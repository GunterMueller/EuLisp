(* b2h.ml -- Convert files with `def-bytecode' forms to a C header

   Note: this has been replaced by b2h.em.

   Note: this is not the original b2h.ml; that wasn't in the youtoo 
   distribution, and Andreas Kind didn't have a copy of it any more.

   This is my best guess at how it worked.

   * If the name of the bytecode contains "branch" it's a branch and
     the branch field is true; otherwise it's not a branch and
     the branch field is false.
   * If the name of the bytecode contains "-neg" it's a backward branch
     and the branch field is true with the value -1; otherwise
     the branch field is true with the value 1.
   * The inlined_arg_size field defaults to zero.
   * An arg that is "byte" or "reg" increases the inlined_arg_size by 1;
     all other args increase the size by 4.

   compile: ocamlc -g -o b2h -custom str.cma b2h.ml -cclib -lstr
   run:     ./b2h cg-bycode{1,2}.em >tkb.b2h.out2

   ??? Rewrite this in youtoo!!!

*)


open Printf

let old_style = ref true

type defbytecode = { name : string; args : string list; number : int }

let r = Str.regexp "^[ \t]*(def-bytecode[ \t]*\\([-a-zA-Z0-9_]+\\)[ \t]*(\\(.*\\))[ \t]*\\([0-9]+\\)"
and branch = Str.regexp "branch"
and neg = Str.regexp "-neg$"
and delim = Str.regexp "[ \t]+"

let arg_size args =
  let rec iter =
    function sum, [] -> sum
      |	sum, ("byte" | "reg") :: rest -> iter ((sum + 1), rest)
      |	sum, _ :: rest -> iter ((sum + 4), rest)
  in iter (0, args)

(* ??? I assume the values can only be 0, -1, and 1. *)
let branch_info name =
  try ignore (Str.search_forward branch name 0);
    try ignore (Str.search_forward neg name 0);
      -1
    with Not_found -> 1
  with Not_found -> 0

let bytecodes = (Hashtbl.create 127 : (int, defbytecode) Hashtbl.t)

let filenames = ref []

let process_file filename =
  filenames := filename :: !filenames;
  let lineno = ref 0 in 
  let inf = open_in filename in
  try while true do
    let line = input_line inf in
    incr lineno;
    if (Str.string_match r line 0) then begin
      let name = Str.matched_group 1 line in
      let args = (try Str.matched_group 2 line with Not_found -> "") in
      let number = Str.matched_group 3 line in
      let args = Str.split delim args in
      let number = int_of_string number in
      let bytecode = { name = name; args = args; number = number } in
      begin try
	ignore (Hashtbl.find bytecodes bytecode.number);
	eprintf "Error: %s:%d: code %d (%x) defined twice (second is %s)\n"
	  filename !lineno bytecode.number bytecode.number bytecode.name
      with Not_found ->
	Hashtbl.add bytecodes bytecode.number bytecode
      end;
    end;
  done with End_of_file -> ()


let date =
  let time = Unix.localtime (Unix.time ())
  in (Printf.sprintf "%04d/%02d/%02d"
     	(time.Unix.tm_year + 1900)
     	(time.Unix.tm_mon + 1)
	time.Unix.tm_mday)


let main () =
  let specs = [
  ]
  and usage = "b2h filename...\n\n\thelp bootstrap Youtoo\n\n" in
  Arg.parse specs process_file usage;
  printf "/* Generated by b2h.ml from %s */\n"
    (String.concat ~sep:", " (List.rev !filenames));
  printf "/* on %s */" date;
  printf "#ifndef BYTECODE2_H\n#define BYTECODE2_H\n";
  printf "#define eul_instr_inlined_arg_size(x) (eul_instr_info[(x)].inlined_arg_size)\n";
  printf "#define eul_instr_branch(x) (eul_instr_info[(x)].branch)\n";
  printf "struct {int inlined_arg_size, branch;} eul_instr_info[256]= {\n";
  for i = 0 to 255 do
    try 
      let bc = Hashtbl.find bytecodes i in
      let n = arg_size bc.args
      and b = branch_info bc.name in 
      if !old_style then
        printf "  {%d, %d}, /* instruction %d (%x)*/\n" n b i i
      else
	printf "  {%d, %d}, /* instruction %d (%x): %s */\n" n b i i bc.name;
    with Not_found ->
      if !old_style then 
	printf "  {%d, %d}, /* instruction %d (%x)*/\n" 0 0 i i
      else
	printf "  {%d, %d}, /* instruction %d (%x): (undefined) */\n" 0 0 i i;
  done;
  printf "};\n\n";
  printf "#endif /* eof */"
  
let _ =
  Printexc.catch main ();
