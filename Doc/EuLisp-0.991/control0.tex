\clause{Expressions, Definitions and Control Forms}
%
\label{control-0}
\index{general}{level-0}
\indexmodule{level-0}
\indexmodule{level-0-macros}
%
\begin{optDefinition}
\noindent
This section gives the syntax of well-formed expressions and describes the
semantics of the special-forms, functions and macros of the level-0 language.
In the case of level-0 macros, the description includes a set of expansion
rules.  However, these descriptions are not prescriptive of any processor and a
conforming program cannot rely on adherence to these expansions.
\end{optDefinition}

\sclause{Simple Expressions}
%
\begin{optPrivate}
    What happens with vectors, instances etc.  They can be printed out, so why
    can't they be constants too.

    Describe relationship of empty list to nil here.

    HED wants ids as well as ids and initializers for \macroref{let}.
\end{optPrivate}
%
\begin{optDefinition}
\noindent
%
\syntaxform{constant}
\ttindex{constant}
\noindent
There are two kinds of constants\index{general}{constant!literal}, literal
constants and defined constants\index{general}{constant!defined}.  Only the
first kind are considered here.  A literal constant is a number, a string, a
character, or the empty list.  The result of processing such a literal constant
is the constant itself---that is, it denotes
itself\index{general}{processing!constants}.
%
\examples
\begin{tabular}{ll}
    \verb+()+ & the empty list\\
    \verb+123+ & a fixed precision integer\\
    \verb+#\a+ & a character\\
    \verb+"abc"+ & a string
\end{tabular}

\defop{defconstant}
%
\Syntax
\defSyntax{defconstant}{
\begin{syntaxx}
    \scdef{defconstant-form}: \ra{} \classref{object} \\
    \>  ( \defopref{defconstant} \scref{constant-name} \scref{form} ) \\
    \scdef{constant-name}: \\
    \>  \scref{identifier}
\end{syntaxx}}%
\showSyntaxBox{defconstant}
%
\begin{arguments}
    \item[identifier] A symbol naming an immutable top-lexical binding to be
    initialized with the value of \sc{form}.

    \item[form] The \sc{form} whose value will be stored in the binding of
    \sc{identifier}.
\end{arguments}
%
\remarks%
The value of \sc{form} is stored in the top-lexical binding of \sc{identifier}.
It is a violation to attempt to modify the binding of a defined constant.

\constant{nil}{null}
%
\remarks%
The symbol {\tt nil} is defined to be immutably bound to the empty list, which
is represented as \nil{}.  The empty list is used to denote the abstract boolean
value \sc{false}.

\constant{t}{symbol}
%
\remarks%
This may be used to denote the abstract boolean value \sc{true}, but so may any
other value than \nil{}.

\syntaxform{symbol}
\ttindex{symbol}
\noindent
The current lexical binding of \syntaxref{symbol} is
returned\index{general}{processing!symbols}.  A symbol can also name a defined
constant---that is, an immutable top-lexical binding.

\defop{deflocal}
%
\Syntax
\defSyntax{deflocal}{
\begin{syntaxx}
    \scdef{deflocal-form}: \ra{} \classref{object} \\
    \>  ( \defopref{deflocal} \scref{local-name} \scref{form} ) \\
    \scdef{local-name}: \\
    \>  \scref{identifier}
\end{syntaxx}}%
\showSyntaxBox{deflocal}
%
\begin{arguments}
    \item[identifier] A symbol naming a binding containing the value of
    \sc{form}.

    \item[form] The \sc{form} whose value will be stored in the binding of
    \sc{identifier}.
\end{arguments}
%
\remarks%
The value of \sc{form} is stored in the top-lexical binding of \sc{identifier}.
The binding created by a \defopref{deflocal} form is mutable.
%
\seealso%
\specopref{setq}.

\specop{quote}
\index{general}{literal}
%
\Syntax
\defSyntax{quote}{
\begin{syntaxx}
    \scdef{quote-form}: \ra{} \scref{object} \\
    \>  ( \specopref{quote} \scref{object} ) \\
    \>  '\scref{object}
\end{syntaxx}}%
\showSyntaxBox{quote}
%
\begin{arguments}
    \item[object] the \sc{object} to be quoted.
\end{arguments}
%
\result%
The result is \scref{object}.
%
\remarks%
The result of processing the expression {\tt (quote \sc{object})} is
\sc{object}.  The \sc{object} can be any object having an external
representation \index{general}{external representation (see also
    \functionref{prin} and \functionref{write})}.  The special form
\specopref{quote} can be abbreviated using {\em apostrophe} --- graphic
representation~\verb+'+\ttsubindex{quote}{abbreviation with {\tt '}} --- so that
{\tt (quote a)} can be written {\tt 'a}.  These two notations are used to
incorporate literal constants \index{general}{literal!quotation} in programs.
It is an error to modify a literal expression
\index{general}{literal!modification of}.
\end{optDefinition}

\sclause{Functions: creation, definition and application}
\label{function}
%
\begin{optPrivate}
    Need more detail about \functionref{apply}.

    The stuff about macroexpand is probably redundant now?  Although I
    suppose we need something at top-level??
\end{optPrivate}
%
\begin{optDefinition}
%
\specop{lambda}
%
\Syntax
\label{lambda-syntax-table}
\defSyntax{lambda}{
\begin{syntaxx}
    \scdef{lambda-form}: \ra{} \classref{function} \\
    \>  ( \specopref{lambda} \scref{lambda-list} \scseqref{form} ) \\
   \scdef{lambda-list}: \\
   \>  \scref{identifier} \\
   \>  \scref{simple-list} \\
   \>  \scref{rest-list} \\
   \scdef{simple-list}: \\
   \>  ( \scseqref{identifier} ) \\
   \scdef{rest-list}: \\
   \>  ( \scseqref{identifier} . \scref{identifier} )
\end{syntaxx}}%
\showSyntaxBox{lambda}
%
\begin{arguments}
    \item[lambda-list] The parameter list of the function conforming to the
    syntax \ref{lambda-syntax-table}.
    \item[form] An expression.
\end{arguments}
%
\result%
A function with the specified \sc{lambda-list} and sequence of \sc{form}s.
%
\remarks%
The function construction operator is \specopref{lambda}.  Access to the
lexical environment of definition is guaranteed.  The syntax of \sc{lambda-list}
is defined in ref{lambda-syntax-table}.

If \sc{lambda-list} is an \sc{identifier}, it is bound to a newly allocated
list of the actual parameters.  This binding \index{general}{scope and extent!of
    \specopref{lambda} bindings} has lexical scope and indefinite extent.  If
\sc{lambda-list} is a {\em simple-list}, the arguments are bound to the
corresponding {\em identifiers}.  Otherwise, \sc{lambda-list} must be a {\em
    rest-list}.  In this case, each \sc{identifier} preceding the dot is bound
to the corresponding argument and the \sc{identifier} succeeding the dot is
bound to a newly allocated list whose elements are the remaining arguments.
These bindings have lexical scope and indefinite extent.  It is a violation
if the same identifier appears more than once in a \sc{lambda-list}.  It is an
error to modify {\em rest-list}.

\syntaxform{defmacro}
%
\Syntax
\defSyntax{defmacro}{
\begin{syntaxx}
    \scdef{defmacro-form}: \ra{} \classref{function} \\
   \>  ( \syntaxref{defmacro} \scref{macro-name} \scref{lambda-list} \scseqref{form} ) \\
   \scdef{macro-name}: \\
   \>  \scref{identifier}
\end{syntaxx}}%
\showSyntaxBox{defmacro}
%
\begin{arguments}
    \item[macro-name] A symbol naming an immutable top-lexical binding to be
    initialized with a function having the specified \sc{lambda-list} and {\em
        body}.

    \item[lambda-list] The parameter list of the function conforming to the
    syntax specified under \specopref{lambda}.

    \item[body] A sequence of forms.
\end{arguments}
%
\remarks%
The \syntaxref{defmacro} form defines a function \index{general}{macro} named by
{\em macro-name} and stores the definition as the top-lexical binding of {\em
    macro-name} \index{general}{macro!definition by \syntaxref{defmacro}}
\index{general}{binding!module}.  The interpretation of the \sc{lambda-list} is
as defined for \specopref{lambda} (see \ref{lambda-syntax-table}).
%
\begin{note}
    A macro is automatically exported from the the module which defines it.  A
    macro cannot be used in the module which defines it.
\end{note}
%
\seealso%
\specopref{lambda}.

\syntaxform{defun}
%
\Syntax
\defSyntax{defun}{
\begin{syntaxx}
    \scdef{defun-form}: \ra{} \classref{function} \\
    \>  \scref{simple-defun} \\
    \>  \scref{setter-defun} \\
   \scdef{simple-defun}: \\
   \>  ( \syntaxref{defun} \scref{function-name} \scref{lambda-list} \\
   \>\>  \scseqref{form} ) \\
   \scdef{setter defun}: \\
   \>  ( \syntaxref{defun} ( \functionref{setter} \scref{function-name} )
   \scref{lambda-list} \\
   \>\>  \scseqref{form} ) \\
   \scdef{function-name}: \\
   \>  \scref{identifier}
\end{syntaxx}}%
\showSyntaxBox{defun}
%
\begin{arguments}
    \item[function-name] A symbol naming an immutable top-lexical binding to be
    initialized with a function having the specified \sc{lambda-list} and {\em
        body}.

    \item[{\tt (setter {\em function-name})}] An expression denoting the setter
    function to correspond to {\em function-name}.

    \item[lambda-list] The parameter list of the function conforming to the
    syntax specified under \specopref{lambda}.

    \item[body] A sequence of forms.
\end{arguments}
%
\remarks%
The \syntaxref{defun} form defines a function named by {\em function-name} and
stores the definition (i) as the top-lexical binding of {\em function-name} or
(ii) as the setter function of {\em function-name}.  The interpretation of the
\sc{lambda-list} is as defined for \specopref{lambda}.
%
\rewriterules
%
\begin{RewriteTable}{defun}{lll}
\begin{minipage}[t]{\columnwidth}%
    \begin{tabbing}%
        00\= \kill
        (\syntaxref{defun} \sc{identifier}\\
        \>\sc{lambda-list}\\
        \>\sc{body})
    \end{tabbing}
\end{minipage}
&\rewrite&
\begin{minipage}[t]{\columnwidth}
    \begin{tabbing}
        00\= \kill
        (\defopref{defconstant} \sc{identifier}\\
        \>(\specopref{lambda} \sc{lambda-list} \\
        \>\sc{body}))
    \end{tabbing}
\end{minipage}\\
\\
\begin{minipage}[t]{\columnwidth}
    \begin{tabbing}
        00\= \kill
        (\syntaxref{defun}\\
        \>(\functionref{setter} \sc{identifier})\\
        \>\sc{lambda-list} \\
        \>\sc{body})
    \end{tabbing}
\end{minipage}
&\rewrite&
\begin{minipage}[t]{\columnwidth}
    \begin{tabbing}
        00\= \kill
        ((\functionref{setter} \functionref{setter}) \\
        \>\sc{identifier}\\
        \>(\specopref{lambda} \sc{lambda-list} \\
        \>\sc{body}))
    \end{tabbing}%
\end{minipage}%
\end{RewriteTable}

\syntaxform{function call}
\index{general}{function!calling}
%
\Syntax
\defSyntax{function-call}{
\begin{syntaxx}
    \scdef{function-call-form}: \ra{} \classref{object} \\
    \>  ( \scref{operator} \scseqref{operand} ) \\
    \scdef{operator}: \\
    \>  \scref{identifier} \\
    \scdef{operand}: \\
    \>  \scref{atomic-expression} \\
    \>  \scref{literal-expression} \\
    \>  \scref{function-call-form}
\end{syntaxx}}%
\showSyntaxBox{function-call}
%
\begin{arguments}
    \item[operator] This may be a symbol---being either the name of a special
    form, or a lexical variable---or a function call, which must result in an
    instance of \classref{function}.

    An error is signalled (condition class:
    \conditionref{invalid-operator}\indexcondition{invalid-operator}) if the
    operator is not a function.

    \item[operand\/$^*$] Each {\em operand} must be either an atomic expression,
    a literal expression or a function call.
\end{arguments}
%
\result%
The result is the value of the application of {\em operator} to the
evaluation of {\em operand\/$^*$}.
%
\remarks%
The {\em operand} expressions are evaluated in order from left to
right.  The {\em operator} expression may be evaluated at any time
before, during or after the evaluation of the operands.
%
\begin{note}
    The above rule for the evaluation of function calls was finally agreed upon
    for this version since it is in line with one strand of common practice, but
    it may be revised in a future version.
\end{note}
%
\seealso%
\syntaxref{constant}, \syntaxref{symbol}, \specopref{quote}.

\condition{invalid-operator}{general-condition}
%
\begin{initoptions}
    \item[invalid-operator, object] The object which was being used as an
    operator.

    \item[operand-list, list] The operands prepared for the operator.
\end{initoptions}
%
\remarks%
Signalled by function call if the operator is not an instance of
\classref{function}.

\function{apply}
%
\Syntax
\defSyntax{apply}{
\begin{syntaxx}
    \scdef{apply-form}: \ra{} \classref{object} \\
    \>  ( \functionref{apply} \scref{function} \scseqref{form} ) \\
    \scdef{function}: \\
    \>  \scref{level-0-expression}
\end{syntaxx}}%
\showSyntaxBox{apply}
%
\begin{arguments}
    \item[function] An expression which must evaluate to an instance of
    \classref{function}.

    \item[form$_1$ ... form$_{n-1}$] A sequence of expressions, which will be
    evaluated according to the rules given in {\em function call}.

    \item[form$_n$] An expression which must evaluate to a proper list.  It is
    an error if {\em obj$_n$} is not a proper list.
\end{arguments}
%
\result%
The result is the result of calling {\em function} with the actual parameter
list created by appending \sc{form}$_n$ to a list of the arguments {\em
    form}$_1$ through \sc{form}$_{n-1}$.  An error is signalled (condition
class: \conditionref{invalid-operator}\indexcondition{invalid-operator}) if the
first argument is not an instance of \classref{function}.
%
\seealso%
{\em function call}, \conditionref{invalid-operator}.
\end{optDefinition}

\sclause{Destructive Operations}
%
\begin{optPrivate}
    The term {\em closer} is a weak specification---cross ref terminology?
\end{optPrivate}
%
\begin{optDefinition}
\noindent
An assignment operation\index{general}{assignment} modifies the contents of a
binding named by a identifier---that is, a variable.

\specop{setq}
%
\Syntax
\defSyntax{setq}{
\begin{syntaxx}
    \scdef{setq-form}: \ra{} \classref{object} \\
    \>  ( \specopref{setq} \scref{identifier} \scref{form} )
\end{syntaxx}}%
\showSyntaxBox{setq}
%
\begin{arguments}
    \item[identifier] The identifier whose lexical binding is to be updated.

    \item[form] An expression whose value is to be stored in the binding of {\em
        identifier}.
\end{arguments}
%
\result%
The result is the value of \sc{form}.
%
\remarks%
The \sc{form} is evaluated and the result is stored in the closest lexical
binding named by \sc{identifier}.  It is a violation to modify an immutable
binding.

\function{setter}
%
\begin{arguments}
    \item[reader] An expression which must evaluate to an instance of
    \classref{function}.
\end{arguments}
%
\result%
The {\em writer\/} corresponding to {\em reader}.
%
\remarks%
A generalized place update facility is provided by \functionref{setter}.  Given
{\em reader}\index{general}{function!reader}, \functionref{setter} returns the
corresponding update function\index{general}{function!writer}.  If no such
function is known to \functionref{setter}, an error is signalled (condition
class: \conditionref{no-setter}\indexcondition{no-setter}).  Thus {\tt
    (\functionref{setter} \functionref{car})} returns the function to update the
\functionref{car} of a pair.  New update functions can be added by using
{setter}'s update function, which is accessed by the expression {\tt
    (\functionref{setter} \functionref{setter})}.  Thus {\tt
    ((\functionref{setter} \functionref{setter}) a-reader a-writer)} installs
the function which is the value of {\tt a-writer} as the writer of the reader
function which is the value of {\tt a-reader}.  All writer functions in this
definition and user-defined writers have the same immutable status as other
standard functions, such that attempting to redefine such a function, for
example {\tt ((\functionref{setter} \functionref{setter}) \functionref{car}
    a-new-value)}, signals an error (condition class:
\conditionref{cannot-update-setter}\indexcondition{<cannot-update-setter>})
%
\seealso%
\defopref{defgeneric}, \macroref{defmethod}, \defopref{defclass},
\syntaxref{defun}.

\condition{no-setter}{general-condition}
%
\begin{initoptions}
    \item[object, object] The object given to \functionref{setter}.
\end{initoptions}
%
\remarks%
Signalled by \functionref{setter} if there is no updater for the given
function.

\condition{cannot-update-setter}{general-condition}
%
\begin{initoptions}
    \item[accessor, object$_1$] The given accessor object.

    \item[updater, object$_2$] The given updater object.
\end{initoptions}
%
\remarks%
Signalled by {\tt (\functionref{setter} \functionref{setter})} if the updater of
the given accessor is immutable.
%
\seealso%
\functionref{setter}.
%
\end{optDefinition}

\sclause{Conditional Expressions}
%
\begin{optPrivate}
    \macroref{cond} rules are strange (RPG).

    Added \macroref{when} and \macroref{unless}.

    Moved these here after October '90 meeting.
\end{optPrivate}
%
\begin{optDefinition}
%
\specop{if}
%
\Syntax
\defSyntax{if}{
\begin{syntaxx}
    \scdef{if-form}: \ra{} \classref{object} \\
    \>  ( \specopref{if} \scref{antecedent} \\
    \>\>\> \scref{consequent} \\
    \>\>  \scref{alternative} ) \\
    \scdef{antecedent}: \\
    \>  \scref{form} \\
    \scdef{consequent}: \\
    \>  \scref{form} \\
    \scdef{alternative}: \\
    \>  \scref{form} \\
\end{syntaxx}}%
\showSyntaxBox{if}
%
\result%
Either the value of \sc{consequent} or {\em alternative\/} depending on the
value of \sc{antecedent}.
%
\remarks%
The {\em antecedent\/} is evaluated.  If the result is \true{} the
\sc{consequent} is evaluated, otherwise the \sc{alternative} is evaluated.  Both
\sc{consequent} and \sc{alternative} must be specified.  The result of
\specopref{if} is the result of the evaluation of whichever of \sc{consequent}
or \sc{alternative} is chosen.

\macro{cond}
%
\Syntax
\defSyntax{cond}{
    \begin{syntaxx}
    \scdef{cond-form}: \ra{} \classref{object} \\
    \>  ( \macroref{cond} \\
    \>\>  \scgseq{{\tt(} \scref{antecedent} \scseqref{consequent} {\tt)}} )
\end{syntaxx}}%
\showSyntaxBox{cond}
%
\remarks%
The \macroref{cond} macro provides a convenient syntax for collections of {\em
    if-then-elseif...else} expressions.
%
\rewriterules
%
\begin{RewriteTable}{cond}{lll}
    (\macroref{cond}) &\rewrite& () \\
    (\macroref{cond} (\sc{antecedent}) \\
    \tts\ldots) &\rewrite&
    (\macroref{or} \sc{antecedent} (\macroref{cond} \ldots)) \\
\begin{minipage}[t]{0.45\columnwidth}
\begin{tabbing}
    00\=00\= \kill
    (\macroref{cond} \\
    \>(\sc{antecedent}$_1$) \\
    \>(\sc{antecedent}$_2$ \scseq{form}) \\
    \>\ldots)
\end{tabbing}
\end{minipage}
&\rewrite&
\begin{minipage}[t]{0.45\columnwidth}
\begin{tabbing}
    (\macroref{or} \= \sc{antecedent}$_1$ \\
    \>00\= \kill
    \>(\macroref{cond} \\
    \>\>(\sc{antecedent}$_2$ \scseq{form}) \\
    \>\>\ldots))
\end{tabbing}
\end{minipage} \\

\begin{minipage}[t]{0.45\columnwidth}
\begin{tabbing}
    00\=00\= \kill
    (\macroref{cond} \\
    \>(\sc{antecedent}$_1$ \scseq{form}) \\
    \>(\sc{antecedent}$_2$ \scseq{form}) \\
    \>\ldots)
\end{tabbing}
\end{minipage}
&\rewrite&
\begin{minipage}[t]{0.45\columnwidth}
\begin{tabbing}
    (\specopref{if} \=\sc{antecedent}$_1$ \\
    \>(\specopref{progn} \scseq{form}) \\
    \>00\= \kill
    \>(\macroref{cond} \\
    \>\>(\sc{antecedent}$_2$ \scseq{form}) \\
    \>\>\ldots))
\end{tabbing}%
\end{minipage}%
\end{RewriteTable}

\macro{and}
%
\Syntax
\defSyntax{and}{
\begin{syntaxx}
    \scdef{and-form}: \ra{} \classref{object} \\
    \>  ( \macroref{and} \scseqref{form} )
\end{syntaxx}}%
\showSyntaxBox{and}
%
\remarks%
The expansion of an \macroref{and} form leads to the evaluation of the sequence
of {\em form}s from left to right.  The first \sc{form} in the sequence that
evaluates to \nil{}\/ stops evaluation and none of the {\em form}s to its right
will be evaluated---that is to say, it is non-strict.  The result of {\tt
    (\macroref{and})} is \true{}.  If none of the {\em form}s evaluate to
\nil{}, the value of the last \sc{form} is returned.
%
\rewriterules
%
\begin{RewriteTable}{and}{lll}
    (\macroref{and}) &\rewrite& \true{} \\
    (\macroref{and} \sc{form}) &\rewrite& \sc{form} \\
    (\macroref{and} \sc{form}$_1$ \sc{form}$_2$ \ldots) &\rewrite&
\begin{minipage}[t]{0.45\columnwidth}
\begin{tabbing}
    (\specopref{if} \= \sc{form}$_1$\\
    \>(\macroref{and} \sc{form}$_2$ \ldots)\\
    \>())
\end{tabbing}%
\end{minipage}%
\end{RewriteTable}

\macro{or}
%
\Syntax
\defSyntax{or}{
\begin{syntaxx}
    \scdef{or-form}: \ra{} \classref{object} \\
    \>  ( \macroref{or} \scseqref{form} )
\end{syntaxx}}%
\showSyntaxBox{or}
%
\remarks%
The expansion of an \macroref{or} form leads to the evaluation of the sequence
of {\em form}s from left to right.  The value of the first \sc{form} that
evaluates to {\em true} is the result of the \macroref{or} form and none of the
{\em form}s to its right will be evaluated---that is to say, it is non-strict.
If none of the forms evaluate to {\em true}, the value of the last \sc{form} is
returned.
%
\rewriterules
%
\begin{RewriteTable}{or}{lll}
    (\macroref{or}) &\rewrite& () \\
    (\macroref{or} \sc{form}) &\rewrite& \sc{form} \\
    (\macroref{or} \sc{form}$_1$ \sc{form}$_2$ \ldots) &\rewrite&
\begin{minipage}[t]{0.45\columnwidth}
\begin{tabbing}
    (\macroref{let} (\=(x \sc{form}$_1$))\\
    \>(\specopref{if} \= x\\
    \>\>x\\
    \>\>(\macroref{or} \sc{form}$_2$ \ldots)))
\end{tabbing}%
\end{minipage}%
\end{RewriteTable}
%
Note that {\tt x} does not occur free in any of \sc{form}$_2$ \ldots {\em
    form}$_n$.
%
\end{optDefinition}

\sclause{Variable Binding and Sequences}
\label{subsubsec:variable-binding}
%
\begin{optPrivate}
    The term {\em closure} is not defined.  Should expand on syntactic variants
    and precise the definition of the scope and extent of the binding.

    Should make clear that \sc{body} is a sequence of forms.  The term
    continuation is not defined.  RPG finds ``The invocation...invalidated''
    obscure.

    In {\tt make-values} is the object copied or shared?  Rather sparse!

    The phrase ``...object named by variable'' is weak.

    Does {\tt multiple-argument-values} copy or not?

    JAP removed all the multiple argument junk until a better model can be
    proposed.

    JAP would like to weaken the requirement that let/cc ``signal an error'' to
    be ``is an error''.  Done.  Perhaps someone will notice this issue now.

    Should \sc{lambda-list} become {\em specialized-lambda-list}?
\end{optPrivate}
%
\begin{optDefinition}

\specop{let/cc}
\ttsubindex{let/cc}{see also \macroref{block} and \macroref{return-from}}
%
\Syntax
\defSyntax{let/cc}{
\begin{syntaxx}
    \scdef{let/cc-form}: \ra{} \classref{object} \\
    \>  ( \specopref{let/cc} \scref{identifier} \scseqref{form} )
\end{syntaxx}}%
\showSyntaxBox{let/cc}
%
\begin{arguments}
    \item[\scref{identifier}] To be bound to the continuation of the
    \specopref{let/cc} form.
    \item[\scseqref{form}] A sequence of forms to evaluate.
\end{arguments}
%
\result%
The result of evaluating the last form in \sc{body} or the value of
the argument given to the continuation bound to \sc{identifier}.
%
\remarks%
The \sc{identifier} is bound to a new location, which is initialized with the
continuation of the \specopref{let/cc} form.  This binding is immutable and has
lexical scope and indefinite extent\index{general}{scope and extent!of
    \specopref{let/cc} binding}.  Each form in \sc{body} is evaluated in order
in the environment extended by the above binding.  It is an error to call the
continuation outside the dynamic extent of the \specopref{let/cc} form that
created it.  The continuation is a function of one argument.  Calling the
continuation causes the restoration of the lexical environment and dynamic
environment that existed before entering the \specopref{let/cc} form.
%
\examples%
An example of the use of \specopref{let/cc} is given in
example~\ref{example:pathopen}.  The function {\tt path-open} takes a list of
paths, the name of a file and list of options to pass to {\tt open}.  It tries
to open the file by appending the name to each path in turn.  Each time {\tt
    open} fails, it signals a condition that the file was not found which is
trapped by the handler function.  That calls the continuation bound to fail to
cause it to try the next path in the list.  When {\tt open} does find a file,
the continuation bound to {\tt succeed} is called with the stream as its
argument, which is subsequently returned to the caller of {\tt path-open}.  If
the path list is exhausted, \genericref{map} (section~\ref{collection})
terminates and an error (condition class: \conditionref{cannot-open-path}) is
signalled.
%
\begin{example}
\label{example:pathopen}
\examplecaption{using \specopref{let/cc}}
{\syntax
(defun path-open (pathlist name . options)
  (let/cc succeed
    (map
      (lambda (path)
        (let/cc fail
          (with-handler
            (lambda (condition resume) (fail ()))
            (succeed (apply open
                       (format nil "~a/~a" path name)
                       options)))))
      pathlist)
    (error
      (format nil
        "path-open: cannot open stream for (~a) ~a"
        pathlist name)
      <cannot-open-path>)))
\endsyntax}
\end{example}
%
\seealso%
\macroref{block}, \macroref{return-from}.

\macro{block}
%
\ttsubindex{block}{see also \specopref{let/cc}}
\Syntax
\defSyntax{block}{
\begin{syntaxx}
    \scdef{block-form}: \ra{} \classref{object} \\
    \>  ( \macroref{block} \scref{identifier} \scseqref{form} )
\end{syntaxx}}%
\showSyntaxBox{block}
%
\remarks%
The block expression is used to establish a statically scoped binding of an
escape function.  The block {\em variable} is bound to the
continuation\index{general}{continuation} of the block.  The continuation can be
invoked anywhere within the block by using \macroref{return-from}.  The {\em
    form}s are evaluated in sequence and the value of the last one is returned
as the value of the block form.  See also \specopref{let/cc}.
%
\rewriterules
%
\begin{RewriteTable}{block}{lll}
    (\macroref{block} \sc{identifier}) &\rewrite& ()\\
    (\macroref{block} \sc{identifier}  &\rewrite&
    (\specopref{let/cc} \sc{identifier} \\
    \tts\scseq{form})                    && \tts\scseq{form})
\end{RewriteTable}
%
The rewrite for \macroref{block} does not prevent the \macroref{block} being
exited from anywhere in its dynamic extent, since the function bound
to \sc{identifier} is a first-class item and can be passed as an
argument like other values.
%
\seealso%
\macroref{return-from}.

\macro{return-from}
\ttsubindex{return-from}{see also \specopref{let/cc}}
%
\Syntax
\defSyntax{return-from}{
\begin{syntaxx}
    \scdef{return-from-form}: \ra{} \classref{object} \\
    \>  ( \macroref{return-from} \scref{identifier} \scoptref{form} )
\end{syntaxx}}%
\showSyntaxBox{return-from}
%
\remarks%
In \macroref{return-from}, the \sc{identifier} names the continuation of
the (lexical) \macroref{block} from which to return.
%An error is signalled
%(condition class: {\tt
%<invalid-return-continuation>}\indexcondition{invalid-return-continuation})
%if the value of the variable named by \sc{identifier} is not a
%continuation.
\macroref{return-from} is the invocation of the continuation of the block
named by \sc{identifier}.  The \sc{form} is evaluated and the value
is returned as the value of the block named by \sc{identifier}.
%
\rewriterules
%
\begin{RewriteTable}{return-from}{lll}
    (\macroref{return-from} \sc{identifier}) &\rewrite& (\sc{identifier} ())\\
\begin{minipage}[t]{0.45\columnwidth}
\begin{tabbing}
    00\= \kill
    (\macroref{return-from} \\
    \>\sc{identifier} \sc{form})
\end{tabbing}
\end{minipage}
&\rewrite& (\sc{identifier} \sc{form})
\end{RewriteTable}
%
\seealso%
\macroref{block}.

\specop{labels}
%
\Syntax
\defSyntax{labels}{
\begin{syntaxx}
    \scdef{labels-form}: \ra{} \classref{object} \\
    \>  ( \specopref{labels} \\
    \>\>  ( \scseqref{function-definition} ) \\
    \>\>  \scseqref{form} ) \\
    \scdef{function-definition}: \\
    \>  ( \scref{identifier} \scref{lambda-list} \scseqref{form} )
\end{syntaxx}}%
\showSyntaxBox{labels}
%
\begin{arguments}
    \item[identifier] A symbol naming a new inner-lexical binding to be
    initialized with the function having the \sc{lambda-list} and \sc{body}
    specified.

    \item[lambda-list] The parameter list of the function conforming to the
    syntax specified below.

    \item[body] A sequence of forms.

    \item[labels-body] A sequence of forms.
\end{arguments}
%
\result%
The \specopref{labels} operator provides for local mutually recursive function
creation.  Each \sc{identifier} is bound to a new inner-lexical binding
initialized with the function constructed from \sc{lambda-list} and \sc{body}.
The scope of the {\em identifier}s is the entire \specopref{labels}
form\index{general}{scope and extent!in \specopref{labels} expressions}.  The
\sc{lambda-list} is either a single variable or a list of variables---see
\specopref{lambda}.  Each form in {\em labels-body} is evaluated in order in
the lexical environment extended with the bindings of the {\em identifier}s.
The result of evaluating the last form in {\em labels-body}\/ is returned as the
result of the \specopref{labels} form.

\macro{let}
%
\Syntax
\defSyntax{let}{
\begin{syntaxx}
    \scdef{let-form}: \ra{} \classref{object} \\
    \>  ( \macroref{let} \scoptref{identifier} ( \scseqref{binding} ) \\
    \>\>  \scseqref{form} ) \\
    \scdef{binding}: \\
    \>  \scref{identifier} \\
    \> ( \scref{identifier} \scref{form} )
\end{syntaxx}}%
\showSyntaxBox{let}
%
\remarks%
The optional \sc{identifier}\/ denotes that the let form can be called from
within its \sc{body}.  This is an abbreviation for \specopref{labels} form in
which \sc{identifier} is bound to a function whose parameters are the
identifiers of the {\em binding\/}s of the \macroref{let}, whose body is that of
the \macroref{let} and whose initial call passes the values of the initializing
form of the {\em binding\/}s.  A binding is specified by either an identifier or
a two element list of an identifier and an initializing form.  All the
initializing forms are evaluated in order from left to right in the current
environment and the variables named by the identifiers in the {\em binding}s are
bound to new locations holding the results.  Each form in \sc{body} is
evaluated in order in the environment extended by the above bindings.  The
result of evaluating the last form in \sc{body} is returned as the result of
the \macroref{let} form.
%
\rewriterules
%
\begin{RewriteTable}{let}{lll}
    (\macroref{let} () \scseq{form}) &\rewrite& (\specopref{progn} \scseq{form}) \\
\begin{minipage}[t]{\columnwidth}
\begin{tabbing}
    (\macroref{let} (\=(\sc{id}$_1$ \sc{form}$_1$) \\
    \>(\sc{id}$_2$ \sc{form}$_2$) \\
    \>\sc{id}$_3$ \\
    \>\ldots)\\
    00\= \kill
    \>\scseq{form})
\end{tabbing}
\end{minipage}
&\rewrite&
\begin{minipage}[t]{\columnwidth}
\begin{tabbing}
    00\=00\=00\= \kill
    ((\specopref{lambda} (\sc{id}$_1$ \sc{id}$_2$ \sc{id}$_3$ \ldots) \\
    \>\>\scseq{form}) \\
    \>\sc{form}$_1$ \sc{form}$_2$ () \ldots) \\
\end{tabbing}
\end{minipage}\\
\begin{minipage}[t]{\columnwidth}
\begin{tabbing}
    (\macroref{let} \={\em id$_0$}\\
    \>(\=(\sc{id}$_1$ \sc{form}$_1$) \\
    \>\>\sc{id}$_2$ \\
    \>\>\ldots)\\
    00\= \kill
    \>\scseq{form})
\end{tabbing}
\end{minipage}
&\rewrite&
\begin{minipage}[t]{\columnwidth}
\begin{tabbing}
    00\= \kill
    (\specopref{labels}\\
    \>(\=(\sc{id}$_0$ (\sc{id}$_1$ \sc{id}$_2$ \ldots) \\
    \>\>\scseq{form})) \\
    \>({\em id$_0$} \sc{form}$_1$ () \ldots))
\end{tabbing}%
\end{minipage}%
\end{RewriteTable}

\macro{let*}
%
\Syntax
\defSyntax{let*}{
\begin{syntaxx}
    \scdef{let-star-form}: \ra{} \classref{object} \\
    \>  ( \macroref{let*} ( \scseqref{binding} ) \\
    \>\>  \scseqref{form} )
\end{syntaxx}}%
\showSyntaxBox{let*}
%
\remarks%
A {\em binding} is specified by a two element list of a variable and an
initializing form.  The first initializing form is evaluated in the
current environment and the corresponding variable is bound to a new
location containing that result.  Subsequent bindings are processed in
turn, evaluating the initializing form in the environment extended by
the previous binding.  Each form in \sc{body} is evaluated in order in
the environment extended by the above bindings.  The result of
evaluating the last form is returned as the result of the \macroref{let*}
form.
%
\rewriterules
%
\begin{RewriteTable}{let*}{lll}
    (\macroref{let*} () \scseq{form}) &\rewrite& (progn \scseq{form}) \\
\begin{minipage}[t]{\columnwidth}
\begin{tabbing}
    (\macroref{let*} (\=(\sc{var}$_1$ \sc{form}$_1$) \\
    \>(\sc{var}$_2$ \sc{form}$_2$) \\
    \>\sc{var}$_3$\\
    \>\ldots) \\
    00\= \kill
    \>\scseq{form})
\end{tabbing}%
\end{minipage}%
&\rewrite&
\begin{minipage}[t]{\columnwidth}%
\begin{tabbing}%
    00\= \kill
    (\macroref{let} ((\sc{var}$_1$ \sc{form}$_1$)) \\
    \>(\macroref{let*} (\=(\sc{var}$_2$ \sc{form}$_2$) \\
    \>\>\sc{var}$_3$\\
    \>\>\ldots) \\
    00\=00\= \kill
    \>\>\scseq{form}))
\end{tabbing}%
\end{minipage}%
\end{RewriteTable}

\specop{progn}
%
\Syntax
\defSyntax{progn}{
\begin{syntaxx}
    \scdef{progn-form}: \ra{} \classref{object} \\
    \>  ( \specopref{progn} \scseqref{form} )
\end{syntaxx}}%
\showSyntaxBox{progn}
%
\begin{arguments}
    \item[form\/$^*$] A sequence of forms and in certain circumstances, defining
    forms.
\end{arguments}
%
\result%
The sequence of {\em form}s is evaluated from left to right, returning the value
of the last one as the result of the \specopref{progn} form.  If the sequence
of forms is empty, \specopref{progn} returns \nil{}.
%
\remarks%
If the \specopref{progn} form occurs enclosed only by \specopref{progn} forms
and a \syntaxref{defmodule} form, then the {\em form}s within the
\specopref{progn} can be defining forms, since they appear in the top-lexical
environment.  It is a violation for defining forms to appear in inner-lexical
environments.

% \specop{multiple-value-bind}{lambda-list form body}{obj}
% \gdef\multipleValueBind{\verb+(multiple-value-bind+ lambda-list form
%     body\verb+)+} The \sc{form} is evaluated and the elements of {\em
%     lambda-list} are bound to the resulting values.  The cardinality of the
% resulting values might not agree with the arity of the {\tt
%     multiple-value-bind} \sc{lambda-list}.  If the number of values is less
% than the arity, the excess formal parameters receive the value \nil{}.  It is
% an error if the number of values is greater than the arity.  A conforming
% processor must support a minimum {\tt multiple-value-bind} arity of 15.  If
% \sc{lambda-list} is an \sc{identifier}, it is bound to a newly allocated list
% of the multiple values.  If \sc{lambda-list} is a {\em rest-list}, each
% \sc{identifier} preceding the dot is bound to its corresponding value in the
% multiple value and the {\em identifier} succeeding the dot is bound to a newly
% allocated list of the remaining elements of the multiple value.  These
% bindings have lexical scope and extent.  Each form in \sc{body} is evaluated
% in order in the environment extended by the above bindings.
%
%\standard{values}{obj$_1$ ... obj$_n$}{multiple-value(obj)}
%The values {\em obj$_1$} to {\em obj$_n$} are passed to the
%dynamically closest enclosing instance of {\tt multiple-value-bind}.
%If there is no such enclosing {\tt multiple-value-bind}, the
%excess values are discarded and only {\em obj$_1$} is returned.

\specop{unwind-protect}
%
\Syntax
\defSyntax{unwind-protect}{
\begin{syntaxx}
    \scdef{unwind-protect-form}: \ra{} \classref{object} \\
    \>  ( \specopref{unwind-protect} \scref{protected-form} \\
    \>\>  \scseqref{after-form} )
 \end{syntaxx}}%
\showSyntaxBox{unwind-protect}
%
\begin{arguments}
    \item[protected-form] A form.
    \item[after-form$^*$] A sequence of forms.
\end{arguments}
%
\result%
The value of {\em protected-form}.
%
\remarks%
The normal action of \specopref{unwind-protect} is to process {\em
    protected-form} and then each of {\em after-form}s in order, returning the
value of {\em protected-form} as the result of \specopref{unwind-protect}.  A
non-local exit from the dynamic extent of {\em protected-form}, which can be
caused by processing a non-local exit form, will cause each of {\em after-form}s
to be processed before control goes to the continuation specified in the
non-local exit form.  The {\em after-form}s are not protected in any way by the
current \specopref{unwind-protect}.  Should any kind of non-local exit occur
during the processing of the {\em after-form}s, the {\em after-form}s being
processed are not reentered.  Instead, control is transferred to wherever
specified by the new non-local exit but the {\em after-form}s of any intervening
\specopref{unwind-protect}s between the dynamic extent of the target of control
transfer and the current \specopref{unwind-protect} are evaluated in increasing
order of dynamic extent.
%
\examples
%
\begin{example}
\label{example:unwind-loop}
\examplecaption{Interaction of \specopref{unwind-protect} with non-local exits}
{\syntax
(progn
  (let/cc k1
    (labels
      ((loop
         (let/cc k2 (unwind-protect (k1 10) (k2 99))
         ;; continuation bound to {\tt k2}
         (loop))))
      (loop)))
  ;; continuation bound to {\tt k1}
  ...)
\endsyntax}
\end{example}
%
The code fragment in example~\ref{example:unwind-loop} illustrates both the use
of \specopref{unwind-protect} and of a difference between the semantics of
\eulisp\ and some other Lisps.  Stepping through the evaluation of this form:
{\tt k1} is bound to the continuation of its \specopref{let/cc} form; a
recursive function named {\tt loop} is constructed, {\tt loop} is called from
the body of the \specopref{labels} form; {\tt k2} is bound to the continuation
of its \specopref{let/cc} form; \specopref{unwind-protect} calls {\tt k1}; the
after forms of \specopref{unwind-protect} are evaluated in order; {\tt k2} is
called; {\tt loop} is called; etc..  This program loops indefinitely.
%
\end{optDefinition}

\sclause{Quasiquotation Expressions}
\gdef\module{syntax-0}
\label{backquote}
\index{general}{quasiquotation}
\index{general}{backquoting}
%
\begin{optPrivate}
    Should it be an error to splice an improper list even if its the last item?
\end{optPrivate}
%
\begin{optDefinition}

\macro{quasiquote}
%
\Syntax
\defSyntax{quasiquote}{
\begin{syntaxx}
    \scdef{quasiquote-form}: \ra{} \classref{object} \\
    \> ( \macroref{quasiquote} \scref{skeleton} ) \\
    \> `\scref{skeleton}
\end{syntaxx}}%
\showSyntaxBox{quasiquote}
%
\remarks%
Quasiquotation is also known as backquoting.  A \macroref{quasiquote}d
expression is a convenient way of building a structure.  The {\em skeleton}
describes the shape and, generally, many of the entries in the structure but
some holes remain to be filled.  The \macroref{quasiquote} macro can be
abbreviated by using the glyph called {\em grave accent}
(\verb+`+)\ttsubindex{quasiquote}{abbreviation with {\tt `}}, so that {\tt
    (\macroref{quasiquote} {\em expression})} can be written {\tt `{\em
        expression}}.

\syntaxform{unquote}
\Syntax
\defSyntax{unquote}{
\begin{syntaxx}
    \scdef{unquote-form}: \ra{} \classref{object} \\
    \>  ( \syntaxref{unquote} \scref{form} ) \\
    \>  ,\scref{form}
\end{syntaxx}}%
\showSyntaxBox{unquote}
%
\remarks%
See \syntaxref{unquote-splicing}.

\syntaxform{unquote-splicing}
\Syntax
\defSyntax{unquote-splicing}{
\begin{syntaxx}
    \scdef{unquote-splicing-form}: \ra{} \classref{object} \\
    \>  ( \syntaxref{unquote-splicing} \scref{form} ) \\
    \> ,@\scref{form}
\end{syntaxx}}%
\showSyntaxBox{unquote-splicing}
%
\remarks%
The holes in a quasiquoted expression are identified by unquote expressions of
which there are two kinds---forms whose value is to be inserted at that location
in the structure and forms whose value is to be spliced into the structure at
that location.  The former is indicated by an \syntaxref{unquote} expression and
the latter by an \syntaxref{unquote-splicing} expression.  In
\syntaxref{unquote-splicing} the \sc{form} must result in a proper list.  The
insertion of the result of an unquote-splice expression is as if the opening and
closing parentheses of the list are removed and all the elements of the list are
appended in place of the unquote-splice expression.
%An
%error is signalled (condition class: {\tt
%<unquote-no-context>}\indexcondition{unquote-no-context}) if either of
%these syntaxes occurs outside the scope of a {\tt quasiquote}
%expression.

The syntax forms \syntaxref{unquote} and \syntaxref{unquote-splicing} can be
abbreviated respectively by using the glyph called {\em comma}
(\verb+,+)\ttsubindex{unquote}{abbreviation with {\tt ,}} preceding an
expression and by using the diphthong {\em comma} followed by the glyph called
{\em commercial at} (\verb+,@+)\ttindex{unquote-splicing!abbreviation to ,@}
preceding a form.  Thus, {\tt (\syntaxref{unquote} a)} may be written {\tt ,a}
and {\tt (\syntaxref{unquote-splicing} a)} can be written {\tt ,@a}.
%
\examples
{\tt
\begin{tabular}{lll}
    `(a ,(list 1 2) b) & $\rightarrow$ & (a (1 2) b)\\
    `(a ,@(list 1 2) b) & $\rightarrow$ & (a 1 2 b)
\end{tabular}}
%
\end{optDefinition}

\sclause{Summary of Level-0 Expressions and Definitions}
%
\begin{optDefinition}
\noindent
This section gives the syntax of all level-0 expressions and definitions
together.  The syntax of data objects is given in the section pertaining to the
class and is summarized in section~\ref{object-syntax-summary}.  \raggedbottom
%
\ssclause{Syntax of Level-0 defining forms}
%
\showSyntax{defmodule-0}
\showSyntax{defclass}
\showSyntax{defgeneric}
\showSyntax{defmethod}
\showSyntax{defconstant}
\showSyntax{deflocal}
\showSyntax{defmacro}
\showSyntax{defun}

\ssclause{Syntax of Level-0 expressions}
%
\showSyntax{generic-lambda}
\showSyntax{lambda}
\showSyntax{function-call}
\showSyntax{quote}
\showSyntax{setq}
\showSyntax{if}
\showSyntax{let/cc}
\showSyntax{labels}
\showSyntax{progn}
\showSyntax{unwind-protect}
\showSyntax{apply}

\ssclause{Syntax of Level-0 macros}
%
\showSyntax{cond}
\showSyntax{and}
\showSyntax{or}
\showSyntax{block}
\showSyntax{return-from}
\showSyntax{let}
\showSyntax{let*}
\showSyntax{quasiquote}
\showSyntax{unquote}
\showSyntax{unquote-splicing}

\flushbottom
\end{optDefinition}
