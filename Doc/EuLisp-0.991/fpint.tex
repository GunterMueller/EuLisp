\sclause{Fixed Precision Integers}
\label{fpi}
\label{spint}
\index{general}{fixed precision integer}
\index{general}{fixed precision integer!module}
\index{general}{level-0 modules!fpi}
\begin{optDefinition}

    The defined name of this module is {\tt fpi}.  Arithmetic operations for
    \classref{fixed-precision-integer} are defined by methods on the generic
    functions defined in the number module:
%
\begin{flushleft}
    \genericref{binary+},\ttindex{binary+}\indexmeth{binary+}
    \genericref{binary-},\ttindex{binary-}\indexmeth{binary-}
    \genericref{binary*},\ttindex{binary*}\indexmeth{binary*}
    \genericref{binary/},\ttindex{binary/}\indexmeth{binary/}
    \genericreflabel{binary\protect\%}{binarypercent},\ttindex{binary\protect\%}\indexmeth{binary\protect\%}
    \genericref{binary<},\ttindex{binary<}\indexmeth{binary<}
    \genericref{binary=},\ttindex{binary=}\indexmeth{binary=}
    \genericref{binary-gcd},\ttindex{binary-gcd}\indexmeth{binary-gcd}
    \genericref{binary-lcm},\ttindex{binary-lcm}\indexmeth{binary-lcm}
    \genericref{binary-mod},\ttindex{binary-mod}\indexmeth{binary-mod}
    \genericref{negate},\ttindex{negate}\indexmeth{negate}
    \genericref{zerop}\ttindex{zerop}\indexmeth{zerop}
\end{flushleft}

\noindent
and in the integer module:
\begin{flushleft}
    \genericref{evenp}\ttindex{evenp}\indexmeth{evenp}
\end{flushleft}

\noindent
The behaviour of these functions is defined in the modules noted
above.

\derivedclass{fixed-precision-integer}{integer}
\index{general}{level-0 classes!\theclass{fixed-precision-integer}}

The class of all instances of fixed precision integers.

\constant{<fpi>}{fixed-precision-integer}

\remarks%
A constant binding whose value is \classref{fixed-precision-integer}.

\function{fixed-precision-integer-p}
\begin{arguments}
\item[object] Object to examine.
\end{arguments}

\result%
Returns {\em object\/} if it is fixed precision integer, otherwise
\nil.

\constant{most-positive-fixed-precision-integer}{fixed-precision-integer}
\index{general}{implementation-defined!most positive fixed precision integer}
\index{general}{conformity-clause!most positive fixed precision integer}

\remarks%
This is an implementation-defined constant.  A conforming processor
must support a value greater than or equal to $32767$ and greater than
or equal to the value of {\tt
maximum-vector-index}\index{general}{implementation-defined!most positive
fixed precision integer}\index{general}{conformity-clause!most positive
fixed precision integer}.

\constant{most-negative-fixed-precision-integer}{fixed-precision-integer}
\index{general}{implementation-defined!most negative fixed precision integer}
\index{general}{conformity-clause!most negative fixed precision integer}

\remarks%
This is an implementation-defined constant.  A conforming processor
must support a value less than or equal to
$-32768$\index{general}{implementation-defined!most positive fixed
precision integer}\index{general}{conformity-clause!most positive fixed
precision integer}.

\method{equal}
\begin{specargs}
\item[integer$_1$, \classref{fixed-precision-integer}] A fixed precision integer.
\item[integer$_2$, \classref{fixed-precision-integer}] A fixed precision integer.
\end{specargs}

\result%
The result of calling \genericref{binary=} on {\em integer$_1$} and {\em
integer$_2$}.

\remarks%
The difference between \genericref{equal} and \functionref{=} is that the former
only compares numbers of the same class, whereas the latter coerces the numbers
to be of the same class before comparison.

\converter{string}
%
\begin{specargs}
    \item[integer, \classref{fixed-precision-integer}] An integer.
\end{specargs}
%
\result%
Constructs and returns a string, the characters of which correspond to
the external representation of {\em integer\/} in decimal notation.

\converter{double-float}
\begin{specargs}
\item[integer, \classref{fixed-precision-integer}] An integer.
\end{specargs}

\result%
Returns a double float whose value is the floating point approximation
to {\em integer}.

\method{generic-prin}
\begin{specargs}
\item[integer, \classref{fixed-precision-integer}] An integer to be output on {\em stream}.
\item[stream, \classref{stream}] The stream on which the representation is
to be output.
\end{specargs}

\result%
The fixed precision integer supplied as the first argument.

\remarks%
Outputs external representation of {\em integer\/} on {\em stream\/}
in decimal as defined by {\em decimal integer} at the beginning of
this section.

\method{generic-write}
\begin{specargs}
\item[integer, \classref{fixed-precision-integer}] An integer to be output on {\em stream}.
\item[stream, \classref{stream}] The stream on which the representation is
to be output.
\end{specargs}

\result%
The fixed precision integer supplied as the first argument.

\remarks%
Outputs external representation of {\em integer\/} on {\em stream\/}
in decimal as defined by {\em decimal integer} at the beginning of
this section.

\end{optDefinition}
