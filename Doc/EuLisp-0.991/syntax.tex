\clause{Lexical Syntax}
\label{syntax}
\index{general}{lexical syntax}
%
\sclause{Character Set}
\label{character-set}
\index{general}{character set}
%
\begin{optDefinition}
%
Case\index{general}{case sensitivity} is distinguished in each of characters,
strings and identifiers, so that {\tt variable-name} and {\tt Variable-name} are
different, but where a character is used in a positional number representation
(\eg \verb+#\x3Ad+) the case is ignored.  Thus, case is also significant
in this definition and, as will be observed later, all the special form and
standard function names are lower case.  In this section, and throughout this
text, the names for individual character glyphs are those used in \cite{iso646}.

The minimal character set \index{general}{character!minimal character set} to
support \eulisp\ is defined in syntax table~\ref{character-set}.  The language
as defined in this text uses only the characters given in this table.  Thus,
left hand sides of the productions in this table define and name groups of
characters which are used later in this definition: \scref{decimal-digit},
\scref{upper-letter}, \scref{lower-letter}, \scref{letter},
\scref{other-character} and \scref{special-character}.  Any character not
specified here is classified under \scref{other-character}, which permits its
use as an initial or a constituent character of an identifier (see
section~\ref{symbol}).
%
\Syntax
\defSyntax{character-set}{
\begin{syntax}
    \scdef{decimal-digit}: one of \\
    \>  0 1 2 3 4 5 6 7 8 9 \\
    \scdef{upper-letter}: one of \\
    \>  A B C D E F G H I J K L M \\
    \>  N O P Q R S T U V W X Y Z \\
    \scdef{lower-letter}: one of \\
    \>  a b c d e f g h i j k l m \\
    \>  n o p q r s t u v w x y z \\
    \scdef{letter}: \\
    \>  \scref{upper-letter} \\
    \>  \scref{lower-letter} \\
    \scdef{normal-other-character}: one of \\
    \>  * / < = > + . \\
    \scdef{other-character}: \\
    \>  \scref{normal-other-character}
    \>  - \\
    \scdef{special-character}: one of \\
    \>  ; ' , \textbackslash{} " \# ( ) ` | @ \\
    \scdef{level-0-character}: \\
    \>  \scref{decimal-digit} \\
    \>  \scref{letter} \\
    \>  \scref{other-character} \\
    \>  \scref{special-character}
\end{syntax}}
\showSyntaxBox{character-set}
%
\end{optDefinition}
%
\sclause{Whitespace and Comments}
\begin{optPrivate}
    \verb+\#tab+ is omitted from whitespace because it is not a standard
    character.

    JWD: Is \verb+#\tab+ whitespace?  Section 2.4.2 does not include it, but the
    formal syntax in section A.8 does.  In Common Lisp, it is a "semi-standard"
    character, which may indicate that it ought to be somewhat of a special
    case.

    Need to be able to allow whitespace as a constituent of numbers.  Leave for
    later!  Define an extended input syntax??
\end{optPrivate}
%
\begin{optDefinition}
Whitespace characters\index{general}{whitespace} are space and
newline.  The newline character is also used to represent end of record for
configurations providing such an input model, thus, a reference to newline in
this definition should also be read as a reference to end of record.  The only
use of whitespace is to improve the legibility of programs for human readers.
Whitespace separates tokens and is only significant in a string or when it
occurs escaped within an identifier.

A comment\index{general}{comment} is introduced by the \scref{comment-begin}
\index{general}{comment!\sc{comment-begin} glyph} glyph, called \sc{semicolon}
(\verb+;+) and continues up to, but does not include, the end of the line:
%
\Syntax
\defSyntax{comment}{
\begin{syntax}
    \scdef{comment}: \\
    \>  \scref{comment-begin} \sc{all subsequent characters} \\
    \>\>  \sc{up to the end of the line} \\
    \scdef{comment-begin}: \\
    \>  ;
\end{syntax}}
\showSyntaxBox{comment}

Hence, a comment cannot occur in the middle of a token because of the whitespace
in the form of the newline.  Thus a comment is equivalent to whitespace.
%
\begin{note}
    There is no notation in \eulisp\ for block comments.
\end{note}
\end{optDefinition}

\sclause{Objects}
\begin{optDefinition}
An object is either a \scref{literal}, a \scref{symbol} or a \scref{list}.  The
syntax of the classes of objects that can be read by \eulisp\ is defined in the
section of this definition corresponding to the class as defined below:
%
\Syntax
\label{object-syntax}
\defSyntax{object}{
\begin{syntax}
    \scdef{object}: \\
    \>  \scref{literal} \\
    \>  \scref{list}      \>\>\>\S\ref{list} \\
    \>  \scref{symbol}    \>\>\>\S\ref{symbol} \\
    \scdef{literal}: \\
    \>  \scref{boolean} \\
    \>  \scref{character} \>\>\>\S\ref{character} \\
    \>  \scref{float}     \>\>\>\S\ref{float} \\
    \>  \scref{integer}   \>\>\>\S\ref{integer} \\
    \>  \scref{string}    \>\>\>\S\ref{string} \\
    \>  \scref{vector}    \>\>\>\S\ref{vector}
\end{syntax}}
\showSyntaxBox{object}

\sclause{Boolean}
\label{boolean}
\index{general}{boolean}
%
A boolean value is either \sc{false} \index{general}{false}, which is
represented by the empty list---written \nil{} and is also the value of
\constantref{nil}---or \sc{true} \index{general}{true}, which is represented by
any other value than \nil{} or if specified as \true{}:
%
\Syntax
\label{object-syntax}
\defSyntax{boolean}{
\begin{syntax}
    \scdef{boolean}: \\
    \>  \scref{true} \\
    \>  \scref{false} \\
    \scdef{true}: \\
    \>  \true \\
    \>  \scref{object} not \nil \\
    \scdef{false}: \\
    \>  \nil \\
    \>  \constantref{nil}
\end{syntax}}
\showSyntaxBox{boolean}

Although the class containing exactly this set of values is not defined in the
language, notation is abused for convenience and \scref{boolean}
\index{general}{boolean} is defined, for the purposes of this definition, to
mean that set of values.

The syntax for \scref{identifier}s \index{general}{identifier!syntax}
\index{general}{syntax!identifier} corresponds to that for \scref{symbol}s.

\end{optDefinition}
