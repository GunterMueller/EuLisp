\sclause{Dynamic Binding}
\label{control-1}
%
\begin{optPrivate}
    HED wants ids as well as ids and initializers for \specopref{dynamic-let}.
\end{optPrivate}
%
\begin{optDefinition}
%
\specop{dynamic}
%
\Syntax
\defSyntax{dynamic}{
\begin{syntaxx}
    \scdef{dynamic-form}: \ra{} \classref{object} \\
    \>  ( \specopref{dynamic} \scref{identifier} )
\end{syntaxx}}%
\showSyntaxBox{dynamic}
%
\begin{arguments}
    \item[identifier] A symbol naming a dynamic binding.
\end{arguments}
%
\result%
The value of closest dynamic binding of \scref{identifier} is returned.  If no
visible binding exists, an error is signaled (condition:
\conditionref{unbound-dynamic-variable}
\indexcondition{unbound-dynamic-variable}).

\specop{dynamic-setq}
%
\Syntax
\defSyntax{dynamic-setq}{
\begin{syntaxx}
    \scdef{dynamic-setq-form}: \ra{} \classref{object} \\
    \>  ( \specopref{dynamic-setq} \scref{identifier} \scref{form} )
\end{syntaxx}}%
\showSyntaxBox{dynamic-setq}
%
\begin{arguments}
    \item[identifier] A symbol naming a dynamic binding to be updated.

    \item[form] An expression whose value will be stored in the dynamic binding
    of \scref{identifier}.
\end{arguments}
%
\result%
The value of \scref{form}.
%
\remarks%
The \scref{form} is evaluated and the result is stored in the closest dynamic
binding of \scref{identifier}.  If no visible binding exists, an error is
signalled (condition: \conditionref{unbound-dynamic-variable}
\indexcondition{unbound-dynamic-variable}).

\condition{unbound-dynamic-variable}{general-condition}
%
\begin{initoptions}
    \item[symbol, symbol] A symbol naming the (unbound) dynamic variable.
\end{initoptions}
%
\remarks%
Signalled by \specopref{dynamic} or \specopref{dynamic-setq} if the given
dynamic variable has no visible dynamic binding.

\specop{dynamic-let}
%
\Syntax
\defSyntax{dynamic-let}{
\begin{syntaxx}
    \scdef{dynamic-let-form}: \ra{} \classref{object} \\
    \>  ( \specopref{dynamic-let} \scseqref{binding} \\
    \>\>  \scseqref{form} )
\end{syntaxx}}%
\showSyntaxBox{dynamic-let}
%
\begin{arguments}
    \item[binding\/$^*$] A list of binding specifiers.

    \item[body] A sequence of forms.
\end{arguments}
%
\result%
The sequence of \scref{form}s is evaluated in order, returning the value of the
last one as the result of the \specopref{dynamic-let} form.
%
\remarks%
A binding specifier is either an identifier or a two element list of an
identifier and an initializing form.  All the initializing forms are evaluated
from left to right in the current environment and the new bindings for the
symbols named by the identifiers are created in the dynamic environment to hold
the results.  These bindings have dynamic scope and dynamic extent
\index{general}{scope and extent!of \specopref{dynamic-let} bindings}.  Each
form in \scref{body} is evaluated in order in the environment extended by the
above bindings.  The result of evaluating the last form in \scref{body} is
returned as the result of \specopref{dynamic-let}.

\defop{defglobal}
%
\Syntax
\defSyntax{defglobal}{
\begin{syntaxx}
    \scdef{defglobal-form}: \ra{} \classref{object} \\
    \> ( \defopref{defglobal} \scref{identifier} \scref{level-1-expression} )
\end{syntaxx}}%
\showSyntaxBox{defglobal}
%
\begin{arguments}
    \item[identifier] A symbol naming a top dynamic binding containing the value
    of \scref{form}.

    \item[form] The \scref{form} whose value will be stored in the top dynamic
    binding of \scref{identifier}.
\end{arguments}
%
\remarks%
The value of \scref{form} is stored as the top dynamic value of the symbol named
by \scref{identifier} \index{general}{binding!top dynamic}.  The binding created by
\defopref{defglobal} is mutable.  An error is signaled (condition:
\conditionref{dynamic-multiply-defined}
\indexcondition{dynamic-multiply-defined}), on processing this form more than
once for the same \scref{identifier}.
%
\begin{note}
    The problems engendered by cross-module reference necessitated by a single
    top-dynamic environment are leading to a reconsideration of the defined
    model.  Another unpleasant aspect of the current model is that it is not
    clear how to address the issue of importing (or hiding) dynamic
    variables---they are in every sense global, which conflicts with the
    principle of module abstraction.  A model, in which a separate top-dynamic
    environment is associated with each module is under consideration for a
    later version of the definition.
\end{note}

\condition{dynamic-multiply-defined}{general-condition}
%
\begin{initoptions}
    \item[symbol, symbol] A symbol naming the dynamic variable which has already
    been defined.
\end{initoptions}
%
\remarks%
Signalled by \defopref{defglobal} if the named dynamic variable already
exists.
\end{optDefinition}

\sclause{Exit Extensions}
%
\label{subsubsec:exitext}
\begin{optPrivate}
    There is no prevention mechanism in CL either---can capture
    \macroref{return-from} in a function and pass it down (RPG).

    GN would like arbitrary tags for \macroref{catch} and \macroref{throw}---not
    just symbols.
\end{optPrivate}
%
\begin{optDefinition}

\macro{catch}
%
\Syntax
\defSyntax{catch}{
\begin{syntaxx}
    \scdef{catch-form}: \ra{} \classref{object} \\
    \>  ( \macroref{catch} \scref{tag} \scseqref{form} ) \\
    \scdef{tag}: \\
    \>  \scref{symbol}
\end{syntaxx}}%
\showSyntaxBox{catch}
%
\remarks%
The \macroref{catch} operator is similar to \macroref{block}, except that the
scope of the name (\scref{tag}) of the exit function is dynamic.  The catch
\scref{tag} must be a \syntaxref{symbol} because it is used as a dynamic
variable to create a dynamically scoped binding of \scref{tag} to the
continuation of the \macroref{catch} form.  The continuation can be invoked
anywhere within the dynamic extent of the \macroref{catch} form by using
\macroref{throw}.  The \scref{form}s are evaluated in sequence and the value of
the last one is returned as the value of the \macroref{catch} form.
%
\rewriterules
%
\begin{RewriteTable}{catch}{lll}
    (\macroref{catch}) & \rewrite &
        {\rm Is an error}\\
    (\macroref{catch} \scref{tag}) & \rewrite &
        (\specopref{progn} \scref{tag} ())\\
    (\macroref{catch} \scref{tag} \scseqref{form}) & \rewrite &
    \begin{minipage}[t]{0.3\columnwidth}
    \begin{tabbing}
        00\=00\= \kill
        (\specopref{let/cc} tmp\\
        \>(\specopref{dynamic-let} ((\scref{tag} tmp))\\
        \>\>\scseqref{form}))
    \end{tabbing}
    \end{minipage}
\end{RewriteTable}
%
Exiting from a \macroref{catch}, by whatever means, causes the restoration of
the lexical environment and dynamic environment that existed before the
\macroref{catch} was entered.  The above rewrite for \macroref{catch}, causes
the variable {\tt tmp} to be shadowed.  This is an artifact of the above
presentation only and a conforming processor must not shadow any variables that
could occur in the body of \macroref{catch} in this way.
%
\seealso%
\macroref{throw}.

\macro{throw}
%
\Syntax
\defSyntax{throw}{
\begin{syntaxx}
    \scdef{throw-form}: \ra{} \classref{object} \\
    \>  ( \macroref{throw} \scref{tag} \scseqref{form} )
\end{syntaxx}}%
\showSyntaxBox{throw}
%
\remarks%
In \macroref{throw}, the \scref{tag} names the continuation of the
\macroref{catch} from which to return.  \macroref{throw} is the invocation of
the continuation\index{general}{continuation} of the catch named \scref{tag}.
The \scref{form} is evaluated and the value are returned as the value of the
catch named by \scref{variable}.  The \scref{tag} ia a symbol because it used to
access the current dynamic binding of the symbol, which is where the
continuation is bound.
%
\rewriterules
%
\begin{RewriteTable}{throw}{lll}
    (\macroref{throw}) & \rewrite &
        {\rm Is an error}\\
    (\macroref{throw} \scref{tag}) & \rewrite &
        ((\specopref{dynamic} \scref{tag}) ())\\
    (\macroref{throw} \scref{tag} \scref{form}) & \rewrite &
        ((\specopref{dynamic} \scref{tag}) \scref{form})
\end{RewriteTable}
%
\seealso%
\macroref{catch}.
%
\end{optDefinition}

\sclause{Summary of Level-1 Expressions and Definitions}
%
\begin{optDefinition}
%
This section gives the syntax of all level-1 expressions and definitions
together.  Any productions undefined here appear elsewhere in the definition,
specifically: the syntax of most expressions and definitions is given in the
section defining level-0.
\raggedbottom
%
\ssclause{Syntax of Level-1 defining forms}
\showSyntax{defmodule-1}
\showSyntax{defclass-1}
\showSyntax{defgeneric-1}
\showSyntax{defmethod-1}
\showSyntax{defglobal}
%
\ssclause{Syntax of Level-1 expressions}
\showSyntax{dynamic}
\showSyntax{dynamic-setq}
\showSyntax{dynamic-let}
\showSyntax{generic-1-lambda}
\showSyntax{method-lambda}
%
% \ssclause{Syntax of Level-1 macros}
\showSyntax{catch}
\showSyntax{throw}
%
\flushbottom
%
\end{optDefinition}
