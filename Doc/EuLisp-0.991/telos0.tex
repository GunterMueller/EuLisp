% This is the telos0.tex file.
% It contains the Objects section in the EuLisp level-0 spec.
%
\clause{Objects}
\label{obj-0}
\label{telos0}
\index{general}{telos0}
\index{general}{level-0 modules!telos0}
\index{general}{telos0!module}
%
\begin{optPrivate}
    The structure of the final description is still open.  So far only
    initialization is described here. However, from the object-oriented point of
    view all general operations should be described here like generic-prin,
    generic-write, etc. On the other hand they could also be described in an I/O
    section.  hb: I've changed the structure of the 3 object sections. Now, we
    have only one section on objects at level-0. Duplicate text has been
    removed, as well as meta-level descriptions.
\end{optPrivate}
%
\begin{optRationale}
    \telos\ aids the system builder in defining abstractions for his programs
    which can be gracefully used, reused, and extended.  \telos\ consists of a
    kernel layer which implements a limited but very useful set of abilities,
    and various library extensions implementing more advanced, and more
    expensive, features.  For example, the kernel layer supports only single
    inheritance, classes which cannot be dynamically redefined, and classes
    whose instances cannot change their class.  On the other hand, because of
    the flexibility inherent in a self-descriptive system, \telos\ is highly
    extensible.  Users can extend the object model by defining new metaclasses,
    slot description classes, and generic function classes.
\end{optRationale}
%
\begin{optDefinition}
\noindent
In \eulisp, every object in the system has a specific class.  Classes themselves
are first-class objects.  In this respect \eulisp\ differs from statically-typed
\ools\ such as \Cpp\ and \mceyx.  The \eulisp\ object system is called \telos.
The facilities of the object system are split across the two levels of the
definition.  Level-0 supports the definition of generic functions, methods and
structures.  The defined name of this module is {\tt telos0}.

Programs written using \telos\ typically involve the design of a {\em class
    hierarchy}, where each class represents a category of entities in the
problem domain, and a {\em protocol}, which defines the operations on the
objects in the problem domain.

A class defines the structure and behaviour of its instances.  {\em Structure\/}
is the information contained in the class's instances and {\em behaviour\/} is
the way in which the instances are treated by the protocol defined for them.

The components of an object are called its {\em slots}. Each slot of an object
is defined by its class.

A protocol defines the operations which can be applied to instances of a set of
classes.  This protocol is typically defined in terms of a set of {\em generic
    functions}, which are functions whose application behaviour depends on the
classes of the arguments.  The particular class-specific behaviour is
partitioned into separate units called {\em methods}. A method is not a function
itself, but is a closed expression which is a component of a generic function.

Generic functions replace the {\em send} construct found in many \ools.  In
contrast to sending a message to a particular object, which it must know how to
handle, the method executed by a generic function is determined by all of its
arguments.  Methods which specialize on more than one of their arguments are
called {\em multi-methods}.

{\em Inheritance} is provided through classes. Slots and methods defined for a
class will also be defined for its subclasses but a subclass may specialize
them. In practice, this means that an instance of a class will contain all the
slots defined directly in the class as well as all of those defined in the
class's superclasses. In addition, a method specialized on a particular class
will be applicable to direct and indirect instances of this class.  The
inheritance rules, the applicability of methods and the generic dispatch are
described in detail later in this section.

Classes are defined using the \defformref{defclass} (\ref{defclass}) and
\defformref{defcondition} (\ref{defcondition}) defining forms, both of which
create top-lexical bindings.

Generic functions are defined using the
\defformref{defgeneric}\ttindex{defgeneric} defining form, which creates a named
generic function in the top-lexical environment of the module in which it
appears and \macroref{generic-lambda}\ttindex{generic-lambda}, which creates an
anonymous generic function.  These forms are described in detail later in this
section.

Methods can either be defined at the same time as the generic function, or else
defined separately using the \macroref{defmethod} macro, which adds a new method
to an existing generic function.  This macro is described in detail later in
this section.
% hb: do we need that? i think no.
%It may be possible in an implementation to acquire a pointer that does
%not correspond to any \eulisp\ object.  It is an error to pass such a
%pointer to a function.  The default domain for arguments of functions
%is \classref{object}.
%
\end{optDefinition}

\sclause{System Defined Classes}
\label{subsec:telos}
\label{subsec:objects}
%
\begin{optPrivate}
    hb: <simple-function> added, <method> removed, ...
\end{optPrivate}
%
\begin{optDefinition}
\noindent
The basic classes of \eulisp\ are elements of the object system class hierarchy,
which is shown in table~\ref{level-0-class-hierarchy}.
%
\begin{table}%
\caption{Level-0 class hierarchy}%
\label{level-0-class-hierarchy}%
{\tt%
\begin{tabbing}%
    00\=00\=00\=00\= \kill%
    \classref{object} \\
    \>\classref{character} \\
    \>\classref{condition} \\
    \>\>{\normalfont See table~\ref{condition-class-hierarchy}}\\
    \>\classref{function} \\
    % NotYoutoo \>\>\classref{continuation} \\
    \>\>\classref{simple-function} \\
    \>\>\classref{generic-function} \\
    \>\classref{collection} \\
    \>\>\classref{sequence} \\
    \>\>\>\classref{list} \\
    \>\>\>\>\classref{cons} \\
    \>\>\>\>\classref{null}\\
    \>\>\>\classref{character-sequence} \\
    \>\>\>\>\classref{string} \\
    \>\>\>\classref{vector} \\
    \>\>\classref{table} \\
    \>\>\>\classref{hash-table} \\
    \>\classref{lock} \\
    \>\classref{number} \\
    \>\>\classref{integer}\\
    \>\>\>\classref{fixed-precision-integer}\\
    % NotYoutoo \>\>\>\classref{variable-precision-integer}\\
    \>\>\classref{float}\\
    \>\>\>\classref{double-float}\\
    \>\classref{stream} \\
    \>\>\classref{buffered-stream}\\
    \>\>\>\classref{string-stream}\\
    \>\>\>\classref{file-stream}\\
    \>\classref{name} \\
    \>\>\classref{symbol}\\
    \>\>\classref{keyword}\\
    \>\classref{thread} \\
    \>\>\classref{simple-thread}%
\end{tabbing}%
}%
\end{table}%
%
Indentation indicates a subclass relationship to the class under which the line
has been indented, for example, \classref{condition}\ is a subclass of
\classref{object}.  The names given here correspond to the bindings of names to
classes as they are exported from the level-0 modules.  Classes directly
relevant to the object system are described in this section while others are
described in corresponding sections, e.g. \classref{condition}\ is described in
\S~\ref{condition}.
%
In this definition, unless otherwise specified, classes declared to be
subclasses of other classes may be indirect subclasses. Classes not declared to
be in a subclass relationship are disjoint.  Furthermore, unless otherwise
specified, all objects declared to be of a certain class may be indirect
instances of that class.

\class{object}
\index{general}{level-0 classes!\theclass{object}}
%
The root of the inheritance hierarchy. \classref{object}\ defines the basic
methods for initialization and external representation of objects.  No
initialization options are specified for \classref{object}.

\class{class}
\index{general}{level-0 classes!\theclass{class}}
%
The default super-class including for itself.  All classes defined using the
\defformref{defclass} form are direct or indirect subclasses of
\classref{class}.  Thus, this class is specializable by user-defined classes at
level-0.
%
\end{optDefinition}

\sclause{Single Inheritance}
\begin{optRationale}
    At level-0 \telos\ supports a standard inheritance protocol as flexible as
    that proposed in~\bref{Kiczales+91} and of a slightly finer granularity,
    splitting the work into a number of explicit phases.

    The move towards a more load-time weighted protocol translates into more
    work being done at class instantiation time including the computation and
    update of accessors, allocators and initializers as described above. The
    generation of these functions constitutes a phase in itself.

    The default inheritance methods implement just single inheritance.  The
    decision for single inheritance is justified by clearer semantics and the
    efficiency gain in time and space regarding slot access and generic
    dispatch.  Multiple inheritance~\bref{Bretthauer+89} is implemented in
    level-1.

    Neither class redefinition nor changing the class of an instance is
    supported by standard classes. It is this, in combination with the guarantee
    that the behaviour of standard generic functions cannot be modified for
    standard classes (due to no support for method removal nor non-standard
    method combination), which imbues programs expressed in terms of the default
    metaobjects with static semantics.

    Class, method, and generic function redefinition together with class change
    may all be portably implemented as library extensions as has been done in
    \mcs.  They are also desirable features of an interactive development
    environment.  It is envisaged that such development environments may
    transparently, by simple module substitution, allow code to be developed in
    terms of a set of metaobjects supporting these facilities in place of the
    standard metaobjects. If necessary, to gain speed or space efficiency, the
    program may be recompiled in terms of the standard metaobject set without
    change.
\end{optRationale}
%
\begin{optDefinition}
\noindent
\telos\ level-0 provides only single
inheritance\index{general}{inheritance!single}\index{general}{single
    inheritance}, meaning that a class can have exactly one direct
superclass---but indefinitely many direct subclasses.  In fact, all classes in
the level-0 class inheritance tree have exactly one direct superclass except the
root class \classref{object}\ which has no direct superclass.

Each class has a {\em class precedence list (CPL)}, a linearized list of all its
superclasses, which defines the classes from which the class inherits structure
and behaviour. For single inheritance classes, this list is defined recursively
as follows:
\begin{enumerate}
    \item the {\em CPL\/} of \classref{object}\ is a list of one element
    containing \classref{object}\ itself;

    \item the {\em CPL\/} of any other class is a list of classes beginning with
    the class itself followed by the elements of the {\em CPL\/} of its direct
    superclass which is \classref{object}\ by default.
\end{enumerate}

The class precedence list controls system-defined protocols
concerning:
\begin{enumerate}
    \item inheritance of slot and class options when initializing a class;
    \item method lookup and generic dispatch when applying a generic function.
\end{enumerate}
\end{optDefinition}

\sclause{Defining Classes}
\begin{optPrivate}
Since there is a special construct to define new metaclasses, defclass
can be viewed as a non-reflective construct and be placed here.  If
kept, defclass should be described here also.
\end{optPrivate}

\begin{optDefinition}
\defform{defclass}
\label{defclass}
\Syntax
\savesyntax\defclassSyntax\vbox{\syntax
defclass form
   = '(', 'defclass', class name, superclass name,
     slot list, {class option}, ')';
class name
   = identifier; (* \[\S\ref{symbol}\] *)
superclass name
   = identifier; (* \[\S\ref{symbol}\] *)
slot list
   = '(', {slot}, ')';
slot
   = slot name
   | '(', slot name, {slot option}, ')';
slot name
   = identifier; (* \[\S\ref{symbol}\] *)
slot option
   = 'keyword:' identifier (* \[\S\ref{symbol}\] *)
   | 'default:' level 0 expression (* \[\S\ref{control-0}\] *)
   | 'reader:' identifier (* \[\S\ref{symbol}\] *)
   | 'writer:' identifier (* \[\S\ref{symbol}\] *)
   | 'accessor:' identifier (* \[\S\ref{symbol}\] *)
   | 'requiredp:' boolean;
class option
   = 'keywords:', '(', {identifier}, ')'
   | 'constructor:', constructor specification
   | 'predicate:' identifier (* \[\S\ref{symbol}\] *)
   | 'abstractp:' boolean;
constructor specification
   = identifier
   | '(', identifier, {keyword name}, ')'
\endsyntax}
\label{defclass-syntax-table}
\syntaxtable{defclass}{\defclassSyntax}

\begin{arguments}
    \item[class name] A symbol naming a binding to be initialized with the new
    structure class. The binding is immutable.

    \item[superclass name] A symbol naming a binding of a class to be used as
    the direct superclass of the new structure class.

    \item[slot list] A list of slots (see below), comprising either a {\em slot
        name} or a list of a {\em slot name} followed by some {\em slot
        option}s.

    \item[class option] A key and a value (see below) which, taken together,
    apply to the class as a whole.
\end{arguments}
%
\remarks%
\defformref{defclass} defines a new structure class. Structure classes support
single inheritance as described above. Neither class redefinition nor changing
the class of an instance is supported by structure classes\footnote{In
    combination with the guarantee that the behaviour of generic functions
    cannot be modified once it has been defined, due to no support for method
    removal nor method combination, this imbues level-0 programs with static
    semantics.}.

The {\em slot option\/}s are interpreted as follows:
\begin{options}
    \item[keyword, identifier]%
    The value of this option is an identifier naming a symbol, which is the name
    of an argument to be supplied in the initialization options of a call to
    \functionref{make} on the new class.  The value of this argument in the call
    to \functionref{make} is the initial value of the slot.  This option must
    only be specified once for a particular slot.  The same initarg name may be
    used for several slots, in which case they will share the same initial value
    if the initarg is given to \functionref{make}.  Subclasses inherit the
    initarg. Each slot must have at most one initarg including the inherited
    one. That means, a subclass can not shadow or add a new initarg, if a
    superclass has already defined one.

    \item[default, level-0 expression]%
    The value of this option is an expression, which is evaluated as the default
    value of the slot, to be used if no initarg is defined for the slot or given
    to a call to \functionref{make}.  The expression is evaluated in the lexical
    environment of the call to \defformref{defclass} and the dynamic environment
    of the call to \functionref{make}.  The expression is evaluated each time
    \functionref{make} is called and the default value is called for.  The order
    of evaluation of the initforms in all the slots is determined by
    \genericref{initialize}.  This option must only be specified once for a
    particular slot. Subclasses inherit the initform.  However, a more specific
    form may be specified in a subclass, which will shadow the inherited one.

    \item[reader, identifier]%
    The value is the identifier of the variable to which the reader function
    will be bound.  The binding is immutable.  The reader function is a means to
    access the slot.  The reader function is a function of one argument, which
    should be an instance of the new class.  No writer function is automatically
    bound with this option.  This option can be specified more than once for a
    slot, creating several bindings for the same reader function. It is a
    violation to specify the same reader, writer, or accessor name for two
    different slots.

    \item[writer, identifier]%
    The value is the identifier of the variable to which the writer function
    will be bound.  The binding is immutable.  The writer function is a means to
    change the slot value.  The creation of the writer is analogous to that of
    the reader function. The writer function is a function of two arguments, the
    first should be an instance of the new class and the second can be any new
    value for the slot.  This option can be specified more than once for a slot.
    It is a violation to specify the same reader, writer, or accessor name
    for two different slots.

    \item[accessor, identifier]%
    The value is the identifier of the variable to which the reader function
    will be bound. In addition, the use of this {\em slot option\/} causes the
    writer function to be associated to the reader {\em via\/} the
    \functionref{setter} mechanism. This option can be specified more than once
    for a slot. It is a violation to specify the same reader, writer, or
    accessor name for two different slots.

    \item[requiredp, boolean]%
    The value is either true or false. True indicates that an initialization
    argument must be supplied for this slot.
\end{options}
%
The class options are interpreted as follows:
%
\begin{options}
    \item[keywords, list]%
    The value of this option is a list of identifiers naming symbols, which
    extend the inherited names of arguments to be supplied in the {\em
        init-option\/}s of a call to \functionref{make} on the new
    class. Initargs are inherited by union. The values of all legal arguments in
    the call to \functionref{make} are the initial values of corresponding slots
    if they name a slot initarg or are ignored by the default
    \genericref{initialize} method, otherwise. This option must only be
    specified once for a class.

    \item[constructor, constructor specification]%
    Creates a constructor function for the new class.  The constructor
    specification gives the name to which the constructor function will be
    bound, followed by a sequence of legal initargs for the class.  The new
    function creates an instance of the class and fills in the slots according
    to the match between the specified initargs and the given arguments to the
    constructor function.  This option may be specified any number of times for
    a class.
    % Specifying the constructor in this way is equivalent to writing a
    % \defformref{defconstructor} form for the class.

    \item[predicate, identifier]%
    Creates a function which tests whether an object is an instance of the new
    class.  The predicate specification gives the name to which the predicate
    function will be bound.  This option may be specified any number of times
    for a class.
    % Specifying the constructor in this way is equivalent to writing a
    % \defformref{defpredicate} form for the class.

    \item[abstractp, boolean]%
    The value is either true or false. True indicates that the class being
    defined is abstract.
%
\end{options}
%
\end{optDefinition}
%
\function{abstract-class-p}
%
\savesyntax\abstractClassPSyntax\vbox{\syntax
abstract-class-p form
   = '(', 'abstract-class-p', object, ')';
\endsyntax}
\syntaxtable{abstract-class-p}{\abstractClassPSyntax}
%
\begin{arguments}
    \item[object] Returns {\em object\/}, if it is an abstract class, otherwise
    \nil.
\end{arguments}
%
\begin{note}
    \functionref{abstract-class-p} is not currently implemented in \youtoo.
\end{note}
%
\sclause{Defining Generic Functions and Methods}
\begin{optDefinition}
%
\derivedclass{function}{object}
\index{general}{level-0 classes!\theclass{function}}
%
The class of all functions.

\derivedclass{generic-function}{function}
\index{general}{level-0 classes!\theclass{generic-function}}
%
The class of all generic functions.

\defform{defgeneric}
\label{defgeneric-0}
%
\Syntax
\savesyntax\defgenericSyntax\vbox{\syntax
defgeneric form
   = '(', 'defgeneric', gf name, gf lambda list,
     {level 0 init option}, ')';
gf name
   = identifier;     (* \[\ref{symbol}\] *)
gf lambda list
   = specialized lambda list;
level 0 init option
   = 'method', method description;
method description
   = '(', specialized lambda list, {form}, ')';
specialized lambda list
   = '(', specialized parameter,
     {specialized parameter},
     ['.', identifier], ')';     (* \[\ref{symbol}\] *)
specialized parameter
   = '(', identifier, class name, ')'     (* \[\ref{symbol}\] *)
   | identifier;     (* \[\ref{symbol}\] *)
\endsyntax}
\label{defgeneric-syntax-table}
\index{general}{generic function!lambda-list}
\index{general}{syntax!generic function lambda-list}
\syntaxtable{defgeneric}{\defgenericSyntax}
%
\begin{arguments}
    \item[gf name] One of a symbol, or a form denoting a setter function or a
    converter function.

    \item[gen lambda list] The parameter list of the generic function, which may
    be specialized to restrict the domain of methods to be attached to the
    generic function.

    \item[level 0 init option\/$^*$\/] Options as specified below.
\end{arguments}
%
\remarks%
This defining form defines a new generic function.  The resulting
generic function will be bound to {\em gf-name}.  The second argument
is the formal parameter list.  The method's specialized lamba list
must be congruent to that of the generic function.  Two lambda lists
are said to be {\em congruent\/} iff:
%
\begin{enumerate}
    \item  both have the same number of formal parameters, and
    \item  if one lambda list has a rest formal parameter then the other
    lambda list has a rest formal parameter too, and vice versa.
\end{enumerate}
%
An error is signalled (condition class:
\conditionref{non-congruent-lambda-lists}
\indexcondition{non-congruent-lambda-lists}) if any method defined on this
generic function does not have a lambda list {\em congruent\/} to that of the
generic function.

An error is signalled (condition class:
\conditionref{incompatible-method-domain}
\indexcondition{incompatible-method-domain}) if the method's specialized lambda
list widens the domain of the generic function.  In other words, the lambda
lists of all methods must specialize on subclasses of the classes in the lambda
list of the generic function.

An error is signalled (condition class:
\conditionref{method-domain-clash}\indexcondition{method-domain-clash}) if any
methods defined on this generic function have the same domain.  These conditions
apply both to methods defined at the same time as the generic function and to
any methods added subsequently by \macroref{defmethod}.  An {\em init-option\/}
is an identifier followed by a corresponding value.

An error is signalled (condition class:
\conditionref{no-applicable-method}\indexcondition{no-applicable-method}) if an
attempt is made to apply a generic function which has no applicable methods for
the classes of the arguments supplied.

A {\em level 0 init-option\/} is:
\begin{options}
    \item[method, method-spec] This option is followed by a method description.
    A method description is a list comprising the specialized lambda list of the
    method, which denotes the domain, and a sequence of forms, denoting the
    method body.  The method body is closed in the lexical environment in which
    the generic function definition appears. This option may be specified more
    than once.
\end{options}
%
The rewrite rules for \defformref{defgeneric} are:

\savesyntax\defgenericRewrites\vbox{\syntax
(defgeneric identifier
  gf-lambda-list {level 0 init option})
   = (defconstant identifier
       (generic-lambda
         gf-lambda-list {level 0 init option}))
(defgeneric (setter identifier)
  gf-lambda-list {level 0 init option})
   = ((setter setter) identifier
       (generic-lambda
         gf-lambda-list {level 0 init option}))
(defgeneric (converter identifier)
  gf-lambda-list {level 0 init option})
   = ((setter converter) identifier
       (generic-lambda
         gf-lambda-list {level 0 init option}))
\endsyntax}
\label{defgeneric-rewrite-rules}
\index{general}{generic function!rewrite rules}
\index{general}{syntax!generic function rewrite rules}
\syntaxtable{defgeneric {\normalfont rewrite rules}}{\defgenericRewrites}
%
\examples
In the following example of the use of \defformref{defgeneric} a generic
function named {\tt gf-0} is defined with three methods attached to
it.  The domain of {\tt gf-0} is constrained to be \classref{object}\
$\times$ {\tt <class-a>}.  In consequence, each method added to the
generic function, both here and later (by \macroref{defmethod}), must have
a domain which is a subclass of \classref{object}\ $\times$ {\tt <class-a>},
which is to say that {\tt <class-c>}, {\tt <class-e>} and {\tt
<class-g>} must all be subclasses of {\tt <class-a>}.
%
{\syntax
(defgeneric gf-0 (arg1 (arg2 <class-a>))
  method (((m1-arg1 <class-b>) (m1-arg2 <class-c>)) ...)
  method (((m2-arg1 <class-d>) (m2-arg2 <class-e>)) ...)
  method (((m3-arg1 <class-f>) (m3-arg2 <class-g>)) ...))
\endsyntax}
%
\seealso%
\macroref{defmethod}, \macroref{generic-lambda}.

\macro{defmethod}
\Syntax
\savesyntax\defmethodSyntax\vbox{\syntax
defmethod macro
   = '(', 'defmethod', gf locator,
     specialized lambda list,
     {form}, ')';
gf locator
   = identifier
   | '(', 'setter', identifier, ')'
   | '(', 'converter', identifier, ')';
\endsyntax}
\syntaxtable{defmethod}{\defmethodSyntax}
%
\remarks%
This macro is used for defining new methods on generic functions.  A new method
object is defined with the specified body and with the domain given by the
specialized lambda list.  This method is added to the generic function bound to
{\em gf-name\/}, which is an identifier, or a form denoting a setter function or
a converter function. If the specialized-lambda-list is not congruent with that
of the generic function, an error is signalled (condition class:
\conditionref{non-congruent-lambda-lists}\indexcondition{non-congruent-lambda-lists}).
An error is signalled (condition class:
\conditionref{incompatible-method-domain}\indexcondition{incompatible-method-domain})
if the method's specialized lambda list would widen the domain of the generic
function.  If there is a method with the same domain already defined on this
gneric function, an error is signalled (condition class:
\conditionref{method-domain-clash}\indexcondition{method-domain-clash}).

\macro{generic-lambda}
\Syntax
\savesyntax\genericLambdaSyntax\vbox{\syntax
generic lambda form
   = '(', 'generic-lambda', gf lambda list,
     {level 0 init option}, ')';
\endsyntax}
\syntaxtable{generic-lambda}{\genericLambdaSyntax}
%
\remarks%
\macroref{generic-lambda} creates and returns an anonymous generic function that
can be applied immediately, much like the normal \keywordref{lambda}.  The {\em
    gen-lambda-list} and the {\em init-option\/}s are interpreted exactly as for
the level-0 definition of \defformref{defgeneric}.  \examples In the following
example an anonymous version of {\tt gf-0} (see \defformref{defgeneric} above)
is defined.  In all other respects the resulting object is the same as {\tt
    gf-0}.
%
{\syntax
(generic-lambda ((arg1 <object>) (arg2 <class-a>))
  method (((m1-arg1 <class-b>) (m1-arg2 <class-c>)) ...)
  method (((m2-arg1 <class-d>) (m2-arg2 <class-e>)) ...)
  method (((m3-arg1 <class-f>) (m3-arg2 <class-g>)) ...))
\endsyntax}
%
\seealso%
\defformref{defgeneric}.
%
\end{optDefinition}

\sclause{Specializing Methods}
%
\begin{optPrivate}
    RPG: aren't argument bindings assigned?  Re footnote: why do need {\tt
        change-class} protocol for assignment?

    Both the functions here are bogus.

    Less bogus now---but note that we need context sensitive syntax to implement
    the specified behaviour.
\end{optPrivate}
%
\begin{optDefinition}
The following two operators are used to specialize more general methods.  The
more specialized method can do some additional computation before calling these
operators and can then carry out further computation before returning.  It is an
error to use either of these operators outside a method body.  Argument bindings
inside methods are immutable\index{general}{method!bindings}.  Therefore an
argument inside a method retains its specialized class throughout the processing
of the method.

\keyword{call-next-method}
\Syntax
\savesyntax\callNextMethodSyntax\vbox{\syntax
call-next-method form
   = '(', 'call-next-method', ')';
\endsyntax}
\syntaxtable{call-next-method}{\callNextMethodSyntax}
%
\result%
The result of calling the next most specific applicable method.
%
\remarks%
The next most specific applicable method is called with the same
arguments as the current method.  An error is signalled (condition
class: \conditionref{no-next-method}\indexcondition{no-next-method}) if there
is no next most specific method.

\keyword{next-method-p}
\Syntax
\savesyntax\nextMethodPSyntax\vbox{\syntax
next-method-p form
   = '(', 'next-method-p', ')';
\endsyntax}
\syntaxtable{next-method-p}{\nextMethodPSyntax}
%
\result%
If there is a next most specific method, \keywordref{next-method-p} returns a
non-\nil\/ value, otherwise, it returns \nil.
%
\end{optDefinition}

\sclause{Method Lookup and Generic Dispatch}
%
\begin{optRationale}
\telos\ uses the generic function mechanism introduced by \clos\ to
implement polymorphic behaviour.  However, the default generic function
mechanism of \telos\ is simplified compared to \clos; rather than
introducing dubious and costly extensions in the kernel, we choose to
relegate certain functionality to extension modules, and provide
enough extensibility to allow portable versions of them to be written at
level-1.
Like the slot access protocol, the extensible protocol for method
lookup and dispatch is based on the early computation of functions
implementing the extended functionality.  This is similar to the
\closmop, where the discriminating function is calculated once (or
relatively rarely) during the lifetime of a generic function.
However, in \telos\ both a method lookup function and a discriminating
function are computed when a generic function is created and
initialized.  The method lookup function corresponds to \clos's
runtime function \functionref{compute-applicable-methods}.
\end{optRationale}

\begin{optDefinition}
The system defined  method lookup and generic function dispatch is purely
class based. \genericref{equal} methods known from \clos\ are excluded.

The application behaviour of a generic function can be described in terms
of {\em method lookup\/} and {\em generic dispatch}. The method lookup
determines
\begin{enumerate}
        \item  which methods attached to the generic function are applicable
    to the supplied arguments, and

        \item  the linear order of the applicable methods with respect to
        classes of the  arguments and the argument precedence order.
\end{enumerate}

A class $C_1$ is called {\em more specific\/} than class $C_2$ {\em with respect
    to\/} $C_3$ iff $C_1$ appears before $C_2$ in the class precedence list
(CPL) of $C_3$
%
\footnote%
{%
    This definition is required when multiple
    inheritance\index{general}{inheritance!multiple}\index{general}{multiple
        inheritance} comes into play. Then, two classes have to be compared with
    respect to a third class even if they are not related to each other via the
    subclass relationship.  Although, multiple inheritance is not provided at
    level-0, it is provided at level-1 the method lookup protocol is independent
    of the inheritance strategy defined on classes. It depends on the class
    precedence lists of the domains of methods attached to the generic function
    and the argument classes involved.%
}.

Two additional concepts are needed to explain the processes of method
lookup and generic dispatch: (i) whether a method is {\em applicable},
(ii) how {\em specific} it is in relation to the other applicable
methods.  The definitions of each of these terms is now given.

A method with the domain $D_1 \times \ldots \times D_m [\times$
\verb|<list>|$]$ is {\em applicable\/} to the arguments $a_1 \ldots a_m
[a_{m+1} \ldots a_n]$ if the class of each argument, $C_i$, is a
subclass of $D_i$, which is to say, $D_i$ is a member of $C_i$'s class
precedence list.

A method {\tt M$_{1}$} with the domain $D_{11} \times \ldots \times
D_{1m} [\times$ \verb|<list>|$]$ is {\em more specific\/} than a method
{\tt M$_{2}$} with the domain $D_{21} \times \ldots \times D_{2m}
[\times$ \verb|<list>|$]$ {\em with respect to} the arguments $a_1
\ldots a_m [a_{m+1} \ldots a_n]$ iff there exists an $i\in (1 \ldots
m)$ so that $D_{1i}$ is more specific than $D_{2i}$ with respect to
$C_i$, the class of $a_i$, and for all $j=1 \ldots i-1$, $D_{2j}$ is
{\em not} more specific than $D_{1j}$ with respect to $C_j$, the class
of $a_j$.

Now, with the above definitions, we can describe the application
behaviour of a generic function {\tt (f} $a_1 \ldots a_m [a_{m+1} \ldots
a_n]${\tt )}:

\begin{enumerate}
        \item  Select the methods applicable to $a_1 \ldots a_m [a_{m+1} \ldots
        a_n]$ from all methods attached to {\tt f}.

        \item  Sort the applicable methods {\tt M$_{1}$} \ldots
            {\tt M$_{k}$} into
        decreasing order of specificity using left to right argument
        precedence order to resolve otherwise equally specific methods.

        \item  If \keywordref{call-next-method} appears in one of the method
        bodies, make the sorted list of applicable methods available for it.

        \item  Apply the most specific method on $a_1 \ldots a_m [a_{m+1} \ldots
        a_n]$.

        \item  Return the result of the previous step.
\end{enumerate}

The first two steps are usually called {\em method lookup} and the
first four are usually called {\em generic dispatch}.
\end{optDefinition}

\sclause{Creating and Initializing Objects}
\index{general}{object}
\index{general}{initialization}
\begin{optPrivate}

\end{optPrivate}
\begin{optRationale}
If the default method is not executed during a call of
\genericref{initialize}, no check of initargs will be done by the system.

Writers for metaobjects are not specified yet. That implies that users must use
\keywordref{call-next-method} if they specialize metaobjects classes and define
new \genericref{initialize} methods for them.
\end{optRationale}

\begin{optDefinition}
Objects can be created by calling
%
\begin{itemize}
    \item constructors (predefined or user defined) or
    \item \functionref{make}, the general constructor function or
    \item \functionref{allocate}, the general allocator function.
\end{itemize}

\function{make}
%
\begin{arguments}
    \item[class] The class of the object to create.
    \item[{\tt key$_1$} obj$_1$ ... {\tt key$_n$} obj$_n$] Initialization
    arguments.
\end{arguments}
%
\result%
An instance of {\em class}.
%
\remarks%
The general constructor \functionref{make} creates a new object calling
\genericref{allocate} and initializes it by calling
\genericref{initialize}. \functionref{make} returns whatever
\genericref{allocate} returns as its result.

\function{allocate}
%
\begin{arguments}
    \item[class] A structure class.
    \item[initlist] A list of initialization arguments.
\end{arguments}
%
\result%
A new uninitialized direct instance of the first argument.
%
\remarks%
The {\em class\/} must be a structure class, the {\em initlist\/} is ignored.
The behaviour of \genericref{allocate} is extended at level-1 for classes not
accessible at level-0. The level-0 behaviour is not affected by the
level-1 extension.

\generic{initialize}
%
\begin{genericargs}
    \item[object, \classref{object}] The object to initialize.
    \item[initlist] The list of initialization arguments.
\end{genericargs}
%
\result%
The initialized object.
%
\remarks%
Initializes an object and returns the initialized object as the result.  It is
called by \functionref{make} on a new uninitialized object created by calling
\genericref{allocate}.

Users may extend \genericref{initialize} by defining methods specializing on
newly defined classes, which are structure classes at level-0.

\method{initialize}
%
\begin{specargs}
    \item[object, \classref{object}] The object to initialize.
    \item[initlist] The list of initialization arguments.
\end{specargs}
%
\result%
The initialized object.
%
\remarks%
This is the default method attached to \genericref{initialize}.  This method
performs the following steps:

\begin{enumerate}
    \item Checks if the supplied initargs are legal and signals an error
    otherwise. Legal initargs are those specified in the class definition
    directly or inherited from a superclass.  An initarg may be specified as a
    slot option or as a class option.

    \item Initializes the slots of the object according to the initarg, if
    supplied, or according to the most specific {\tt initform}, if specified.
    % directly in the class definition or inherited from a superclass.
    Otherwise, the slot remains ``unbound''.
\end{enumerate}
%
Legal initargs which do not initialize a slot are ignored by the default
\genericref{initialize} method.  More specific methods may handle these initargs
and call the default method by calling \keywordref{call-next-method}.
% The default method can be specialized by calling \keywordref{call-next-method}
% from more specific \genericref{initialize} methods.
%
%\seealso%
%\genericref{initialize} methods for classes, slot descriptors, generic functions
%and methods, \functionref{make}, \genericref{allocate}.
%
\end{optDefinition}

\sclause{Accessing Slots}
%
\begin{optDefinition}
Object components (slots) can be accessed using reader and writer functions
(accessors) only. For system defined object classes there are predefined readers
and writers. Some of the writers are accessible using the \functionref{setter}
function. If there is no writer for a slot, its value cannot be changed. When
users define new classes, they can specify which readers and writers should be
accessible in a module and by which binding.  Accessor bindings are not exported
automatically when a class (binding) is exported. They can only be exported
explicitly.

\sclause{Other Abstract Classes}
%
\derivedclass{name}{object}
\index{general}{level-0 classes!\theclass{name}}
%
The class of all ``names''.
%
\seealso%
\classref{symbol} and \classref{keyword}.
%
\end{optDefinition}
