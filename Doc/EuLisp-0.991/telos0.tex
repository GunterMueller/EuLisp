% This is the telos0.tex file.
% It contains the Objects section in the EuLisp level-0 spec.
%
\clause{Objects}
\label{obj-0}
\label{telos0}
\index{general}{telos0}
\index{general}{level-0 modules!telos0}
\index{general}{telos0!module}
%
\begin{optPrivate}
    The structure of the final description is still open.  So far only
    initialization is described here. However, from the object-oriented point of
    view all general operations should be described here like generic-prin,
    generic-write, etc. On the other hand they could also be described in an I/O
    section.  hb: I've changed the structure of the 3 object sections. Now, we
    have only one section on objects at level-0. Duplicate text has been
    removed, as well as meta-level descriptions.
\end{optPrivate}
%
\begin{optRationale}
    \telos\ aids the system builder in defining abstractions for his programs
    which can be gracefully used, reused, and extended.  \telos\ consists of a
    kernel layer which implements a limited but very useful set of abilities,
    and various library extensions implementing more advanced, and more
    expensive, features.  For example, the kernel layer supports only single
    inheritance, classes which cannot be dynamically redefined, and classes
    whose instances cannot change their class.  On the other hand, because of
    the flexibility inherent in a self-descriptive system, \telos\ is highly
    extensible.  Users can extend the object model by defining new metaclasses,
    slot description classes, and generic function classes.
\end{optRationale}
%
\begin{optDefinition}
\noindent
In \eulisp, every object in the system has a specific class.  Classes themselves
are first-class objects.  In this respect \eulisp\ differs from statically-typed
\ools\ such as \Cpp\ and \mceyx.  The \eulisp\ object system is called \telos.
The facilities of the object system are split across the two levels of the
definition.  Level-0 supports the definition of generic functions, methods and
structures.  The defined name of this module is {\tt telos0}.

Programs written using \telos\ typically involve the design of a {\em class
    hierarchy}, where each class represents a category of entities in the
problem domain, and a {\em protocol}, which defines the operations on the
objects in the problem domain.

A class defines the structure and behaviour of its instances.  {\em Structure\/}
is the information contained in the class's instances and {\em behaviour\/} is
the way in which the instances are treated by the protocol defined for them.

The components of an object are called its {\em slots}. Each slot of an object
is defined by its class.

A protocol defines the operations which can be applied to instances of a set of
classes.  This protocol is typically defined in terms of a set of {\em generic
    functions}, which are functions whose application behaviour depends on the
classes of the arguments.  The particular class-specific behaviour is
partitioned into separate units called {\em methods}. A method is not a function
itself, but is a closed expression which is a component of a generic function.

Generic functions replace the {\em send} construct found in many \ools.  In
contrast to sending a message to a particular object, which it must know how to
handle, the method executed by a generic function is determined by all of its
arguments.  Methods which specialize on more than one of their arguments are
called {\em multi-methods}.

{\em Inheritance} is provided through classes. Slots and methods defined for a
class will also be defined for its subclasses but a subclass may specialize
them. In practice, this means that an instance of a class will contain all the
slots defined directly in the class as well as all of those defined in the
class's superclasses. In addition, a method specialized on a particular class
will be applicable to direct and indirect instances of this class.  The
inheritance rules, the applicability of methods and the generic dispatch are
described in detail later in this section.

Classes are defined using the \defopref{defclass} (\ref{defclass}) and
\defopref{defcondition} (\ref{defcondition}) defining forms, both of which
create top-lexical bindings.

Generic functions are defined using the
\defopref{defgeneric}\ttindex{defgeneric} defining form, which creates a named
generic function in the top-lexical environment of the module in which it
appears and \specopref{generic-lambda}\ttindex{generic-lambda}, which creates an
anonymous generic function.  These forms are described in detail later in this
section.

Methods can either be defined at the same time as the generic function, or else
defined separately using the \defopref{defmethod} macro, which adds a new method
to an existing generic function.  This macro is described in detail later in
this section.
\end{optDefinition}

\sclause{System Defined Classes}
\label{subsec:telos}
\label{subsec:objects}
%
\begin{optDefinition}
\noindent
The basic classes of \eulisp\ are elements of the object system class hierarchy,
which is shown in table~\ref{level-0-class-hierarchy}.
%
\begin{table}%
\caption{Level-0 class hierarchy}%
\label{level-0-class-hierarchy}%
{\tt%
\begin{tabbing}%
    00\=00\=00\=00\= \kill%
    $\cal A$ \classref{object} \\
    \>$\cal C$ \classref{character} \\
    \>$\cal A$ \classref{condition}
    {\normalfont See table~\ref{condition-class-hierarchy}}\\
    \>$\cal A$ \classref{function} \\
    \>\>$\cal C$ \classref{continuation} \\
    \>\>$\cal C$ \classref{simple-function} \\
    \>\>$\cal P$ \classref{generic-function} \\
    \>\>\>$\cal C$ \classref{simple-generic-function} \\
    \>$\cal A$ \classref{collection} \\
    \>\>$\cal A$ \classref{sequence} \\
    \>\>\>$\cal P$ \classref{list} \\
    \>\>\>\>$\cal C$ \classref{cons} \\
    \>\>\>\>$\cal C$ \classref{null}\\
    \>\>\>$\cal A$ \classref{character-sequence} \\
    \>\>\>\>$\cal C$ \classref{string} \\
    \>\>\>$\cal C$ \classref{vector} \\
    \>\>$\cal A$ \classref{table} \\
    \>\>\>$\cal C$ \classref{hash-table} \\
    \>$\cal C$ \classref{lock} \\
    \>$\cal A$ \classref{number} \\
    \>\>$\cal A$ \classref{integer}\\
    \>\>\>$\cal C$ \classref{int}\\
    % NotYoutoo \>\>\>$\cal C$ \classref{variable-precision-integer}\\
    \>\>$\cal A$ \classref{float}\\
    \>\>\>$\cal C$ \classref{double-float}\\
    \>$\cal A$ \classref{stream} \\
    \>\>$\cal A$ \classref{buffered-stream}\\
    \>\>\>$\cal C$ \classref{string-stream}\\
    \>\>\>$\cal C$ \classref{file-stream}\\
    \>$\cal A$ \classref{name} \\
    \>\>$\cal C$ \classref{symbol}\\
    \>\>$\cal C$ \classref{keyword}\\
    \>$\cal A$ \classref{thread} \\
    \>\>$\cal C$ \classref{simple-thread}%
\end{tabbing}%
}%
\end{table}%
%
Indentation indicates a subclass relationship to the class under which the line
has been indented, for example, \classref{condition}\ is a subclass of
\classref{object}.  The names given here correspond to the bindings of names to
classes as they are exported from the level-0 modules.  Classes directly
relevant to the object system are described in this section while others are
described in corresponding sections, e.g. \classref{condition}\ is described in
\S~\ref{condition}.
%
In this definition, unless otherwise specified, classes declared to be
subclasses of other classes may be indirect subclasses. Classes not declared to
be in a subclass relationship are disjoint.  Furthermore, unless otherwise
specified, all objects declared to be of a certain class may be indirect
instances of that class.

\class{object}
\index{general}{level-0 classes!\theclass{object}}
%
The root of the inheritance hierarchy. \classref{object}\ defines the basic
methods for initialization and external representation of objects.  No
initialization options are specified for \classref{object}.

\class{class}
\index{general}{level-0 classes!\theclass{class}}
%
The default super-class including for itself.  All classes defined using the
\defopref{defclass} form are direct or indirect subclasses of
\classref{class}.  Thus, this class is specializable by user-defined classes at
level-0.
%
\end{optDefinition}

\sclause{Single Inheritance}
\begin{optRationale}
    At level-0 \telos\ supports a standard inheritance protocol as flexible as
    that proposed in~\bref{Kiczales+91} and of a slightly finer granularity,
    splitting the work into a number of explicit phases.

    The move towards a more load-time weighted protocol translates into more
    work being done at class instantiation time including the computation and
    update of accessors, allocators and initializers as described above. The
    generation of these functions constitutes a phase in itself.

    The default inheritance methods implement just single inheritance.  The
    decision for single inheritance is justified by clearer semantics and the
    efficiency gain in time and space regarding slot access and generic
    dispatch.  Multiple inheritance~\bref{Bretthauer+89} is implemented in
    level-1.

    Neither class redefinition nor changing the class of an instance is
    supported by standard classes. It is this, in combination with the guarantee
    that the behaviour of standard generic functions cannot be modified for
    standard classes (due to no support for method removal nor non-standard
    method combination), which imbues programs expressed in terms of the default
    metaobjects with static semantics.

    Class, method, and generic function redefinition together with class change
    may all be portably implemented as library extensions as has been done in
    \mcs.  They are also desirable features of an interactive development
    environment.  It is envisaged that such development environments may
    transparently, by simple module substitution, allow code to be developed in
    terms of a set of metaobjects supporting these facilities in place of the
    standard metaobjects. If necessary, to gain speed or space efficiency, the
    program may be recompiled in terms of the standard metaobject set without
    change.
\end{optRationale}
%
\begin{optDefinition}
\noindent
\telos\ level-0 provides only single
inheritance\index{general}{inheritance!single}\index{general}{single
    inheritance}, meaning that a class can have exactly one direct
superclass---but indefinitely many direct subclasses.  In fact, all classes in
the level-0 class inheritance tree have exactly one direct superclass except the
root class \classref{object}\ which has no direct superclass.

Each class has a {\em class precedence list (CPL)}, a linearized list of all its
superclasses, which defines the classes from which the class inherits structure
and behaviour. For single inheritance classes, this list is defined recursively
as follows:
\begin{enumerate}
    \item the {\em CPL\/} of \classref{object}\ is a list of one element
    containing \classref{object}\ itself;

    \item the {\em CPL\/} of any other class is a list of classes beginning with
    the class itself followed by the elements of the {\em CPL\/} of its direct
    superclass which is \classref{object}\ by default.
\end{enumerate}

The class precedence list controls system-defined protocols
concerning:
\begin{enumerate}
    \item inheritance of slot and class options when initializing a class;
    \item method lookup and generic dispatch when applying a generic function.
\end{enumerate}
\end{optDefinition}

\sclause{Defining Classes}
\begin{optPrivate}
Since there is a special construct to define new metaclasses, defclass
can be viewed as a non-reflective construct and be placed here.  If
kept, defclass should be described here also.
\end{optPrivate}

\begin{optDefinition}
\defop{defclass}
\label{defclass}
%
\Syntax
\defSyntax{defclass}{
\begin{syntax}
    \scdef{defclass-form}: \\
    \>  ( \defopref{defclass} \scref{class-name} \scref{superclass-name} \\
    \>\>  ( \scseqref{slot} ) \scseqref{class-option} ) \\
    \scdef{class-name}: \\
    \>  \scref{identifier} \\
    \scdef{superclass-name}: \\
    \>  \scref{identifier} \\
    \scdef{slot}: \\
    \>  \scref{slot-name} \\
    \>  ( \scref{slot-name} \scseqref{slot-option} ) \\
    \scdef{slot-name}: \\
    \>  \scref{identifier} \\
    \scdef{slot-option}: \\
    \>  \keywordref{keyword}: \scref{identifier} \\
    \>  \keywordref{default}: \scref{level-0-form} \\
    \>  \keywordref{reader}: \scref{identifier} \\
    \>  \keywordref{writer}: \scref{identifier} \\
    \>  \keywordref{accessor}: \scref{identifier} \\
    \>  \keywordref{required?}: \scref{boolean} \\
    \scdef{class-option}: \\
    \>  \keywordref{keywords}: ( \scseqref{identifier} ) \\
    \>  \keywordref{constructor}: \scref{constructor-specification} \\
    \>  \keywordref{predicate}: \scref{identifier} \\
    \>  \keywordref{abstract?}: \scref{boolean} \\
    \scdef{constructor-specification}: \\
    \>  ( \scref{identifier} \scseqref{identifier} ) \\
    \scdef{initlist}: \\
    \>  \scgseq{\scref{identifier} \scref{object}}
\end{syntax}}
\showSyntaxBox{defclass}
%
\begin{arguments}
    \item[\scref{class-name}] A symbol naming a binding to be initialized with
    the new structure class. The binding is immutable.

    \item[\scref{superclass-name}] A symbol naming a binding of a class to be
    used as the direct superclass of the new structure class.

    \item[\scref{slot}] Either a \scref{slot-name} or a list of
    \scref{slot-name} followed by some \scref{slot-option}s.

    \item[\scref{class-option}] A key and a value (see below) which, taken
    together, apply to the class as a whole.
\end{arguments}
%
\remarks%
\defopref{defclass} defines a new structure class. Structure classes support
single inheritance as described above. Neither class redefinition nor changing
the class of an instance is supported by structure classes\footnote{In
    combination with the guarantee that the behaviour of generic functions
    cannot be modified once it has been defined, due to no support for method
    removal nor method combination, this imbues level-0 programs with static
    semantics.}.

The \scref{slot-option}s are interpreted as follows:
\begin{options}
    \item[\keyworddef{keyword}:, \scref{identifier}]%
    The value of this option is an identifier naming a symbol, which is the name
    of an argument to be supplied in the initialization options of a call to
    \functionref{make} on the new class.  The value of this argument in the call
    to \functionref{make} is the initial value of the slot.  This option must
    only be specified once for a particular slot.  The same \scref{keyword} name
    may be used for several slots, in which case they will share the same
    initial value if the \scref{keyword} is given to \functionref{make}.
    Subclasses inherit the \scref{keyword}. Each slot must have at most one
    \scref{keyword} including the inherited one. That means, a subclass can not
    shadow or add a new \scref{keyword}, if a superclass has already defined
    one.

    \item[\keyworddef{default}:, \scref{level-0-form}]%
    The value of this option is a form, which is evaluated as the default
    value of the slot, to be used if no \scref{keyword} is defined for the slot
    or given to a call to \functionref{make}.  The expression is evaluated in
    the lexical environment of the call to \defopref{defclass} and the dynamic
    environment of the call to \functionref{make}.  The expression is evaluated
    each time \functionref{make} is called and the default value is called for.
    The order of evaluation of the defaults in all the slots is determined by
    \genericref{initialize}.  This option must only be specified once for a
    particular slot. Subclasses inherit the default.  However, a more specific
    form may be specified in a subclass, which will shadow the inherited one.

    \item[\keyworddef{reader}:, \scref{identifier}]%
    The value is the identifier of the variable to which the reader function
    will be bound.  The binding is immutable.  The reader function is a means to
    access the slot.  The reader function is a function of one argument, which
    should be an instance of the new class.  No writer function is automatically
    bound with this option.  This option can be specified more than once for a
    slot, creating several bindings for the same reader function. It is a
    violation to specify the same reader, writer, or accessor name for two
    different slots.

    \item[\keyworddef{writer}:, \scref{identifier}]%
    The value is the identifier of the variable to which the writer function
    will be bound.  The binding is immutable.  The writer function is a means to
    change the slot value.  The creation of the writer is analogous to that of
    the reader function. The writer function is a function of two arguments, the
    first should be an instance of the new class and the second can be any new
    value for the slot.  This option can be specified more than once for a slot.
    It is a violation to specify the same reader, writer, or accessor name
    for two different slots.

    \item[\keyworddef{accessor}:, \scref{identifier}]%
    The value is the identifier of the variable to which the reader function
    will be bound. In addition, the use of this \scref{slot-option} causes the
    writer function to be associated to the reader {\em via\/} the
    \functionref{setter} mechanism. This option can be specified more than once
    for a slot. It is a violation to specify the same reader, writer, or
    accessor name for two different slots.

    \item[\keyworddef{required?}:, \scref{boolean}]%
    The value is either \true{} or \nil{}. \true{} indicates that an
    initialization argument must be supplied for this slot.
\end{options}
%
The class-options are interpreted as follows:
%
\begin{options}
    \item[\keyworddef{keywords}:, \sc{( \scseqref{identifier} )}]%
    The value of this option is a list of identifiers naming symbols, which
    extend the inherited names of arguments to be supplied to \functionref{make}
    on the new class.  Keywords are inherited by union. The values of all legal
    arguments in the call to \functionref{make} are the initial values of
    corresponding slots if they name a slot \scref{keyword} or are ignored by
    the default \methodref{initialize}{object} method, otherwise. This option
    must only be specified once for a class.

    \item[\keyworddef{constructor}:, \scref{constructor-specification}]%
    Creates a constructor function for the new class.  The constructor
    specification gives the name to which the constructor function will be
    bound, followed by a sequence of legal \scref{keyword}s for the class.  The
    new function creates an instance of the class and fills in the slots
    according to the match between the specified \scref{keyword}s and the given
    arguments to the constructor function.  This option may be specified any
    number of times for a class.
    % Specifying the constructor in this way is equivalent to writing a
    % \defopref{defconstructor} form for the class.

    \item[\keyworddef{predicate}:, \scref{identifier}]%
    Creates a function which tests whether an object is an instance of the new
    class.  The predicate specification gives the name to which the predicate
    function will be bound.  This option may be specified any number of times
    for a class.
    % Specifying the constructor in this way is equivalent to writing a
    % \defopref{defpredicate} form for the class.

    \item[\keyworddef{abstract?}:, \scref{boolean}]%
    The value is either \true{} or \nil{}. \true{} indicates that the class
    being defined is abstract.
%
\end{options}
%
\end{optDefinition}
%
\function{abstract-class?}
%
\Signature
\defSignature{abstract-class?}{
\begin{signature}
    (\functionref{abstract-class?} \scref{object}) \ra{} \classref{object}
\end{signature}}
\showSignatureBox{abstract-class?}%
%
\begin{arguments}
    \item[\scref{object}] Returns \scref{object}, if it is an abstract class,
    otherwise \nil{}.
\end{arguments}
%
\begin{note}
    \functionref{abstract-class?} is not currently implemented in \youtoo.
\end{note}
%
\sclause{Defining Generic Functions and Methods}
\begin{optDefinition}
%
\derivedclass{function}{object}
\index{general}{level-0 classes!\theclass{function}}
%
The class of all functions.

\derivedclass{simple-function}{function}
\index{general}{level-0 classes!\theclass{simple-function}}
%
Place holder for \classref{simple-function} class.

\derivedclass{generic-function}{function}
\index{general}{level-0 classes!\theclass{generic-function}}
%
The class of all generic functions.

\derivedclass{simple-generic-function}{generic-function}
\index{general}{level-0 classes!\theclass{simple-generic-function}}
%
Place holder for \classref{simple-generic-function} class..

\defop{defgeneric}
\label{defgeneric-0}
%
\Syntax
\defSyntax{defgeneric}{
\begin{syntax}
    \scdef{defgeneric-form}: \\
    \>  ( \defopref{defgeneric} \scref{gf-name} \scref{gf-lambda-list} \\
    \>\>  \scref{level-0-init-option} ) \\
    \scdef{gf-name}: \\
    \>  \scref{identifier} \\
    \scdef{gf-lambda-list}: \\
    \>  \scref{specialized-lambda-list} \\
    \scdef{level-0-init-option}: \\
    \>  \keywordref{method} \scref{method-description} \\
    \scdef{method-description}: \\
    \>  ( \scref{specialized-lambda-list} \scseqref{form} ) \\
    \scdef{specialized-lambda-list}: \\
    \> ( \scSeqref{specialized-parameter} \scgopt{. \scref{identifier}} ) \\
    \scdef{specialized-parameter}: \\
    \> ( \scref{identifier} \scref{class-name} ) \\
    \> \scref{identifier}
\end{syntax}}
\label{defgeneric-syntax-table}
\index{general}{generic function!lambda-list}
\index{general}{syntax!generic function lambda-list}
\showSyntaxBox{defgeneric}
%
\begin{arguments}
    \item[\scref{gf-name}] One of a symbol, or a form denoting a setter function
    or a converter function.

    \item[\scref{gf-lambda-list}] The parameter list of the generic function,
    which may be specialized to restrict the domain of methods to be attached to
    the generic function.

    \item[\scref{level-0-init-option}] is \keyworddef{method}
    \scref{method-description} \\
    where \scref{method-description} is a list comprising the
    \scref{specialized-lambda-list} of the method, which denotes the domain, and
    a sequence of forms, denoting the method body.  The method body is closed in
    the lexical environment in which the generic function definition
    appears. This option may be specified more than once.
\end{arguments}
%
\remarks%
This defining form defines a new generic function.  The resulting
generic function will be bound to \scref{gf-name}.  The second argument
is the formal parameter list.  The method's specialized lamba list
must be congruent to that of the generic function.  Two lambda lists
are said to be {\em congruent\/} iff:
%
\begin{enumerate}
    \item  both have the same number of formal parameters, and
    \item  if one lambda list has a rest formal parameter then the other
    lambda list has a rest formal parameter too, and vice versa.
\end{enumerate}
%
An error is signalled (condition class:
\conditionref{non-congruent-lambda-lists}
\indexcondition{non-congruent-lambda-lists}) if any method defined on this
generic function does not have a lambda list {\em congruent\/} to that of the
generic function.

An error is signalled (condition class:
\conditionref{incompatible-method-domain}
\indexcondition{incompatible-method-domain}) if the method's specialized lambda
list widens the domain of the generic function.  In other words, the lambda
lists of all methods must specialize on subclasses of the classes in the lambda
list of the generic function.

An error is signalled (condition class: \conditionref{method-domain-clash}
\indexcondition{method-domain-clash}) if any methods defined on this generic
function have the same domain.  These conditions apply both to methods defined
at the same time as the generic function and to any methods added subsequently
by \defopref{defmethod}.  An \scref{level-0-init-option} is an identifier
followed by a corresponding value.

An error is signalled (condition class: \conditionref{no-applicable-method}
\indexcondition{no-applicable-method}) if an attempt is made to apply a generic
function which has no applicable methods for the classes of the arguments
supplied.
%
\rewriterules
\label{defgeneric-rewrite-rules}
%
\index{general}{generic function!rewrite rules}
\index{general}{rewrite rules!generic function}
%
\begin{RewriteTable}{defgeneric}{l}
\begin{minipage}[t]{\linewidth}
    \begin{tabbing}
        00\=00\= \kill
        (\defopref{defgeneric} \scref{identifier} \\
        \>\scref{gf-lambda-list} \scseqref{level-0-init-option})
    \end{tabbing}
\end{minipage}\\
\hspace{2cm}$\equiv$
\begin{minipage}[t]{\linewidth}
    \begin{tabbing}
        00\=00\= \kill
        (\defopref{defconstant} \scref{identifier}\\
        \>(\specopref{generic-lambda} \\
        \>\>\scref{gf-lambda-list} \scseqref{level-0-init-option}))
    \end{tabbing}
\end{minipage}\\
%
\begin{minipage}[t]{\linewidth}
    \begin{tabbing}
        00\=00\= \kill
        (\defopref{defgeneric} \\
        \>(\functionref{setter} \scref{identifier}) \\
        \>\scref{gf-lambda-list} \scseqref{level-0-init-option})
    \end{tabbing}
\end{minipage}\\
\hspace{2cm}$\equiv$
\begin{minipage}[t]{\linewidth}
    \begin{tabbing}
        00\=00\= \kill
        ((\functionref{setter} \functionref{setter}) \scref{identifier}\\
        \>(\specopref{generic-lambda} \\
        \>\> \scref{gf-lambda-list} \scseqref{level-0-init-option}))
    \end{tabbing}
\end{minipage}\\
%
\begin{minipage}[t]{\linewidth}
    \begin{tabbing}
        00\=00\= \kill
        (\defopref{defgeneric} \\
        \>(\functionref{converter} \scref{identifier}) \\
        \>\scref{gf-lambda-list} \scseqref{level-0-init-option})
    \end{tabbing}
\end{minipage}\\
\hspace{2cm}$\equiv$
\begin{minipage}[t]{\linewidth}
    \begin{tabbing}
        00\=00\= \kill
        ((\functionref{setter} \functionref{converter})\\
        \>\scref{identifier}\\
        \>(\specopref{generic-lambda} \\
        \>\>\scref{gf-lambda-list} \scseqref{level-0-init-option}))
    \end{tabbing}
\end{minipage}
\end{RewriteTable}
%
\examples
In the following example of the use of \defopref{defgeneric} a generic
function named {\tt gf-0} is defined with three methods attached to
it.  The domain of {\tt gf-0} is constrained to be \classref{object}\
$\times$ {\tt <class-a>}.  In consequence, each method added to the
generic function, both here and later (by \defopref{defmethod}), must have
a domain which is a subclass of \classref{object}\ $\times$ {\tt <class-a>},
which is to say that {\tt <class-c>}, {\tt <class-e>} and {\tt
<class-g>} must all be subclasses of {\tt <class-a>}.
%
{\codeExample
(defgeneric gf-0 (arg1 (arg2 <class-a>))
  method (((m1-arg1 <class-b>)
           (m1-arg2 <class-c>)) ...)
  method (((m2-arg1 <class-d>)
           (m2-arg2 <class-e>)) ...)
  method (((m3-arg1 <class-f>)
           (m3-arg2 <class-g>)) ...))
\endCodeExample}
%
\seealso%
\defopref{defmethod}, \specopref{generic-lambda}.

\defop{defmethod}
\Syntax
\defSyntax{defmethod}{
\begin{syntax}
    \scdef{defmethod-form}: \\
    \>  ( \defopref{defmethod} \scref{gf-locator} \\
    \>\>   \scref{specialized-lambda-list} \\
    \>\>   \scref{body} ) \\
    \scdef{gf-locator}: \\
    \> \scref{identifier} \\
    \> ( \functionref{setter} \scref{identifier} ) \\
    \> ( \functionref{converter} \scref{identifier} )
\end{syntax}}%
\showSyntaxBox{defmethod}%
%
\remarks%
This macro is used for defining new methods on generic functions.  A new method
object is defined with the specified body and with the domain given by the
specialized-lambda-list.  This method is added to the generic function bound to
\scref{gf-name}, which is an identifier, or a form denoting a setter function or
a converter function. If the specialized-lambda-list is not congruent with that
of the generic function, an error is signalled (condition class:
\conditionref{non-congruent-lambda-lists}
\indexcondition{non-congruent-lambda-lists}).  An error is signalled (condition
class: \conditionref{incompatible-method-domain}
\indexcondition{incompatible-method-domain}) if the method's specialized lambda
list would widen the domain of the generic function.  If there is a method with
the same domain already defined on this gneric function, an error is signalled
(condition class:
\conditionref{method-domain-clash}\indexcondition{method-domain-clash}).

\specop{generic-lambda}
\Syntax
\defSyntax{generic-lambda}{
\begin{syntax}
    \scdef{generic-lambda-form}: \\
    \>  ( \specopref{generic-lambda} \scref{gf-lambda-list} \\
    \>\>  \scseqref{level-0-init-option} )
\end{syntax}}%
\showSyntaxBox{generic-lambda}
%
\remarks%
\specopref{generic-lambda} creates and returns an anonymous generic function that
can be applied immediately, much like the normal \specopref{lambda}.  The
\scref{gf-lambda-list} and the \scref{level-0-init-option}s are interpreted
exactly as for the level-0 definition of \defopref{defgeneric}.  \examples In
the following example an anonymous version of {\tt gf-0} (see
\defopref{defgeneric} above) is defined.  In all other respects the resulting
object is the same as {\tt gf-0}.
%
{\codeExample
(generic-lambda ((arg1 <object>)
                 (arg2 <class-a>))
  method (((m1-arg1 <class-b>)
           (m1-arg2 <class-c>)) ...)
  method (((m2-arg1 <class-d>)
           (m2-arg2 <class-e>)) ...)
  method (((m3-arg1 <class-f>)
           (m3-arg2 <class-g>)) ...))
\endCodeExample}
%
\seealso%
\defopref{defgeneric}.
%
\end{optDefinition}

\sclause{Specializing Methods}
%
\begin{optPrivate}
    RPG: aren't argument bindings assigned?  Re footnote: why do need {\tt
        change-class} protocol for assignment?

    Both the functions here are bogus.

    Less bogus now---but note that we need context sensitive syntax to implement
    the specified behaviour.
\end{optPrivate}
%
\begin{optDefinition}
The following two operators are used to specialize more general methods.  The
more specialized method can do some additional computation before calling these
operators and can then carry out further computation before returning.  It is an
error to use either of these operators outside a method body.  Argument bindings
inside methods are immutable\index{general}{method!bindings}.  Therefore an
argument inside a method retains its specialized class throughout the processing
of the method.

\specop{call-next-method}
\Signature
\defSignature{call-next-method}{
\begin{signature}
    (\specopref{call-next-method}) \ra{} \classref{object}
\end{signature}}%
\showSignatureBox{call-next-method}%
%
\result%
The result of calling the next most specific applicable method.
%
\remarks%
The next most specific applicable method is called with the same
arguments as the current method.  An error is signalled (condition
class: \conditionref{no-next-method}\indexcondition{no-next-method}) if there
is no next most specific method.

\specop{next-method?}
\Signature
\defSignature{next-method?}{
\begin{signature}
    (\specopref{next-method?}) \ra{} \scref{boolean}
\end{signature}}%
\showSignatureBox{next-method?}%
%
\result%
If there is a next most specific method, \specopref{next-method?} returns a
non-\nil{}\/ value, otherwise, it returns \nil{}.
%
\end{optDefinition}

\sclause{Method Lookup and Generic Dispatch}
%
\begin{optRationale}
\telos\ uses the generic function mechanism introduced by \clos\ to
implement polymorphic behaviour.  However, the default generic function
mechanism of \telos\ is simplified compared to \clos; rather than
introducing dubious and costly extensions in the kernel, we choose to
relegate certain functionality to extension modules, and provide
enough extensibility to allow portable versions of them to be written at
level-1.
Like the slot access protocol, the extensible protocol for method
lookup and dispatch is based on the early computation of functions
implementing the extended functionality.  This is similar to the
\closmop, where the discriminating function is calculated once (or
relatively rarely) during the lifetime of a generic function.
However, in \telos\ both a method lookup function and a discriminating
function are computed when a generic function is created and
initialized.  The method lookup function corresponds to \clos's
runtime function \functionref{compute-applicable-methods}.
\end{optRationale}

\begin{optDefinition}
The system defined  method lookup and generic function dispatch is purely
class based.

The application behaviour of a generic function can be described in terms of
{\em method lookup\/} and {\em generic dispatch}. The method lookup determines
\begin{enumerate}
    \item which methods attached to the generic function are applicable to the
    supplied arguments, and

    \item the linear order of the applicable methods with respect to classes of
    the arguments and the argument precedence order.
\end{enumerate}

A class $C_1$ is called {\em more specific\/} than class $C_2$ {\em with respect
    to\/} $C_3$ iff $C_1$ appears before $C_2$ in the class precedence list
(CPL) of $C_3$
%
\footnote%
{%
    This definition is required when multiple
    inheritance\index{general}{inheritance!multiple}\index{general}{multiple
        inheritance} comes into play. Then, two classes have to be compared with
    respect to a third class even if they are not related to each other via the
    subclass relationship.  Although, multiple inheritance is not provided at
    level-0, it is provided at level-1 the method lookup protocol is independent
    of the inheritance strategy defined on classes. It depends on the class
    precedence lists of the domains of methods attached to the generic function
    and the argument classes involved.%
}.

Two additional concepts are needed to explain the processes of method lookup and
generic dispatch: (i) whether a method is {\em applicable}, (ii) how {\em
    specific} it is in relation to the other applicable methods.  The
definitions of each of these terms is now given.

A method with the domain $D_1 \times \ldots \times D_m [\times$ \verb|<list>|$]$
is {\em applicable\/} to the arguments $a_1 \ldots a_m [a_{m+1} \ldots a_n]$ if
the class of each argument, $C_i$, is a subclass of $D_i$, which is to say,
$D_i$ is a member of $C_i$'s class precedence list.

A method {\tt M$_{1}$} with the domain $D_{11} \times \ldots \times D_{1m}
[\times$ \verb|<list>|$]$ is {\em more specific\/} than a method {\tt M$_{2}$}
with the domain $D_{21} \times \ldots \times D_{2m} [\times$ \verb|<list>|$]$
{\em with respect to} the arguments $a_1 \ldots a_m [a_{m+1} \ldots a_n]$ iff
there exists an $i\in (1 \ldots m)$ so that $D_{1i}$ is more specific than
$D_{2i}$ with respect to $C_i$, the class of $a_i$, and for all $j=1 \ldots
i-1$, $D_{2j}$ is {\em not} more specific than $D_{1j}$ with respect to $C_j$,
the class of $a_j$.

Now, with the above definitions, we can describe the application
behaviour of a generic function {\tt (f} $a_1 \ldots a_m [a_{m+1} \ldots
a_n]${\tt )}:

\begin{enumerate}
    \item Select the methods applicable to $a_1 \ldots a_m [a_{m+1} \ldots a_n]$
    from all methods attached to {\tt f}.

    \item Sort the applicable methods {\tt M$_{1}$} \ldots {\tt M$_{k}$} into
    decreasing order of specificity using left to right argument precedence
    order to resolve otherwise equally specific methods.

    \item If \specopref{call-next-method} appears in one of the method bodies,
    make the sorted list of applicable methods available for it.

    \item Apply the most specific method on $a_1 \ldots a_m [a_{m+1} \ldots
    a_n]$.

    \item Return the result of the previous step.
\end{enumerate}

The first two steps are usually called {\em method lookup} and the
first four are usually called {\em generic dispatch}.
\end{optDefinition}

\sclause{Creating and Initializing Objects}
\index{general}{object}
\index{general}{initialization}
\begin{optPrivate}

\end{optPrivate}
\begin{optRationale}
    If the default method is not executed during a call of
    \genericref{initialize}, no check of \scref{keyword}s will be done by the
    system.

    Writers for metaobjects are not specified yet. That implies that users must
    use \specopref{call-next-method} if they specialize metaobjects classes and
    define new \genericref{initialize} methods for them.
\end{optRationale}

\begin{optDefinition}
Objects can be created by calling
%
\begin{itemize}
    \item constructors (predefined or user defined) or
    \item \functionref{make}, the general constructor function or
    \item \functionref{allocate}, the general allocator function.
\end{itemize}

\function{make}
%
\begin{arguments}
    \item[class] The class of the object to create.
    \item[{\tt key$_1$} obj$_1$ ... {\tt key$_n$} obj$_n$] Initialization
    arguments.
\end{arguments}
%
\result%
An instance of {\em class}.
%
\remarks%
The general constructor \functionref{make} creates a new object calling
\genericref{allocate} and initializes it by calling
\genericref{initialize}. \functionref{make} returns whatever
\genericref{allocate} returns as its result.

\function{allocate}
%
\begin{arguments}
    \item[class] The class to allocate.
    \item[\scref{initlist}] The list of initialization arguments.
\end{arguments}
%
\result%
A new uninitialized direct instance of the first argument.
%
\remarks%
The {\em class\/} must be a structure class, the \scref{initlist} is ignored.
The behaviour of \genericref{allocate} is extended at level-1 for classes not
accessible at level-0. The level-0 behaviour is not affected by the level-1
extension.

\generic{initialize}
%
\begin{genericargs}
    \item[\scref{object}, \classref{object}] The object to initialize.
    \item[\scref{initlist}] The list of initialization arguments.
\end{genericargs}
%
\result%
The initialized object.
%
\remarks%
Initializes an object and returns the initialized object as the result.  It is
called by \functionref{make} on a new uninitialized object created by calling
\genericref{allocate}.

Users may extend \genericref{initialize} by defining methods specializing on
newly defined classes, which are structure classes at level-0.

\method{initialize}{object}
%
\begin{specargs}
    \item[\scref{object}, \classref{object}] The object to initialize.
    \item[\scref{initlist}] The list of initialization arguments.
\end{specargs}
%
\result%
The initialized object.
%
\remarks%
This is the default method attached to \genericref{initialize}.  This method
performs the following steps:

\begin{enumerate}
    \item Checks if the supplied \scref{keyword}s are legal and signals an error
    otherwise. Legal \scref{keyword}s are those specified in the class
    definition directly or inherited from a superclass.  An \scref{keyword} may
    be specified as a slot-option or as a class-option.

    \item Initializes the slots of the object according to the \scref{keyword},
    if supplied, or according to the most specific {\tt default}, if specified.
    % directly in the class definition or inherited from a superclass.
    Otherwise, the slot remains ``unbound''.
\end{enumerate}
%
Legal \scref{keyword}s which do not initialize a slot are ignored by the default
\methodref{initialize}{object} method.  More specific methods may handle these
\scref{keyword}s and call the default method by calling
\specopref{call-next-method}.
%
\end{optDefinition}

\sclause{Accessing Slots}
%
\begin{optDefinition}
Object components (slots) can be accessed using reader and writer functions
(accessors) only. For system defined object classes there are predefined readers
and writers. Some of the writers are accessible using the \functionref{setter}
function. If there is no writer for a slot, its value cannot be changed. When
users define new classes, they can specify which readers and writers should be
accessible in a module and by which binding.  Accessor bindings are not exported
automatically when a class (binding) is exported. They can only be exported
explicitly.

\sclause{Other Abstract Classes}
%
\derivedclass{name}{object}
\index{general}{level-0 classes!\theclass{name}}
%
The class of all ``names''.
%
\seealso%
\classref{symbol} and \classref{keyword}.
%
\end{optDefinition}
