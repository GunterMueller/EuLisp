%
% GLOSSARY.TEX:  The Talk glossary
%
% ----------------------------------------------------------------------
% This file is part of Ilog Talk
% Inquiries to ILOG S.A.
%              2 Avenue Gallie'ni, BP 85,
%              94253 Gentilly Cedex, France.
%
% (c) 1993
% ----------------------------------------------------------------------
%
\documentstyle[ilogindex]{ilogmanual}

\input{namemac}

\Begin

\Title {\IlogTalk\ Glossary}

\Author {HD \\ Begun May, 1993 \\ Printed \today}

\def\Gitem#1#2{\item[{\bf #1:}] \Index{#1} #2}
\def\Gref#1{{\em #1}}

\begin{description}

\Gitem	{\|()|}
	{This unique object, which is pronounced {\em nil}, represents
	both an empty list and the boolean value {\em false}.  It is
	the single instance of the class \|null|.  It is considered to
	be both a list and a symbol.  Both the \Gref{car} and
	\Gref{cdr} of \|()| are also \|()|.  This object is in the cdr
	of the final \Gref{cons cell} of a \Gref{proper list},
	although it is not a cons cell itself.  Note that the symbol
	\|nil| is not equivalent to this object; instead, \|nil| is
	system-defined constant which has \|()| as its value.  In
	\Talk, it is considered better to use \|()| to refer to this
	object, rather than \|nil|, to avoid problems in which \|nil|
	appears in an unevaluated position.}

\Gitem	{analysis}
	{The process of examining a \Gref{program unit} in order to
	determine its consistency.  During this process, the
	\Gref{walker} may signal errors or warnings, and modify the
	\Gref{program unit description file} to reflect inter-module
	dependencies, added or removed exports, and other information
	determined by the analyzer.  This process is invoked by the
	function \|analyze-program-unit|.}

\Gitem	{association list}
	{Also called {\em a-list}.  An association list is a list of
	\Gref{cons cell}s.  Each of the elements of the association
	list is a cons cell whose \Gref{car} is a keyword, and whose
	\Gref{cdr} is a value.  The functions \|assq| and \|assoc|
	allow you to look up key/value pairs in the list.  In general,
	\Gref{hash tables} have better performance and are more
	compact than association lists.}

\Gitem	{binding}
	{The association between a name --- represented in source code
	as a symbol --- and some value in some \Gref{namespace}.
	Typical namespaces include the lexical variable namespace, the
	dynamic variable namespace, the \|block| tag namespace, and
	the function namespace.  A binding is established with a form
	such as \|let|, \|dynamic-let|, \|block|, or \|flet| (in the
	case of the namespaces cited above).  It is referenced via a
	namespace-specific special form (such as \|dynamic| or
	\|function|).  Many namespaces also support \Gref{definition}s
	which establish root bindings for a given name.  In most
	namespaces, the value of a name cannot be computed given the
	symbol which represents the name.  For example, given the
	symbol \|'x|, there is no way to find out the value of the
	lexical variable named \|x| --- it must referenced directly.}

\Gitem	{block}
	{A named, sequential group of code within a \Gref{lexical
	scope} which can be exited via the special form
	\|return-from|.  A block is established by the special form
	\|block|.  Blocks have lexical scope but \Gref{indefinite
	extent}.}

\Gitem	{break loop}
	{An interactive loop entered after an error which allows you
	to examine the stack, step through code, and in general debug
	your code.}

\Gitem	{build}
	{The process of generating a \Gref{program unit}'s object
	file.  This may involve generating \langc\ code which is then
	compiled by your system's \langc\ compiler into object code.
	This operation is invoked by the function
	\|build-program-unit|.}

\Gitem	{car}
	{The first element of a \Gref{list} or \Gref{cons cell}.  The
	other element of a cons cell --- or the rest of the list ---
	is the \Gref{cdr}.  The function \|car| returns the car of a
	list.}

\Gitem	{cdr}
	{The second element of a \Gref{cons cell}, or the rest of a
	Gref{list}.  The first element of a cons cell or list is
	called the car.  The function \|cdr| returns the cdr of a
	list.}

\Gitem	{channel}
	{In \Talk, input/output operations are performed on open
	channels which correspond to the terminal or files.  Channels
	are represented by \Gref{fix}es or the special channels \|()|,
	meaning the standard input or output, and \|t|, meaning the
	\Gref{virtual terminal}.  At any time, there is one current
	input channel and one current output channel to which input
	and output operations apply.  Channels can be created with the
	functions \|openi|, \|openo|, and \|opena|, and can be closed
	with the function \|close|.  The functions \|inchan| and
	\|outchan| set the current input and output channel
	respectively.}

\Gitem	{circular object}
	{Any object which contains a pointer to itself, either
	directly or indirectly.  Circular objects --- in particular,
	circular lists and vectors --- cannot normally be printed in
	such a way that the \Gref{reader} can re-read them, nor can
	they be copied by the function \|copy|.  The functions
	\|cirprin| and \|circopy| exist for printing and copying
	circular objects.}

\Gitem	{clan}
	{Every \Talk\ \Gref{object} has a \Gref{class} of which it is
	an \Gref{instance}.  Each such class has a unique number, a
	\Gref{fix}, which is called its clan.  The word {\em clan} is
	a contraction of {\em class number}.  An object's clan can be
	found with the function \|object-clan|.}

\Gitem	{class}
	{Every \Talk\ \Gref{object} is an \Gref{instance} of some
	class.  The class is represented by an object, called a class
	metaobject.  Every class has a name, which corresponds to a
	\Gref{type}.}

\Gitem	{class precedence list}
	{Every \Talk\ \Gref{class} has a flattened, linearized list of
	all its superclasses, and their superclasses, and so on,
	beginning with the class itself up to the root class
	\|object|.  This list, called the {\em class precedence list},
	is used to determine the order of inheritance.  For example,
	when calling a method on some \Gref{instance}, the instance's
	class's class precedence list is used to find the first
	defined method which is applicable for the instance.}

\Gitem	{closure}
	{A function which has one or more lexical variable bindings
	closed over.  This happens when a lexical variable binding is
	established (by \|let| or a \Gref{lambda list}) around the
	creation of a function, and the variable is referenced inside
	the function.  Example:  the function returned by the
	expression \|(let ((x 1)) \#'(lambda () x))| is a closure since
	it closes over the free variable \|x|.}

\Gitem	{compilation environment}
	{A module has both an \Gref{execution environment} and a
	\Gref{compilation environment}.  The compilation environment
	is the set of \Gref{libraries} and \Gref{module}s needed to
	compile the module.  Certain kinds of \Gref{definition} need
	to be in the compilation environment of their references.
	These include macros, structures, and constants.}

\Gitem	{condition}
	{An object which represents an exceptional situation.
	Exceptional situations correspond to errors or foreseen
	situations which some piece code does not know how to handle
	locally.  Conditions can be used to separate calculation from
	interfaces.  A condition is generally signaled using the
	function \|signal|, and is then handled by a \Gref{handler}.}

\Gitem	{cons cell}
	{An instance of the class \|cons|.  A cons cell is two field
	structure.  The two fields are called the \Gref{car} and
	\Gref{cdr}.  Cons cells form the basis for linked
	\Gref{list}s.  A cons cell can be created by the function
	\|cons|.}

\Gitem	{constant}
	{A defined constant is a variable with an unchanging,
	\Gref{literal} value.  Constants can be defined using the
	\Gref{defining form} \|defconstant|.  They are accessed by
	simply referring to the constant's name in an evaluated
	position.  A constant definition must be in the
	\Gref{compilation environment} of the \Gref{module} which
	references the constant.}

\Gitem	{defining form}
	{A special kind of \Gref{macro} which creates a definition, by
	expanding into the special form \|define|.  References to
	defining forms can only appear at the top level of a module;
	they are specially noted by the compiler and must always be
	evaluated when the module is elaborated.  New defining forms
	can be created with the (meta-)defining form \|defdefiner|.}

\Gitem	{definition}
	{The declaration of a defined entity in a module.  Definitions
	are done via the special form \|define|, which can only appear
	at the top level of a module in a position which is always
	evaluated when the module is \Gref{elaborated}.  Each
	definition has a \Gref{definition type}, which allows the
	definition to be exported under that type.  For example,
	definitions done with \|defun| have the definition type
	\|function|, while classes defined with \|defclass| have the
	definition type \|class|.}

\Gitem	{definition type}
	{Each \Gref{definition} is associated with a definition type.
	This type is the export key under which the entity is
	associated.  Common definition types include \|function|,
	\|static-variable|, \|dynamic-variable|, \|structure|, and
	\|generic-function|.  New definition types can be added to the
	system using \|define-definition|.}

\Gitem	{dynamic extent}
	{Every binding exists for a certain period of time, after
	which it can no longer be referenced.  This period of time is
	called the binding's extent.  There are two kinds of extent:
	dynamic and indefinite.  Dynamic extent covers the time
	between the establishment of the binding and leaving the
	binding establishment form.  Examples of binding establishment
	forms with dynamic extent include \|dynamic-let|, \|catch|,
	and \|block|.}

\Gitem	{dynamic variable}
	{A variable with \Gref{dynamic scope}.  Dynamic variable
	bindings are defined using \|defdynamic|, bound using
	\|dynamic-let|, referenced using \|dynamic|, and modified
	using \|setf| with \|dynamic|.  Dynamic variables differ from
	\Gref{lexical variable}s because it can be referenced by all
	functions called by the function which binds it (\Gref{dynamic
	scope}) and because the binding is not preserved after control
	leaves the binding form which created it (\Gref{dynamic
	extent}).  We recommend that dynamic variable names be both
	packaged and have asterisks placed around the root name ---
	for example, \|\#:project:*dyn-var*|.  Dynamic variables can be
	accessed from their name using the function \|symbol-value|.}

\Gitem	{dynamic scope}
	{The area of text in which a \Gref{binding} can be referenced
	is referred to as its scope.  There are several scopes
	available in \Talk:  Dynamic scope means that references are
	valid within all functions called by the function which
	establishes the binding.}

\Gitem	{elaboration}
	{Each \Gref{module} consists of a sequence of
	\Gref{definition}s and \Gref{top-level form}s.  These must be
	executed in order to make the module accessible.  This
	process of execution is known as elaboration, follwing the
	{\sc Ada} language.}

\Gitem	{executable}
	{A complete, standalone application.  An executable is
	comparable to a \langc\ \|a.out| --- in other words, it is a
	program.  Because \Talk\ programs must be elaborated before
	being used, and because this process can involve substantial
	time and memory, each \Talk\ executable can have an associated
	\Gref{image}, which saves the state of memory at some point
	during the elaboration process.  An executable's constituents
	--- which are \Gref{module}s and \Gref{libraries} --- are thus
	divided into two classes, \|initialize| and \|restore|,
	depending on whether they are elaborated before or after the
	saving of the image file.  Modules in the \|restore| class
	either compute runtime-dependent information (such as the
	current display) or, for the last \|restore| module, start the
	work of the program.  This last module is thus equivalent to
	the \|main| procedure in a \langc\ program.}

\Gitem	{extent}
	{Each \Gref{binding} exists for a certain period of time.
	This period of time is called the binding's extent.  There are
	two kinds of extent: \Gref{dynamic extent} and
	\Gref{indefinite extent}.}

\Gitem	{external}
	{An object file from some other language such as \langc\ or
	\fortran\ which is linked with a \Talk\ \Gref{module}.  This
	object file must have been compiled using the compiler's
	position-independent code option in order to be linked with a
	\Talk\ module.  This is because \Talk's use of shared
	libraries.  Functions defined in external modules can be
	accessed in \Talk\ programs using the \Gref{defining form}
	\|defextern|.}

\Gitem	{fix}
	{A \Talk\ integer.  They are represented in 30 bits on most
	\Talk\ ports, although machines which support word sizes
	larger than 32 bits, such as the {\sc DEC Alpha}, will also
	have bigger fixes.  Unlike some ``object-oriented'' languages
	such as \Cpp, \Talk\ fixes are legitimate objects --- they are
	instances of the class \|fix|.  Of the basic \Talk\ object
	representations --- \Gref{float}, \Gref{byte row},
	\Gref{pointer row}, and fix, only fixes need conversion when
	passed to \langc\ programs in order to be treated as \langc\
	\|int|'s (or other integer type).  This cheap operation ---
	it's just a shift --- is done automatically by \|defextern|,
	and can also be done in a \langc\ program using the \langc\
	macros \|LL\_FIX2INT| and \|LL\_INT2FIX|.}

\Gitem	{float}
	{A \Talk\ floating point number.  They are represented as
	allocated \Talk\ objects pointing to 64 bit \langc\
	\|double|s.}

\Gitem	{form}
	{A single \Talk\ expression represented as a \Talk\ object ---
	either a \Gref{literal}, a \Gref{list}, or a \Gref{symbol}.
	Examples of legal forms include \|(car x)|, \|\#[1 2 3]|, and
	\|(defun foo (x) (list x (add1 x)))|.  Non-forms include
	\|(foo|, \|(x . y)|, and \|a 1|.}

\Gitem	{function}
	{A \Talk\ object which can be called to execute some code.  In
	\Talk, functions are real, allocated objects of the class
	\|function| (or one of its subclasses).  They are first-class:
	They can be passed around as arguments, returned from
	functions, and created and called dynamically.  Each function
	is an association between a \Gref{lexical environment} and a
	pointer to some code.  The lexical environment determines how
	free variables referenced in the code will be interpreted.
	The code determines what happens when the function is called.
	Functions can be explicitly called using \|funcall| or
	\|apply|.  They are explicitly created using \|lambda|.}

\Gitem	{garbage collection}
	{The process by which the memory manager deallocates the
	memory assigned to objects which are no longer referenced.  A
	garbage collection is typically invoked when you want to
	allocate an object, and the memory manager determines that
	there is not enough free memory for the object.  At this
	point, it has two choices: Either perform a garbage
	collection, looking for allocated objects which are no longer
	visible to your program; or asking the operating system for
	more memory.  The memory manager chooses by looking at the
	behavior of your system up to the point of the allocation.
	Garbage collections can also be explicitly invoked via the
	function \|gc|.  \IlogTalk\ uses a conservative, non-copying,
	mark and sweep garbage collection strategy.  This means that
	objects, once allocated, always reside at the same address,
	and that foreign pointers --- such as data from \langc\
	programs --- can be stored in \Talk\ object slots without
	problem.}

\Gitem	{generic function}
	{A kind of \Gref{function} in which the executed code depends
	on the \Gref{class} of all the arguments.  Generic functions
	are defined with \|defgeneric|.  A generic function has a set
	of \Gref{method}s, each of which defines the code executed for
	the generic function for some set of argument classes.}

\Gitem	{global scope}
	{A \Gref{binding} with global scope is visible everywhere, in
	all \Gref{module}s which exist in the same \Gref{executable}
	as the module which defines the binding.  Examples of
	\Gref{definition type}s with global scope include classes and
	messages.}

\Gitem	{handler}
	{A special kind of \Gref{generic function} used to treat
	\Gref{condition}s.  A handler is active within a particular
	\Gref{dynamic scope} established by the macro \|with-handler|.
	The methods of a handler each treat some class of condition.
	Handlers are defined with the defining form \|defhandler|, and
	handler methods are defined with \|define-handler-method|.}

\Gitem	{hash table}
	{A data structure which stores associations as key/value pairs
	in some undefined, but efficient, table structure.  Hash
	tables are characterized by rapid lookup and storage, but they
	are unordered.  Hash tables come in several flavors, depending
	on the method by which keys are compared: \|eq| hash tables
	compare the identity of keys; \|equal| hash tables compare the
	external representation of keys; \|eqn| and \|eqstring| tables
	are used for keys which are integers and strings respectively.
	In addition, you can define your own hash table types.  Hash
	tables are created with the function \|make-hash-table|.
	Associations are added with \|puthash|, and values are
	retrieved with \|gethash|.}

\Gitem	{improper list}
	{The final \Gref{cdr} of an improper list is not \|()|.  For
	example, \|(a b . c)| is an improper list, while \|(a b c)| is
	a proper list.  In fully dotted notation, we can see the
	difference more clearly: \|(a . (b . c))| vs. \|(a . (b . (c .
	())))|.}

\Gitem	{indefinite extent}
	{\Gref{Extent} refers to the lifetime of a \Gref{binding}.
	A bindings with indefinite extent remains active as long as
	anyone has a reference to it.  After this point, the binding
	may be collected.  In particular, bindings with indefinite
	extent can live beyond the \Gref{dynamic scope} of the binding
	creation form.  For example, in the code fragment \|(let ((x
	1)) \#'(lambda () x))|, the function returned contains a
	reference to the binding of the lexical variable \|x| to the
	fix \|1|.  This binding will remain in existence as long as
	the function refering to it.  Contrast this with \langc, where
	all bindings have \Gref{dynamic extent}, and disappear after
	the form which creates them exits.  This means that not all
	bindings in \Talk\ can be allocated on the stack; those
	bindings which must live on are allocated in the heap.
	However, the compiler can detect which bindings can be
	stack-allocated; these remain as efficient as automatic
	variables in \langc.  Certain bindings in \Talk\ have dynamic
	extent --- for example, dynamic variables and control tags
	established by \|block| and \|catch|.  These cannot be
	referenced outside of the dynamic scope of their creation.}

\Gitem	{initform}
	{A \Talk\ \Gref{form} used to compute the default value of a
	\Gref{slot}.  Normally, the initform is only executed when no
	explicit value is supplied for a slot when the \Gref{class}
	containing the slot is \Gref{instantiate}d.  The code of an
	initform is actually transformed into an \Gref{initfunction}
	when the class definition macro is expanded.  Since the
	initform serves no purpose at runtime, it is not available by
	default in the \telos\ \Gref{metaobject protocol}.  However,
	the initfunction can be retrieved.  In structures defined by
	\|defstructure|, the default initform is simply \|()|.  In
	classes defined by \|defclass|, the default initform returns
	the distinguished unbound slot value, which is also returned
	by the function \|unbound-slot-value|.}

\Gitem	{initfunction}
	{A function with no arguments which is called to compute the
	value of a \Gref{slot} when no explicit value is provided for
	the slot.  Each initfunction corresponds to an
	\Gref{initform}; see the entry on initforms for more detail.}

\Gitem	{instance}
	{A synonym for \Gref{object} used to emphasize the relation
	between an object and its \Gref{class}.}

\Gitem	{instanciate}
	{The process of creating an \Gref{instance} of some
	\Gref{class}.}

\Gitem	{lambda list}
	{Each function has a lambda list, or \Gref{parameter list}.
	(These two terms are synonymous, and either may be used.)  A
	function's lambda list determines the number and name of each
	argument.  Within a lambda list, certain keywords are used to
	mark optional arguments and n-ary functions.  These keywords
	begin with the character \|\&| --- they are: \|\&optional|,
	\|\&rest|, and \|\&multiple|.  Other symbols in the list are
	argument names.  See the reference manual for more information
	on the exact syntax of lambda lists.}

\Gitem	{lexical scope}
	{Used in two related senses.  First, it refers the limited,
	contiguous area in a program text in which a certain
	identifier refers to a given binding.  For example, ``the
	lexical scope of the variable {\em x} is from lines 13 to
	23.''  It can also refer to the fact that a particular
	namespace allows binding references only within a lexical
	scope.  For example, ``control blocks defined with \|block|
	are only valid in the lexical scope of the \|block| form.''
	This contrasts with \Gref{dynamic scope} and \Gref{module
	scope}, in which the validity of a binding changes dynamically
	or refers to the entire module in which the binding is
	defined, respectively.}

\Gitem	{library}
	{A \Gref{program unit} grouping several related \Gref{module}s
	into a single loadable or linkable unit.  Libraries, like
	other program units, are described by a \|.lm| program unit
	description file.  Libraries are implemented as dynamically
	loadable shared libraries on systems which support them.
	Loading libraries is extremely fast --- usually much faster
	than loading any of the modules in the library! In addition,
	shared libraries allow different processes on the same machine
	to share code memory for the library.  You should try to
	organize your project into independent libraries which may
	then be linked into one or more \Gref{executable}s.  Each
	module in your project should belong to at most one library.
	Due to implementational constraints, libraries can only
	contain modules as \Gref{link unit}s.}

\Gitem	{link unit}
	{One of the \Gref{module}s linked with a \Gref{library}.}

\Gitem	{list}
	{A \Gref{cons cell} used to implement linked lists.  Lists are
	divided into two categories: \Gref{proper list}s and
	\Gref{improper list}s, distinguished by the value of the
	\Gref{cdr} slot in the final cons cell of the list.  Lists
	have an external representation based on parentheses: First an
	opening parenthesis, then the elements of the list separated
	by whitespace, and finally a closing parenthesis.  For
	improper lists, the value of cdr slot in the final cons cell
	is introduced by a dot separated by whitespace before the
	final element.  For example, \|(a b c)| is a proper list of
	three elements, the \Gref{symbol}s \|a|, \|b|, and \|c|; \|(1
	2 . 3)| is an improper list whose formal elements are the
	\Gref{fix}es \|1| and \|2|, and whose final cdr is the fix
	\|3|.  While lists are an important data structure in many
	situations, they are not appropriate everywhere;
	\Gref{vector}s and \Gref{structure}s often provide better
	efficiency and abstraction.  In addition, lists used as
	tables --- also called \Gref{association list}s --- are often
	best replaced by hash tables for greater efficiency.}

\Gitem	{literal}
	{A constant data appearing directly in code.  In \Talk,
	literals can be instances of any of the following
	\Gref{class}es: \|fix|, \|cons|, \|float|, \|string|,
	\|symbol|, \|vector|, and \|pathname|.  Instances of other
	datatypes must be constructed at runtime by the appropriate
	constructors. In the case of cons cells (lists) and symbols,
	the literal must be preceded by a single quote character to
	distinguish the literal from actual code, which has the
	external representation of lists and symbols.  However,
	because there is no possibility for ambiguity, lists and
	symbols appearing as components of vectors and lists must not
	use the quote character.  For example, \|'(a b c)| is a
	literal list of three elements, the symbols \|a|, \|b|, and
	\|c|.  This is not the same as \|'('a 'b 'c)| nor \|('a 'b
	'c)|.  The second is a literal list of three elements also,
	but the elements are the lists \|(quote a)|, \|(quote b)|, and
	\|(quote c)|, since the single quote character is transformed
	by the \Gref{reader} into a list whose car is the symbol
	\|quote|.  Note that in \Talk, equivalent literals within a
	module may be folded into a single instance.  Therefore, you
	should not destructively modify a literal.}

\Gitem 	{load}
	{The process of bringing a \Gref{program unit} into the
	current environment.  This process has two steps:  linking and
	\Gref{elaboration}.  Only \Gref{module}s and \Gref{libraries}
	can be loaded. The function \|load-program-unit| loads a
	program unit; the special macro characters \Hat\|-A| loads a
	program unit in its compiled form, while \Hat-\|B| loads a
	program unit in its interpreted form for debugging.}

\Gitem	{keyword}
	{A \Gref{symbol} used to explicitly name an argument to a
	function, or as a syntactic marker.  Several \Gref{function}s,
	notably those dealing with program units, take keyword
	arguments.  In addition, many \Gref{macro}s, such as
	\|defstructure|, also take keywords to specify various
	options.  Keywords often add legibility to code, but in the
	case of functions they must be decoded at runtime, which can
	be expensive.  Therefore, \Talk\ only supports keywords for
	macros (which can be decoded by the compiler) and functions
	whose overhead is much greater than the cost of decoding the
	keywords.}

\Gitem	{macro}
	{A syntactic extension which transforms a \Talk\ form into
	another \Talk\ form.  Macros provide one of the most powerful
	features of \Talk\/ --- the ability to extend the language
	itself to provide a better match with your problem domain.
	Macros are expanded at compilation time, which means that your
	macros must exist in the \Gref{compilation environment} of any
	uses of them.  Externally, macro uses look much like function
	calls:  The name of the macro is the \Gref{car} of the macro
	form, and the other forms are the arguments to the macro.
	Most of the syntax in \Talk\ is defined as macros which expand
	into unwieldy sequences \Gref{special form}s; this means that
	the user need only see the simple syntax, while the compiler
	need only see the relatively small set of special forms.
	Macros are defined by \|defmacro|\footnote{Itself a macro!}.}

\Gitem	{macro character}
	{A character which, when read, performs more complicated
	actions than simply reading itself.  For example, macro
	characters can be expanded at read-time into more complicated
	forms, or return literals directly.  The most commonly used
	macro character in \Talk\ is the single quote character \|'|,
	which is used to quote literals in code.  When a sequence of
	the form \|'<object>| is read (where \|<object>| is any \Talk\
	form), this character actually returns the form \|(quote
	<object>)|.  Macro characters can be broadly grouped into two
	categories:  Individual macro characters, like \|'|, and sharp
	macro characters, which only take effect when immediately
	preceded by the sharp character \|\#|.  Sharp macro characters
	are more frequently used to designate objects of various
	types.  For example, \|\#u| and \|\#p| create pathnames; \|\#'|
	designates functions; and \|\#\%| creates integers in base 2.
   	You should avoid creating macro characters of your own, since
   	they introduce various complex dependencies which are
   	invisible to the analysis tools provided in \Talk, and are
   	generally hard to debug, maintain, use, and understand.  You
   	should also avoid using the macro characters which provide for
   	read-time evaluation of forms, such as \|\#+|, \|\#-|, and
   	\|\#.|, as the environment in which the forms are interpreted
   	is difficult to control properly, and the interpreted forms
   	will never be compiled.}

\Gitem	{metaclass}
	{A class object whose instances are also class objects.  The
	existence of metaclasses follows very simply from the
	existance of class objects:  Every object has a class.  A
	class is an object.  Therefore, a class also has a class.
	This class is called a metaclass.  The instances of a
	metaclass are classes. The instances of these classes, in
	turn, are called metainstances.  In \Talk, there is one
	distinguished metaclass, called \|class|, which is an instance
	of itself, avoiding the necessity of using up all your
	computer's memory to create the infinite regress implied in
	the simple definition of metaclass given above.  \\
	Classes are responsible for the structure and behavior of
	their instances.  Metaclasses, being classes, are responsible
	for the structure and behavior of their instances, which are
	classes.  The behavior of a class includes its instance
	representation and inheritance support.  Therefore, a
	metaclass controls the representation of its metainstances and
	the inheritance strategy used by its instances.  So, for
	example, we have metaclasses which implement mixin
	inheritance, or single inheritance, or ``indirect objects''
	which can change size and class dynamically. \\
	In practice, you will probably encounter metaclasses very
	rarely.  However, you should be aware of the existence of one
	metaclass, named \|structure-class|.  This metaclass is the
	class of all structure classes.  It is responsible for the
	simple behavior and subsequent efficiency of structures;
	classes which are not instances of \|structure-class| are
	considerably more general, but much less efficient.  You
	should use structures whenever possible.}

\Gitem	{method}
	{An object responsible for the code executed by a generic
	function for a particular set of argument classes.  Methods
	are defined using \|defmethod|. Each generic function has some
	methods attached to it.  When the generic function is called,
	it determines which methods are applicable for the arguments
	passed to the generic function.  It does this using a two-step
	process: First, all the methods attached to the generic
	function are filtered; only those which specialize on the
	appropriate argument classes (or superclasses of those
	classes) are kept.  Secondly, the methods are sorted from most
	to least specific.  The sort is a lexicographic, left-to-right
	sort.  In other words, the first argument is more important
	than the second in determining method specificity.  Finally,
	the most specific method is called.  If this method calls
	\|call-next-method|, the next most specific method is called
	with the same arguments, and so on.  \\
	This process is only done once for a given set of argument
	classes; after that, the previous answer is stored in the
	generic function's \Gref{method cache} so that the next call
	is much more rapid.  Typically, calling a generic function is
	about five times slower than calling a regular function.  Your
	mileage may vary; in particular, the current version of \Talk\
	better optimizes generic functions with methods which
	specialize only on the first or first and second arguments,
	and with five or less arguments in all. \\
	Methods in \Talk\ can be specialized for several arguments;
	the first argument is not treated specially.  Methods which
	are specialized on several arguments are called multi-methods. \\
	Methods are not code, but objects which contain a function
	called when the method is applied.  This function is called
	the {\em method function}.  You can create method functions
	using the macro \|method-function-lambda|.  You can also
	create anonymous methods using \|method-lambda|.\\
	Note that a generic function must be defined (using
	\|defgeneric|) before you can define a method for it using
	\|defmethod|.  This ensures that all definitions have a single
	point of definition, which is necessary for the system to
	automatically determine module dependencies.}

\Gitem	{method cache}
	{A kind of hash table stored in each generic function.  The
	table is indexed by the set of argument classes passed to the
	generic function, and returns the sorted list of applicable
	methods for those argument classes.  The generic function
	cache is filled in for a particular key the first time the
	generic function is called with that set of argument classes.
	It is emptied whenever a method is added to a generic
	function, or by an explicit call to
	\|clear-generic-function-cache|.  Method caches allow
	(relatively) high-performance implementations of generic functions.}

\Gitem	{module}
	{A collection of related definitions treated as a single
	compilation unit.  Modules are the fundamental building blocks
	of \Talk\ programs; all code is structured into modules.  A
	module is a kind of \Gref{program unit}: It has a module
	description file with an extension of \|.lm|, one or more
	source code files with extensions of \|.ll|, and is compiled
	into a \langc\ source file and immediately into a standard
	object file.  For certain definition classes, a definition can
	be either exported or internal to a module.  In particular,
	functions and static variables can be either exported or
	internal.  If internal, these entities are visible only to
	code in the module: They have \Gref{module scope}.  If
	exported, they have \Gref{global scope}, but the compiler will
	warn you if you refer to such a definition without importing
	the exporting module. \\
	Modules are analyzed with \|analyze-program-unit|, compiled
	with \|build-program-unit|, loaded with \|load-program-unit|,
	and tested with \|test-program-unit|.}

\Gitem	{module scope}
	{A definition which can be referenced only within its module
	is said to have module scope.  In particular, unexported
	functions and static variables have module scope.  Other kinds
	of definition have \Gref{global scope}.  Bindings which are
	not definitions have either \Gref{lexical scope} or
	\Gref{dynamic scope}.}
	
\Gitem	{multiple argument}
	{\Talk\ provides two ways to define n-ary functions:  Those
	defined with \|\&rest| in their \Gref{lambda list} and those
	defined with \|\&multiple|.  The latter type have the advantage
	of keeping the $n$ arguments on the stack, rather than
	allocating explicit storage for them (which might cause a
	garbage collection).  They have the disadvantage of requiring
	special forms to refer to them, and of becoming invalid once
	the called function returns.  Multiple arguments defined with
	\|\&rest| are more expensive to allocate.  However, they are
	more flexible, since they are stored in a list, and the
	binding can be closed over.  Such \|\&rest| arguments can also
	be passed to other functions using \|apply|, while
	\|\&multiple| arguments cannot.  Whenever possible, you should
	use \|\&multiple| since it is more efficient.  However, you
	should not hesitate to use \|\&rest| in non-critical portions
	of code which would benefit from its flexibility.}

\Gitem	{next handler}
	{The next \Gref{condition} \Gref{handler} in the stack of
	handlers.  The root of this handler stack is the predefined
	handler named \|default-handler|.  You can add handlers to the
	stack in a dynamic scope using the form \|with-handler|.
	Within a \Gref{handler method}, you can call the next handler
	using the form \|call-next-handler|.  Note that the handler
	stack is orthogonal to the applicable method list of a
	particular handler; calling \|call-next-method| in a handler
	method calls the next most applicable method in the same
	handler, while \|call-next-handler| calls the most specific
	method of the next handler in the stack.}

\Gitem	{next method}
	{When a \Gref{generic function} is called, a certain set of
	\Gref{method}s are applicable for the given set of arguments.
	These are sorted from most to least specific, and then the
	most specific is called.  The next most specific method is
	called the next method, and may in turn be called using
	\|call-next-method|.  This provides a way to inherit and
	extend behavior from superclasses without knowing the exact
	name of the superclass --- contrast this to \Cpp, in which you
	must explicitly name the superclass when extending behavior.
	If the superclass changes, you must manually modify each
	virtual function which refers to that superclass.  In \Talk,
	the abstract, dynamic facility of \|call-next-method| allows
	you to avoid modifying this code, without even recompiling
	your methods.}

\Gitem	{nil}
	{A constant whose value is \|()|.  This constant should not be
	used in \Talk; rather, use \|()| directly.  Note that the
	symbols \|nil| and \|()| are distinct objects.}

\Gitem	{object}
	{What is an object?  This is a difficult question to answer
	precisely.  However, we can say that an object is a kind of
	\Gref{pointer} with a \Gref{class} known to the \Talk\ memory
	manager.  Such objects are divided into classes, based on
	their representation:  \Gref{immediate} objects and
	\Gref{row}s.  Currently, there is only one class of immediate
	objects:  \|fix|.  All other objects are rows, and
	allocated on the heap.  Within the set of rows, we can make
	two further distinctions:  \Gref{pointer row}s, which are
	sequences of pointers, and \Gref{byte row}s, which are
	sequences of bytes.  Currently, there is only one class of
	byte rows:  \|string|.  All other classes are implemented as
	pointer rows.}
	
\Gitem	{optional argument}
	{A non-required argument to a function.  The \Gref{lambda
	list} keyword \|\&optional| introduces optional arguments in a
	lambda list.  Optional arguments can have default values, and
	you can also specify an additional boolean argument associated
	with the optional argument which determines if the optional
	argument was supplied or not.}

\Gitem	{pathname}
	{An object representing a file or directory.  Pathname objects
	are better than strings for representing paths because they
	are portable; when doing file system operations, you can avoid
	most operating-system dependencies with pathnames.  You can
	make a pathname with the function \|make-pathname| or with the
	macro characters \|\#u| and \|\#p|.}

\Gitem	{pointer}
	{Any legal value which can be referenced in \Talk\ is called a
	pointer.  The \Talk\ memory manager can handle references which come
	from foreign languages, such as \langc\ or \Cpp.  These
	references are all pointers, but they are not considered
	objects.  You can store a pointer in a pointer row, but you
	may not pass it to a function which dynamically checks the
	type of its argument (and thus expects a true \Talk\ object)
	since foreign pointers do not have types.}

\Gitem	{pointer row}
	{A \Gref{row} whose contents are \Gref{pointer}s.  All \Talk\
	objects except strings and fixes are pointer rows.  All
	pointer rows are allocated on the heap by class-specific
	allocators.}

\Gitem	{printer}
	{A method on the generic function \|prin-object| which
	implements a class-specific printing function.  Printers are
	defined with \|defprinter|.  Printers are inherited by
	subclasses.}

\Gitem	{program unit}
	{A \Gref{module}, \Gref{library}, or \Gref{executable}: One of
	the units used to structure \Talk\ programs.  Every program
	unit is described by a \Gref{program unit description file}.
	A certain number of operations can be applied to almost every
	program unit: The function \|analyze-program-unit| determines
	if a program unit's description is correct, and corrects what
	it can automatically.  For example, in the case of modules it
	finds any syntax errors and fills in module dependencies.
	The function \|build-program-unit| constructs the program
	unit's object file.  In the case of modules, this is a
	standard object file; for libraries, a shared library; and for
	executables, an executable file with its associated memory
	image. The function \|load-program-unit| loads a module or
	library into memory, and \|test-program-unit| runs a program
	unit's associated test files.}

\Gitem	{program unit database}
	{A kind of pseudo-\Gref{program unit} which is used to store
	information about a set of program units.  These databases are
	used by the program unit analyzer to automatically determine
	module dependencies, as well as by a number of other tools to
	help you navigate in a \Talk\ program.  Program unit databases
	are described by \Gref{program unit description file}s, and
	can be built with \|build-program-unit|.  A list of active
	program unit databases is maintained via the function
	\|program-unit-database-precedence-list|.  In general, each
	project should maintain one or two program unit databases;
	when delivering libraries, an associated program unit database
	describing the library's exports should also be delivered.}

\Gitem 	{program unit description file}
	{A file with a \|.lm| extension which lists the properties of
	a \Gref{program unit}.  This file consists of a sequence of
	keys and values.  Every program unit description file starts
	with a header line indicating the type of the program unit
	being described and the program unit's name, which must be the
	same as the base name of the description file.  The header key
	used to define modules is \|defmodule|; for libraries,
	\|deflibrary|; and for executables, \|defexecutable|.  The
	keys valid for each type are described fully in the reference
	manual.}

\Gitem	{proper list}
	{A \Gref{list} whose final cdr contains \|()|.  Most \Talk\
	list operations assume you have passed a proper list by
	ignoring the value of the final cdr.}

\Gitem	{protocol}
	{A set of related \Gref{class}es and \Gref{generic function}s
	which together implement some useful functionality.  A
	protocol is distinguished from a simple program by the fact
	that the interaction between the various components are
	documented so that the user can extend the protocol by writing
	new subclasses and methods for the generic functions.}

\Gitem	{reader}
	{A function which returns the value of a \Gref{slot} in an
	object.  Readers are defined via \|defstructure|, \|defclass|,
	or \|defreader| or \|defaccessor|.  Every \Gref{slot
	description} has a reader and a \Gref{writer} used for slot
	accesses; it is to these functions that any reader name for
	the slot is bound.  Note that readers for structure classes
	are simple functions or macros, and are thus more efficient
	than readers for slots in instances of \|class|, which are
	generic functions and thus slower.}

\Gitem	{required argument}
	{An argument that must be passed to a function.  In a
	\Gref{lambda list}, all the required arguments must appear
	before any of the \Gref{optional arguments} or the
	\Gref{multiple argument}, if any.}

\Gitem	{rest argument}
	{In an n-ary function, a rest argument is a list containing
	all the arguments not bound to \Gref{required} or
	\Gref{optional argument}s.  A rest argument is introduced in a
	lambda list by the \|\&rest| keyword.  Rest arguments are
	contrasted with \Gref{multiple argument}s, which also
	implement n-ary functions but keep the arguments on the stack
	rather than allocating a list.  See \Gref{multiple argument}
	for more information.}

\Gitem	{row}
	{A non-immediate \Gref{object}.  Rows are always allocated on
	the heap; they are always sequences of elements of some length
	with a specific clan.  There are two kinds of rows:
	\Gref{Pointer row}s, whose elements can be any \Gref{pointer},
	and \Gref{byte row}s, whose elements are always bytes.
	Currently, only the class \|string| has instances which are
	byte rows.}

\Gitem	{scope}
	{The textual area of a program in which a \Gref{binding} can
	be referenced.  There are four kinds of scope in \Talk:
	\Gref{lexical scope} and \Gref{dynamic scope} for temporary
	bindings, and \Gref{module scope} and \Gref{global scope} for
	definitions.   See the individual entries for more detail.}

\Gitem	{s-expression}
	{A legal \Talk\ form which can be treated as code.  In
	particular, either an \Gref{atom} or a \Gref{proper list}
	treated as a \Gref{macro} call, \Gref{function} call, or
	\Gref{special form}.  In fact, the term ``s-expression'' is
	used much less now than formerly in the \Lisp\ community.  We
	usually refer to ``forms'' in this document.}

\Gitem	{slot}
	{A named field in an \Gref{object}.  Every \Gref{class}
	defined with \|defstructure| and \|defclass| has a set of
	named slots.  Slots are generally accessed via \Gref{reader}
	and \Gref{writer} functions, collectively termed
	\Gref{accessor}s.  Within a class object, each slot is
	described by a \Gref{slot description} object.}

\Gitem	{slot description}
	{Each slot defined for a \Gref{class} is described in the
	class object by a slot description.  This object is used in
	conjunction with the class object to determine how instances
	of the class are allocated, and how the reader and writer
	functions for the slot are calculated.  The slot description
	object can also be used introspectively to dynamically
	determine the name of a slot, its position, and its accessor
	functions.}

\Gitem	{source file}
	{In \Talk, source files have the extension \|.ll|.  They
	consist of a sequence of \Talk\ forms and comments.  Most of
	the forms are \Gref{definition}s.  Each source file should be
	attached to a single \Gref{module}; all operations (except
	editing the code) are done on the module rather than the
	source file.}

\Gitem	{specialized lambda list}
	{A kind of \Gref{lambda list} used in a \Gref{method} to
	determine the set of classes for which the method is
	applicable.  In contrast to a normal lambda list, the
	\Gref{required argument}s in specialized lambda lists may be
	enclosed in a list whose second element is the name of a
	\Gref{class}.  When all the arguments supplied to the
	\Gref{generic function} are instances of the respective class
	or one of its subclasses, the method is applicable.}

\Gitem	{specializer}
	{The \Gref{class} for which a \Gref{method} is applicable for
	a particular \Gref{required argument}.}

\Gitem	{static variable}
	{A global variable, modeled after \langc's \|static|
	allocation class.  Static variables are always defined at a
	\Gref{module}'s top level using \|defstatic|.  They can be
	accessed using the special form \|static|, and set via \|setf|
	with \|static|.  Static variables can either be exported or
	internal to a module; if internal, they can only be referenced
	within the module; if external, they can also be referenced by
	modules which export the defining module.  Compared to
	\Gref{dynamic variable}s, static variables offer greater
	security since references are verified by the compiler.
	However, they cannot be locally rebound.}

\Gitem	{string}
	{A sequence of characters.}

\Gitem	{structure}
	{A kind of \Gref{class} with limitations allowing the
	implementation to make several important optimizations.
	Structures can only use single inheritance, and can only
	inherit from other structure classes.  They use a standard
	object and slot representation.  These two limitations mean
	that accesses to slots are quite fast, often compiling to a
	single memory reference.  Structures should be used instead of
	more general classes whenever possible, since object-oriented
	applications often spend a great deal of time accessing slots.
	Structures are defined either with \|defstructure|, or with
	\|defclass| by specifying \|structure-class| as the value of
	the class option \|metaclass|.}

\Gitem	{subclass}
	{A \Gref{class} can have any number of subclasses. Each
	subclass inherits the structure --- {\em ie}, the slots ---
	and the behavior --- {\em ie}, the methods --- defined for the
	class or its \Gref{superclasses}.  The subclass relation in
	\Talk\ is interpreted to mean ``is-a''; that is, you should
	not create a subclass $C_2$ of a class $C_1$ unless you can
	say that an instance of $C_2$ is also an instance $C_1$.  For
	other operations, you should use slots.}

\Gitem 	{superclass}
	{The opposite of \Gref{subclass}, a superclass is a class from
	which a class inherits its structure and behavior.  The
	inheritance hierarchy in \Talk\ forms a DAG whose
	distinguished root is the class \|object|, which is the only
	class in \Talk\ which has no superclass.  By default, \Talk\
	classes can have only one superclass --- in other words, they
	are in single inheritance.  However, libraries are provided
	which implement multiple inheritance as well.}

\Gitem	{symbol}
	{An object whose identity is determined completely by its
	name.  In other words, for any given symbol name, only one
	symbol with that name exists.  This means that symbols make
	execellent keywords, as their identities can be compared using
	a simple pointer comparison.  The name of a symbol is divided
	into two parts:  The package, another symbol; and a root name,
	a string.  An unpackaged symbol actually has the package
	\|()|.  Symbols are normally created as quoted literals, but
	they can be explicitly created using the functions \|symbol|
	(which may find an existing symbol) or \|gensym| (which always
	produces a new symbol by creating a new name).}

\Gitem	{tag}
	{A marker in the control stack or a label allowing control
	flow transfer.  Tags can be created with the special forms
	\|catch|, \|block|, and \|tagbody|.  In the latter two cases,
	references to the tag must all be in the \Gref{lexical scope}
	of the form.  Tags created with \|catch| have \Gref{dynamic
	scope}.  In all cases, tags have \Gref{dynamic extent}; it is
	considered too costly to implement full continuations.  In the
	case of \|catch|, the tag is an evaluated object.  In the case
	of \|block| and \|tagbody|, tags are unevaluated symbols.  You
	can transfer control to tags created with \|catch| using
	\|throw|; with \|block|, \|return-from|; and with \|tagbody|,
	\|go|.}

\Gitem	{test file}
	{A source file with the extension \|.lt| in a special format
	used to perform non-regression tests for \Gref{module}s.  Each
	module has a list of test files under the key \|test-files| in
	its \Gref{program unit description file}.  The format of a
	test file is quite simple:  It consists of alternating
	evaluated forms and unevaluated expected results.  If the form
	should provoke an error, the result should be a list whose car
	is the symbol \|error|.  (You should not design forms whose
	normal return value is such a list!)  You may divide test
	files into sections by introducing a form whose car is the
	symbol \|test-series| and whose second element is a string
	describing the nature of the series.  Program units can be
	tested using the function \|test-program-unit|.}

\Gitem	{top-level form}
	{A \Gref{form} which is not nested in another form.  Certain
	forms --- in particular, \Gref{defining form}s --- can only
	appear at the top level, or within a certain number of other
	top-level forms.  Defining forms can appear either directly at
	the top-level, or within the body of a \|progn| or \|let|
	itself following the same rule.  Top-level forms are executed
	sequentially when a module is elaborated.  Note that top level
	forms in a module are slightly different than top-level forms
	in the \Gref{top-level loop}: Definitions within a module are
	treated as part of that module and are taken into account by
	the module analyzer; nothing special is done with forms typed
	at the top-level loop.}

\Gitem	{top-level loop}
	{An interactive loop in which the user types forms, they are
	evaluated by the interpreter, and the result is then printed
	out.  The top level loop is characterized by three prompts:
	The read prompt, returned and set using the function
	\|prompt|; the ``in-read'' prompt, which is printed when the
	reader is waiting for the completion of a form; and the result
	prompt, printed before the result of a form.  By default,
	these three prompts are \|?|, a blank space, and \|=|
	respectively.  The top-level loop in \Talk\ is primarily
	useful for entering simple expressions, analyzing and
	compiling program units, and debugging.  Any complicated forms
	should be put in a module to ensure that they are not lost. \\
	A simple line editor mechanism known as \|edlin| can be
	invoked in the top level.  It provides for basic editing
	commands, much like Emacs, and a history mechanism.  The line
	editor can be turned on using the function \|edlin|, and
	turned off using \|edlinend|.}

\Gitem	{type}
	{The name of a \Gref{class}.  All types in \Talk\ have a
	corresponding class, and all classes have a corresponding
	type.  The only formal difference is that ``class'' means a
	class object, while ``type'' means the name of a class, which
	is a symbol.  Sometimes the terms ``type'' and ``class'' are
	used interchangeably when the situation is unambiguous.  You
	can find out the type of any object using the function
	\|type-of|.}

\Gitem	{vector}
	{An object of type \|vector| whose elements are accessed by
	numerical index.  Vector indexes in \Talk\ are zero-based.
	Vectors are single-dimensional; multi-dimensional arrays are
	implemented using vectors of vectors.  Vectors are created by
	the functions \|makevector| and \|vector|, and are accessed
	using \|vref| and \|vset|.  Vector access is quite efficient;
	bounds checking is only done at development level \|debug|.
	Vectors cannot be dynamically resized; you can use the
	advanced datatype \|evector| for this purpose.  Vectors have
	the same internal representation as \langc\ vectors:  a simple
	sequence of pointers.  \Talk\ vectors can be passed to \langc\
	functions without conversion.}

\Gitem	{virtual terminal}
	{A generic interface to various terminals, allowing you to
	write terminal-independent tty-based applications.  The
	virtual terminal interface provides essentially the same
	capabilities as the \Unix\ \|termcap| or \|terminfo|
	facilities, but may not be implemented using these facilities
	on other operating systems.}

\Gitem	{walker}
	{A \Talk\ program which analyzes forms and modules, producing
	an abstract syntax tree (AST) as its result.  This AST is then
	used by the interpreter and compiler, providing a certain
	guarantee of consistency between interpreted and compiled
	code.}

\end{description}

\End
