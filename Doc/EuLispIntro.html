<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title><b>An Introduction to EuLisp, EuXLisp and Youtoo</b></title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2010-07-01 22:08:44 BST"/>
<meta name="author" content="of original Euscheme notes Russell Bradford"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">

<h1 class="title"><b>An Introduction to EuLisp, EuXLisp and Youtoo</b></h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 EuLisp index </a></li>
<li><a href="#sec-2">2 Introduction </a></li>
<li><a href="#sec-3">3 Running EuXLisp </a></li>
<li><a href="#sec-4">4 Running Youtoo </a></li>
<li><a href="#sec-5">5 Constants </a></li>
<li><a href="#sec-6">6 Lists and Vectors </a></li>
<li><a href="#sec-7">7 Expressions </a></li>
<li><a href="#sec-8">8 Conditionals </a></li>
<li><a href="#sec-9">9 Assignment </a></li>
<li><a href="#sec-10">10 Defining Functions </a></li>
<li><a href="#sec-11">11 Arithmetic </a></li>
<li><a href="#sec-12">12 Modules </a></li>
<li><a href="#sec-13">13 Errors and the Debug Loop </a></li>
<li><a href="#sec-14">14 Classes and Generic Functions </a></li>
<li><a href="#sec-15">15 Threads </a></li>
<li><a href="#sec-16">16 Input and Output </a></li>
<li><a href="#sec-17">17 Macros </a></li>
<li><a href="#sec-18">18 Miscellany </a></li>
<li><a href="#sec-19">19 Example Modules </a></li>
<li><a href="#sec-20">20 EuLisp functions </a></li>
<li><a href="#sec-21">21 EuXLisp functions </a></li>
<li><a href="#sec-22">22 Command Line Arguments </a></li>
<li><a href="#sec-23">23 Shell Scripts </a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> <a href="../index.html">EuLisp index</a> </h2>
<div class="outline-text-2" id="text-1">

</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Introduction </h2>
<div class="outline-text-2" id="text-2">

<p>This introduction to EuLisp is based on the
<a href="http://people.bath.ac.uk/masrjb/Sources/eunotes.html">Euscheme notes</a>
written by Russell Bradford.  Much of the text remains more or less unchanged
but reformatted in Org-mode and exported as HTML.  Also some changes
have been made and continue to be made to keep this document consistent with
the evolving EuLisp definition and EuXLisp and Youtoo implementations.
</p>
<p>
EuXLisp is a simple EuLisp Level 0 interpreter.  EuLisp Level 0 is a small and
compact Lisp, but nevertheless has many interesting features, such as modules,
an object system, and multithreading.  EuLisp Level 1 has extra features, the
most notable being a full metaobject system which are implemented in Youtoo.
This introduction to EuLisp using EuXLisp and Youtoo concentrates on those
things unique to EuLisp rather than covering basic Lisp concepts which are
already covered well in many texts.
</p>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Running EuXLisp </h2>
<div class="outline-text-2" id="text-3">

<ul>
<li id="sec-3.1"><a href="./euxlisp.html">Man page</a> <br/>
<ul>
<li>
<a href="./euxlisp.html">EuXLisp man page (HTML)</a>
</li>
<li>
<a href="./euxlisp.1">EuXLisp man page (ASCII)</a>
</li>
</ul>
</li>
<li id="sec-3.2">Setting environment variables <br/>
EuXLisp need two paths: where to look for the compiled image, and where to
look for modules to load:
<ul>
<li id="sec-3.2.1">Image <br/>
First euxlisp checks the environment variable <code>EU_IMAGE_PATH</code> (a colon
separated list of directory names), then a builtin path, set from
<code>IMAGE_SEARCH_PATH</code> in the Makefile.
</li>
<li id="sec-3.2.2">Modules <br/>
ditto for environment variable <code>EU_MODULE_PATH</code>, then builtin
<code>MODULE_SEARCH_PATH</code> (e.g., you might want to provide a set of system
supplied modules).
</li>
<li id="sec-3.2.3">Default settings <br/>
The default built-in settings should work for a default build with the
files in their default locations.
</li>
</ul>
</li>
<li id="sec-3.3">Running Interactively <br/>
type
<ul>
<li>
<code>Bin.${ARCH}/euxlisp</code>
</li>
</ul>

<p>without options to start the EuXLisp interpreter which will print the banner
and prompt:
</p>


<pre class="src src-eulisp"><span style="color: #000000;">EuXLisp</span> (<span style="color: #0000ff; font-weight: bold;">formally</span> <span style="color: #000000;">EuScheme</span>) - <span style="color: #000000;">Version</span> 0.991
<span style="color: #000000;">Reading</span> readline history from ${<span style="color: #000000;">HOME</span>}/.eulisp_history

user&gt;
</pre>


<p>
where the final line is the prompt.  EuXLisp uses the usual read-eval-print
cycle of interactive Lisps: type something, it will be evaluated, and the
result printed.  To exit, use
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(exit</span>)
</pre>


<p>
and (usually) ^D will work, too.
</p></li>
<li id="sec-3.4">Executing a module <br/>
To execute the module <code>fact</code> in file <code>fact.em</code> run
<ul>
<li>
<code>echo "(!&gt; fact)"  | ../../Bin.${ARCH}/euxlisp -q</code>
</li>
</ul>

<p>The <code>echo</code> pipes the load module <code>!&gt;</code> command to the interpreter.  In the
future there will be a command-line option to execute a module directly.
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Running Youtoo </h2>
<div class="outline-text-2" id="text-4">

<ul>
<li id="sec-4.1">Options <br/>
to see the command-line options type



<pre class="src src-eulisp"><span style="color: #000000;">Bin.x86_64/youtoo</span> -help
<span style="color: #000000;">Usage:</span> youtoo [<span style="color: #0000ff;">&lt;options&gt;</span>] &lt;source-file(<span style="color: #0000ff; font-weight: bold;">s</span>)&gt; [<span style="color: #0000ff;">&lt;options&gt;</span>]
-help                 --  show usage
-version              --  show current release
-params               --  show current parameter setting
-load_path <span style="color: #0000ff;">&lt;dir&gt;</span>      --  add <span style="color: #0000ff;">&lt;dir&gt;</span> to load path
-c                    --  create <span style="color: #000000;">C</span> linkable module file only
-ar                   --  create <span style="color: #000000;">C</span> linkable library file
-l <span style="color: #0000ff;">&lt;lib&gt;</span>              --  specify <span style="color: #000000;">C</span> linkable library
-L <span style="color: #0000ff;">&lt;dir&gt;</span>              --  extent <span style="color: #000000;">C</span> linkable library load path
-fff <span style="color: #0000ff;">&lt;file&gt;</span>           --  specify <span style="color: #000000;">C</span> foreign function file
-ffl <span style="color: #0000ff;">&lt;lib&gt;</span>            --  specify <span style="color: #000000;">C</span> foreign function library
-o <span style="color: #0000ff;">&lt;file&gt;</span>             --  destination file
-od <span style="color: #0000ff;">&lt;dir&gt;</span>             --  destination directory for object files
--script <span style="color: #0000ff;">&lt;file&gt;</span>       --  script mode
-silent               --  silent mode
-verbose              --  verbose mode
-no_warnings          --  no warning messages
-no_errors            --  no <span style="font-weight: bold;">error messages</span>
-no_else              --  omit warning for if without else
-redefine             --  redefine imported bindings
-no_inline            --  ignore inline declarations
-stop_after <span style="color: #0000ff;">&lt;phase&gt;</span>   --  stop after compilation phase (<span style="color: #0000ff; font-weight: bold;">e.g.</span> read)
-recompile            --  recompile imported modules
-no_recompile         --  no automatic recompilation of imports
-no_gc                --  garbage collection library not linked
-cc                   --  used <span style="color: #000000;">C</span> compiler
-ld                   --  used <span style="color: #000000;">C</span> linker
-ar_cmd               --  used <span style="color: #000000;">C</span> ar command
-ranlib_cmd           --  used <span style="color: #000000;">C</span> ranlib command
-cflags               --  additional <span style="color: #000000;">C</span> flag
-static               --  no shared libraries used
-g                    --  <span style="color: #000000;">C</span> debug info
-i                    --  force interpretation mode
-no_ct_handlers       --  no compile-time <span style="font-weight: bold;">error handling</span>
</pre>


</li>
<li id="sec-4.2">Running Interactively <br/>
type
<ul>
<li>
<code>Bin.${ARCH}/youtoo</code>
</li>
</ul>

<p>which will print the banner and prompt:
</p>


<pre class="src src-eulisp"><span style="color: #000000;">EuLisp</span> <span style="color: #000000;">System</span> <span style="color: #000000;">Youtoo</span> - <span style="color: #000000;">Version</span> 0.991'
<span style="color: #000000;">Reading</span> readline history from ${<span style="color: #000000;">HOME</span>}/.eulisp_history

user&gt;
</pre>


<p>
where the final line is the prompt.  Youtoo uses the usual read-eval-print
cycle of interactive Lisps: type something, it will be evaluated, and the
result printed.  For help type
</p>


<pre class="src src-eulisp">user&gt; help:
load: <span style="color: #0000ff;">&lt;file-name&gt;</span>          evaluate file expressions
?                          previous value
lexical-bindings:          show lexical environment
verbose:                   run verbose
silent:                    run silent
trace: <span style="color: #0000ff;">&lt;function-name&gt;</span>     trace function invocation
untrace: <span style="color: #0000ff;">&lt;functon-name&gt;</span>    stop tracing function invocation
backtrace:                 show backtrace
values:                    show stack values
continue:                  continue computation
reset:                     resume from all errors
resume:                    resume from previous <span style="font-weight: bold;">error</span>
[<span style="color: #000000;">Ctrl-d</span>]                   exit interpreter or resume from previous <span style="font-weight: bold;">error</span>
[<span style="color: #000000;">Ctrl-c</span>]                   interrupt computation
[<span style="color: #000000;">Ctrl-z</span>]                   suspend interpreter
exit:                      exit interpreter
-&gt; #&lt;file-stream: stdout&gt;
user&gt;
</pre>


<p>
to exit type
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(exit</span>)
</pre>


</li>
<li id="sec-4.3">Compiling <br/>
In directory <code>Examples/Misc</code> run
<ul>
<li>
<code>Bin.${ARCH}/youtoo fact -l level1</code>
</li>
</ul>

<p>to compile module fact into a stand-alone executable. With shared libraries
the executable should be less the 40K.
</p></li>
<li id="sec-4.4"><a href="../Youtoo/README.html">See also</a> <br/>
<a href="../Youtoo/README.html">Youtoo README</a>

</li>
</ul>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Constants </h2>
<div class="outline-text-2" id="text-5">

<p>There are the usual self-evaluating bits and pieces:
</p><ul>
<li>
strings: in double quotes "hello"
</li>
<li>
numbers: integers and floating point <code>1234</code> and <code>3.1415</code>
</li>
<li>
characters: preceded by <code>#\</code> as in <code>#\c</code> for the character 'c'
</li>
<li>
vectors: delimited by <code>#(</code> and <code>)</code> as in <code>#(1 a (3))</code> which is a vector of
length 3, containing an integer, a symbol, and a list.

</li>
</ul>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Lists and Vectors </h2>
<div class="outline-text-2" id="text-6">

<p>Lists are created with the usual <code>cons</code>, <code>list</code> and quoted forms '(1 2 3).
Use <code>car</code> and <code>cdr</code> to access the elements.
</p>
<p>
A vector is created by the function <code>make-vector</code> as in
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(make-vector</span> 4)
</pre>


<p>
which creates a vector of length 4, indexed from 0 to 3, all elements
initialised to be =()=s.  In fact, make-vector can take a second argument
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(make-vector</span> 4 0)
</pre>


<p>
which creates a vector as before, with all elements initialised to 0.
</p>
<p>
To access a vector element use <code>(vector-ref vec index)</code>; to update use
<code>((setter vector-ref) vec index newval)</code>.  See below for details about the
setter function.
</p>
<p>
Take care with the creation of vectors: <code>(make-vector 3 #(0 0 0))</code> will create
a vector of three slots, all initialised to the same <code>eq</code> value.
</p>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Expressions </h2>
<div class="outline-text-2" id="text-7">

<p>As is usual, anything that is not a constant is an expression to be evaluated,
and those things marked by a quote are deemed to be constant.  Thus
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(+</span> 1 2)
</pre>


<p>
is an expression to be evaluated, while
</p>


<pre class="src src-eulisp">'<span style="color: #0000ff; font-weight: bold;">(+</span> 1 2)
</pre>



<p>
is a constant list of 3 elements (modifying constant lists has an undefined
effect, so it's best not to do so).  EuLisp has both progn to collect together
several expressions into a single expression, and let for the declaration of
local variables.
</p>


<pre class="src src-eulisp">(progn
  expr
  expr
  ...
)
</pre>


<p>
and
</p>


<pre class="src src-eulisp">(let ((<span style="color: #0000ff; font-weight: bold;">var</span> val)
      (<span style="color: #0000ff; font-weight: bold;">var</span> val)
      ...)
  expr
  expr
  ...
)
</pre>


<p>
(Semantics: evaluate all the vals first, then make the bindings to the
corresponding vals.  Thus the vals cannot refer to the vars.  Use let*
</p>


<pre class="src src-eulisp">(let* ((<span style="color: #0000ff; font-weight: bold;">var1</span> val1)
       (<span style="color: #0000ff; font-weight: bold;">var2</span> val2)
       ...)
  ...)
</pre>


<p>
with semantics of evaluate <code>val1</code>, bind to <code>var1</code>, evaluate <code>val2</code>, bind to
<code>var2</code>, etc., if you need to refer back to previous values.)
</p>
<p>
The values of these expressions are the values of their last exprs.  Named
<code>let</code> and <code>let*</code> are also supported.
</p>
<p>
Numbers have the usual syntax: <code>123</code>, <code>1.23</code> and <code>1.2e4</code>.  Additionally, you
can enter integers in base 2: <code>#b101010</code>, base 8: <code>#o7654</code>, base 16: <code>#x12ab</code>,
and any other base up to 36: <code>#23r12gd</code> for a base 23 integer.
</p>
<p>
The full syntax of symbols is somewhat tricky, but "alphanumerics, starting
with a letter" is certainly OK.  Dodgy characters, such as space, or a leading
digit can be escaped with a <code>\</code>.  A multiple character escape is introduced
and ended by <code>|</code>.  Within the confines of these delimiters any character is
fine, except that <code>\|</code> is interpreted as a literal <code>|</code>, and <code>\\</code> as a literal
<code>\</code>.
</p>
<p>
All the following are the same symbol:
</p>


<pre class="src src-eulisp">\1\ 23
|1 |23
|1 23|
|1 |2|3|
|1 |2\3
\1| |2||3
</pre>


<p>
Their canonical form is <code>|1 23|</code>.
</p>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Conditionals </h2>
<div class="outline-text-2" id="text-8">

<p>EuLisp has the usual <code>(if boolexpr trueexpr falseexpr)</code> (always with both
trueexpr and falseexpr), and the <code>cond</code> form.  The single false value in
EuLisp is <code>()</code>: anything else is deemed to be true.  <code>t</code> is bound to the
symbol <code>t</code>, providing a convenient canonical true value.  Additional
conditional forms include
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(when</span> boolexpr
   expr
   expr
   ...
)
</pre>


<p>
where the exprs are evaluated when the condition is true; and
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(unless</span> boolexpr
   expr
   expr
   ...
)
</pre>


<p>
where the exprs are evaluated when the condition is false.
</p>
</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Assignment </h2>
<div class="outline-text-2" id="text-9">

<p><code>setq</code> as usual:
</p>


<pre class="src src-eulisp">(<span style="color: #0000ff; font-weight: bold;">setq</span> foo 2)
</pre>



<p>
It's also good to define module-local variables:
</p>


<pre class="src src-eulisp">(deflocal <span style="color: #0000ff;">foo</span> 2)
</pre>


<p>
You can omit the initial value if you want.  The <code>deflocal</code> form should only
be used at the top level (i.e., never inside a function definition or a
<code>let</code>).
</p>
</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> Defining Functions </h2>
<div class="outline-text-2" id="text-10">

<p>Here we use defun.
</p>


<pre class="src src-eulisp">(defun <span style="color: #0000ff; font-weight: bold;">len</span> (<span style="color: #0000ff; font-weight: bold;">l</span>)
  (if (<span style="color: #0000ff; font-weight: bold;">null</span> l)
      0
      <span style="color: #0000ff; font-weight: bold;">(+</span> 1 (<span style="color: #0000ff; font-weight: bold;">len</span> <span style="color: #0000ff; font-weight: bold;">(cdr</span> l)))))
</pre>


<p>
EuLisp is fully tail-recursive, so a function written in a tail-recursive way
uses no stack:
</p>


<pre class="src src-eulisp">(defun <span style="color: #0000ff; font-weight: bold;">foo</span> (<span style="color: #0000ff; font-weight: bold;">n</span>)
  <span style="color: #0000ff; font-weight: bold;">(print</span> n)
  (<span style="color: #0000ff; font-weight: bold;">foo</span> <span style="color: #0000ff; font-weight: bold;">(+</span> n 1)))
</pre>


<p>
will run forever.
</p>
<p>
Variable arity functions are available, too:
</p>


<pre class="src src-eulisp">(defun <span style="color: #0000ff; font-weight: bold;">bar</span> (<span style="color: #0000ff; font-weight: bold;">a</span> b .  c)
  <span style="color: #0000ff; font-weight: bold;">(list</span> a b c))
</pre>



<p>
can take 2 or more arguments.  The first two arguments are bounds to a and b
as usual, the rest are made into a list which is bound to c.  Thus <code>(bar 1 2 3   4 5)</code> prints <code>(1 2 (3 4 5))</code>, and <code>(bar 99 100)</code> prints <code>(99 100 ())</code>.
</p>
</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> Arithmetic </h2>
<div class="outline-text-2" id="text-11">

<p>All the usual stuff here.  Functions <code>+</code>, <code>-</code>, <code>*</code> and <code>/</code>, <code>abs</code>, <code>sin</code>,
<code>exp</code> and so on.  Use <code>(pow a b)</code> to raise <code>a</code> to power <code>b</code>.  Additionally,
the basic arithmetic ops have variable arity:
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(+</span>)         -&gt; 0
<span style="color: #0000ff; font-weight: bold;">(+</span> 1)       -&gt; 1
<span style="color: #0000ff; font-weight: bold;">(+</span> 1 2)     -&gt; 3
<span style="color: #0000ff; font-weight: bold;">(+</span> 1 2 3)   -&gt; 6
<span style="color: #0000ff; font-weight: bold;">(-</span> 1)       -&gt; -1
<span style="color: #0000ff; font-weight: bold;">(*</span> 1 2 3 4) -&gt; 24
</pre>



<p>
and so on.
</p>
</div>

</div>

<div id="outline-container-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> Modules </h2>
<div class="outline-text-2" id="text-12">

<p>Now for something a little different.  The basic unit of a program in EuLisp
is the module.  Modules provide a way of fixing the global namespace pollution
problem: each module has its very own namespace.  A module can import names
from other modules, and can export names too.
</p>
<p>
Here is a simple module:
</p>


<pre class="src src-eulisp">(defmodule <span style="color: #0000ff; font-weight: bold;">one</span>
  (<span style="color: #0000ff; font-weight: bold;">import</span> (<span style="color: #0000ff; font-weight: bold;">level0</span>))

  (defun <span style="color: #0000ff; font-weight: bold;">foo</span> ...)
  (defun <span style="color: #0000ff; font-weight: bold;">bar</span> ...)
  (deflocal <span style="color: #0000ff;">baz</span> ...)
  ...

  (<span style="color: #0000ff; font-weight: bold;">export</span> foo baz)
)
</pre>


<p>
The module one imports from the system module named <code>level0</code>.  This module
contains all the useful stuff like <code>cons</code>, <code>car</code>, <code>defun</code>, <code>+</code> and so on.  In
fact, it's generally a good idea to import the <code>level0</code> module, otherwise you
can't actually do anything.
</p>
<p>
In module one we define a few name, like <code>foo</code>, <code>bar</code> and <code>baz</code>, and export
<code>foo</code> and <code>baz</code>.  Now any module that imports one can access <code>foo</code> and <code>baz</code>,
but bar is completely hidden from everyone.
</p>
<p>
If now, we have
</p>


<pre class="src src-eulisp">(defmodule <span style="color: #0000ff; font-weight: bold;">two</span>
  (<span style="color: #0000ff; font-weight: bold;">import</span> (<span style="color: #0000ff; font-weight: bold;">level0</span> one))

  ...
)
</pre>


<p>
the module two imports one (and <code>level0</code>), so two can refer to <code>foo</code> and <code>baz</code>
from one.  If two uses a name <code>bar</code>, it is its own <code>bar</code>, and has nothing to
do with the <code>bar</code> in one.
</p>
<ul>
<li id="sec-12.1">Modules in EuLisp <br/>
EuXLisp and Youtoo require each module to be in a file of its own: thus one
should be in a file named one.em (for EuLisp module), and two in <i>two.em</i>.
To enter a module, use



<pre class="src src-eulisp">(<span style="color: #0000ff; font-weight: bold;">!&gt;</span> one)
</pre>


<p>
which will load one if it is not already loaded, and will set the current
module to be one.  This is indicated by the prompt
</p>


<pre class="src src-eulisp">user&gt; (<span style="color: #0000ff; font-weight: bold;">!&gt;</span> one)
&lt;reading one.em&gt;
&lt;read one.em&gt;
<span style="color: #0000ff;">&lt;one...done&gt;</span>
#t
one&gt;
</pre>


<p>
Now the read-eval-print loop acts on bindings in the one module.  Use <code>(!&gt;     user)</code> to switch back to the original module.
</p>
<p>
To re-load a module (after, say, changing the file) use <code>(!&gt;&gt; one)</code>.
</p>
<p>
Modules can rename and filter on <code>import</code> (not yet on <code>export</code>).  Use
level0.em for all the basic stuff, e.g.,
</p>


<pre class="src src-eulisp">(defmodule <span style="color: #0000ff; font-weight: bold;">mymod</span>
  (<span style="color: #0000ff; font-weight: bold;">import</span> (<span style="color: #0000ff; font-weight: bold;">level0</span>))
  ...
  )
</pre>


<p>
If you <code>import</code> no modules, you get nothing&mdash;not even special forms!  See
<i>Modules/rename.em</i>.
</p>
<p>
Look at directory <i>Modules</i> for a few examples (the basic EuLisp functionality
in the modules in <i>EuXLisp/Boot</i> are written the scheme-like syntax of
xscheme).
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> Errors and the Debug Loop </h2>
<div class="outline-text-2" id="text-13">

<p>When you make an error, EuLisp will call an error handler.  The full use of
error handlers is too tricky for an introductory set of notes, so we shall
rely on the default (built-in) handler.  In EuXLisp an error puts the system
into a simple debugging loop:
</p>


<pre class="src src-eulisp">user&gt; qwerty
<span style="color: #000000;">Continuable</span> error---calling default handler:
<span style="color: #000000;">Condition</span> class is #&lt;class unbound-error&gt;
message:        <span style="color: #00ff00;">"variable unbound in module 'user'"</span>
value:          qwerty

<span style="color: #000000;">Debug</span> loop.  <span style="color: #000000;">Type</span> help: for help
<span style="color: #000000;">Broken</span> at #&lt;Code #1008a768&gt;

<span style="color: #000000;">DEBUG&gt;</span>
</pre>


<p>
There is a lot of information here, and you should look carefully at what
EuXLisp is telling you.
</p>
<p>
In this case, the call of error is an 'unbound-error', i.e., reference to an
undefined variable.  The message gives an English description of the error,
while the value fills in some details, so it is the variable named qwerty that
is at fault.
</p>
<p>
Another error:
</p>


<pre class="src src-eulisp">user&gt; <span style="color: #0000ff; font-weight: bold;">(car</span> 5)
<span style="color: #000000;">Continuable</span> error---calling default handler:
<span style="color: #000000;">Condition</span> class is #&lt;class bad-type&gt;
message:        <span style="color: #00ff00;">"incorrect type in car"</span>
value:          5
expected-type:  #&lt;class cons&gt;

<span style="color: #000000;">Debug</span> loop.  <span style="color: #000000;">Type</span> help: for help
<span style="color: #000000;">Broken</span> at #&lt;Code #100820a8&gt;

<span style="color: #000000;">DEBUG&gt;</span>
</pre>


<p>
This is a 'bad-type' error, where the function car was expecting a different
type of argument; it got a 5, where it was expecting something of class cons,
i.e., some sort of list.
</p>
<p>
The prompt becomes <code>DEBUG&gt;</code> to indicate we are in the debug loop.  In this
loop things act as normal, except we have some additional functions to play
with.  Type help: to get
</p>


<pre class="src src-eulisp"><span style="color: #000000;">Debug</span> loop.
top:                                return to top level
resume:  or  (<span style="color: #0000ff; font-weight: bold;">resume:</span> val)          resume from <span style="font-weight: bold;">error</span>
bt:                                 backtrace
locals:                             local variables
cond:                               current condition
up:  or  (<span style="color: #0000ff; font-weight: bold;">up:</span> n)                    up one or n frames
down:  or  (<span style="color: #0000ff; font-weight: bold;">down:</span> n)                down one or n frames
where:                              current function
</pre>


<p>
The most useful of these is top:, which clears up the error and returns us to
the top-level read-eval-print loop; and bt: which gives us a backtrace, i.e.,
a list of the function calls and their arguments that took us to where we are
now.  (Note that, as EuLisp is tail recursive, EuXLisp does not save all the
return addresses of the functions that it travels through, so the backtrace
may omit certain intermediate function calls.)
</p>
<p>
In a debug loop ^D will act as resume:, which is to try to carry on from the
point of error.  Debug loops can be nested.
</p>
</div>

</div>

<div id="outline-container-14" class="outline-2">
<h2 id="sec-14"><span class="section-number-2">14</span> Classes and Generic Functions </h2>
<div class="outline-text-2" id="text-14">

<p>EuLisp has a full object system.  At Level 0, it is a simple, non-reflective
system, comparable to C++'s class system.  Every object in EuLisp has a class,
which is itself a first-class object: this means that classes are supported at
the same level as any other object in the system, and can be created, passed
to functions, returned from functions, and so on.  For example, the integer
<code>1</code> has class <code>&lt;integer&gt;</code> (or rather, has a class with name <code>&lt;integer&gt;</code>).
</p>
<p>
In fact, EuXLisp has (class-of 1) to be <code>&lt;fpi&gt;</code> (for fixed point integer),
which is a subclass of <code>&lt;integer&gt;</code>.
</p>
<p>
Classes are fully-fledged objects, so they have a class, too
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(class-of</span> <span style="color: #0000ff;">&lt;integer&gt;</span>) -&gt; #&lt;class class&gt;
</pre>


<p>
the print representation of the class <code>&lt;class&gt;</code>.  Finally, (class-of
<code>&lt;class&gt;</code>) is <code>&lt;class&gt;</code> itself, or else we would need an infinite tower of
classes.
</p>
<p>
To make an instance of a class, use make
</p>


<pre class="src src-eulisp">(make <span style="color: #0000ff;">&lt;cons&gt;</span> car: 1 cdr: 2) -&gt; (<span style="color: #0000ff; font-weight: bold;">1</span> .  2)
</pre>


<p>
The keywords (symbols whose names end with colons) indicate how to fill in the
various slots of the instance of the class.  The keywords can be in any order,
and can be omitted if not necessary: though some classes have slots with
required keywords.  This means that instances of such classes must have
certain information passed to make in order to succeed.  Some classes are
abstract, and you cannot make instances of them.  They are there purely for
other classes to inherit from.  The class <code>&lt;list&gt;</code> is abstract, while its
subclass <code>&lt;cons&gt;</code> is concrete.
</p>
<p>
It is simple to create new classes by the use of defclass.
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(defclass</span> <span style="color: #0000ff;">&lt;rat&gt;</span> ()
   ((<span style="color: #0000ff; font-weight: bold;">num</span> keyword: num:
         default: 0
         accessor: num)
    (<span style="color: #0000ff; font-weight: bold;">den</span> keyword: den:
         default: 1
         accessor: den))
    predicate: rat?
    constructor: (<span style="color: #0000ff; font-weight: bold;">rat</span> num: den:))
</pre>


<p>
There are many parts to explain.
</p>
<p>
This form defines a new class named <code>&lt;rat&gt;</code>.  Classes in EuLisp are
conventionally noted by the use of angle brackets <code>&lt;&gt;</code>, but they are just
normal names.  The <code>()</code> next is the list of classes for <code>&lt;rat&gt;</code> to inherit
from.  In EuLisp Level 0, there is only single inheritance, so this should be
a list of at most one class.  Any empty list indicates some suitable default
super-class.
</p>
<p>
Next is a list of slot descriptions.  Each has a slot name first, then a list
of slot options.  The slot options are identified by keywords which can come
in any order, and can be omitted it you don't want them.
</p>
<p>
The slot options are:
</p><ul>
<li>
<code>keyword:</code> a keyword to use in a make of the class instance.
</li>
<li>
<code>default:</code> a default value to put in the slot if a value is not passed via
the keyword.
</li>
<li>
<code>accessor:</code> a name that will be bound to functions to read and write the
slot.  In the above example, num will name a function to read the num slot
in an instance of <code>&lt;rat&gt;</code>.  Similarly, <code>(setter num)</code> will be a function to
write to such a slot.  See setters.
</li>
<li>
<code>reader:</code> a name for a slot reader.
</li>
<li>
<code>writer:</code> a name for a slot writer.
</li>
<li>
<code>required?:</code> use <code>required?: t</code> to indicate a required slot.  This slot must
have a =keyword: keyword=!

</li>
</ul>

<p>The <code>accessor:</code>, <code>reader:</code> and <code>writer:</code> options can be repeated as many times
as you wish with different names.
</p>
<p>
Next come the class options.  Again, in any order or omitted.
</p>
<ul>
<li>
<code>predicate:</code> a symbol to name a function that will return true on an
instance of the class, and false on all other objects.
</li>
<li>
<code>constructor:</code> a way to name a function to make an instance of the class.
In this case, rat will name a function of two arguments that makes an
instance of <code>&lt;rat&gt;</code>.  The first argument will be given to the <code>num:</code>
keyword, the second to the <code>den:</code>.  This is equivalent to defining



<pre class="src src-eulisp">(defun <span style="color: #0000ff; font-weight: bold;">rat</span> (<span style="color: #0000ff; font-weight: bold;">n</span> d)
  (make <span style="color: #0000ff;">&lt;rat&gt;</span> num: n den: d))
</pre>


<p>
As usual, you can reorder or leave out bits as you feel.
</p></li>
<li>
<code>abstract?: t</code> to indicate that this class is abstract, and no direct
instances can be made.

</li>
</ul>

<p>The class options <code>predicate:</code> and <code>constructor:</code> can be repeated.
</p>
<p>
To see all the currently defined classes in EuXLisp use <code>(class-hierarchy)</code>.
Other useful functions include class-superclasses, class-subclasses and
class-slots.
</p>
<ul>
<li id="sec-14.1">Generic Functions <br/>
Generic functions are (again) first-class objects in EuLisp, constructed by
<code>defgeneric</code>.  Methods are added to them by defmethod (unlike some other
systems, a generic function must be created by defgeneric before <code>defmethod</code>
will work.)



<pre class="src src-eulisp">(defgeneric <span style="color: #0000ff; font-weight: bold;">foo</span> (<span style="color: #0000ff; font-weight: bold;">a</span> b))

(defmethod <span style="color: #0000ff; font-weight: bold;">foo</span> ((<span style="color: #0000ff; font-weight: bold;">a</span> <span style="color: #0000ff;">&lt;integer&gt;</span>) (<span style="color: #0000ff; font-weight: bold;">b</span> <span style="color: #0000ff;">&lt;integer&gt;</span>))
  <span style="color: #0000ff; font-weight: bold;">(list</span> 'int 'int))

(defmethod <span style="color: #0000ff; font-weight: bold;">foo</span> ((<span style="color: #0000ff; font-weight: bold;">x</span> <span style="color: #0000ff;">&lt;float&gt;</span>) (<span style="color: #0000ff; font-weight: bold;">y</span> <span style="color: #0000ff;">&lt;float&gt;</span>))
  <span style="color: #0000ff; font-weight: bold;">(list</span> 'float 'float))
</pre>


<p>
This defines a generic of two arguments, and two methods.  So
</p>


<pre class="src src-eulisp">(<span style="color: #0000ff; font-weight: bold;">foo</span> 4 5)     -&gt; (<span style="color: #0000ff; font-weight: bold;">int</span> int)
(<span style="color: #0000ff; font-weight: bold;">foo</span> 1.0 2.0) -&gt; (<span style="color: #0000ff; font-weight: bold;">float</span> float)
(<span style="color: #0000ff; font-weight: bold;">foo</span> 2 2.0)   -&gt; <span style="font-weight: bold;">error</span>, <span style="color: #00ff00;">"no applicable methods"</span>
</pre>


<p>
The methods discriminate off all the arguments, working left to right.
Adding another method
</p>


<pre class="src src-eulisp">(defmethod <span style="color: #0000ff; font-weight: bold;">foo</span> ((<span style="color: #0000ff; font-weight: bold;">n</span> <span style="color: #0000ff;">&lt;number&gt;</span>) (<span style="color: #0000ff; font-weight: bold;">m</span> <span style="color: #0000ff;">&lt;number&gt;</span>))
  <span style="color: #0000ff; font-weight: bold;">(list</span> 'num 'num))
</pre>


<p>
we get <code>(foo 2 2.0) -&gt; (num num)</code>.  Generally the most specific method for a
given set of arguments is the method that is executed in a generic call.
The next most specific method can be invoked by using <code>(call-next-method)</code>
in the body of the current method.
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-15" class="outline-2">
<h2 id="sec-15"><span class="section-number-2">15</span> Threads </h2>
<div class="outline-text-2" id="text-15">

<p>EuLisp supports multiple threaded programming by supplying some basic thread
primitives.
</p>
<p>
To make a thread use
</p>


<pre class="src src-eulisp">(<span style="color: #0000ff; font-weight: bold;">make-thread</span> fn)
</pre>


<p>
which returns a thread object (another first-class object).  The fn is the
function that the thread will start executing when it and when starts running.
</p>
<p>
A thread will not run until it is started
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(thread-start</span> thr arg arg ...)
</pre>


<p>
This function takes a thread thr and starts executing the function <code>fn</code> (from
<code>make-thread</code>) on the arguments <code>arg</code>.  That is, it starts executing <code>(fn arg   arg ...)</code>.
</p>
<p>
Or it would start executing the thread if there were enough processors to do
so.  As is most likely, the thread is simply marked as ready to run whenever
the resource is available.  The EuLisp model requires the programmer to write
in such a manner that does not presume any particular number of processors are
available.  Even if there is just one processor, the program should be written
to work.  To aid this, there is the function
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(thread-reschedule</span>)
</pre>


<p>
which will suspend the current thread, and allow another to run in its place.
If there are enough processors so that all threads are running, then
thread-reschedule could have no effect at all.
</p>
<p>
An single-threaded implementation such as EuXLisp requires a sprinkling of
thread-reschedules for a parallel program to work.
</p>
<p>
Threads are often used for their effect, but they can also return a value.
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(thread-value</span> thr)
</pre>


<p>
will suspend the calling thread (and allow another to run in its place) until
the thread thr returns a value (and returns what the thr returned).  A thread
can return a value simply by returning from its initial function (<code>fn</code>,
above).
</p>
<ul>
<li id="sec-15.1">Semaphores <br/>
EuLisp provides simple binary semaphores, named locks, with functions
<code>make-lock</code> to make one, lock to gain a semaphore, and unlock to release.

<p>
Locking a locked lock will suspend the calling thread (and allow another to
run) until some other thread releases the lock.
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-16" class="outline-2">
<h2 id="sec-16"><span class="section-number-2">16</span> Input and Output </h2>
<div class="outline-text-2" id="text-16">

<ul>
<li>
<code>read</code> to read a Lisp expression.
</li>
<li>
<code>write</code> write to standard output in a way that can be re-read if possible.
Thus, for example, strings are quoted.
</li>
<li>
<code>prin</code> print to standard output in a human-friendly manner.  Strings and
such are not quoted.  Compare



<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(prin</span> <span style="color: #00ff00;">"asd"</span>)    prints: asd
<span style="color: #0000ff; font-weight: bold;">(write</span> <span style="color: #00ff00;">"asd"</span>)   prints: <span style="color: #00ff00;">"asd"</span>
</pre>


</li>
<li>
<code>print</code> as <code>prin</code>, with a newline.
</li>
<li>
Print and write functions are n-ary:



<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(prin</span> <span style="color: #00ff00;">"one = "</span> 1 <span style="color: #00ff00;">", two = "</span> 2)    prints: one = 1, two = 2
<span style="color: #0000ff; font-weight: bold;">(write</span> <span style="color: #00ff00;">"one = "</span> 1 <span style="color: #00ff00;">", two = "</span> 2)   prints: <span style="color: #00ff00;">"one = "</span>1<span style="color: #00ff00;">", two = "</span>2
</pre>


</li>
<li>
<code>newline</code> output a newline.

</li>
</ul>

<p>All of the above have variants beginning with an 's' which take a stream to
print on as the first argument.
</p>
<p>
For stream manipulation:
</p><ul>
<li>
open-input-file takes a string, and opens and returns a corresponding
stream for input.  Returns <code>()</code> if not such file exists.
</li>
<li>
open-output-file creates a file if it didn't already exist.
</li>
<li>
open-update-file opens for append.
</li>
<li>
get-file-position and <code>(setter get-file-position)</code> move the file pointer in
a file opened for update.
</li>
<li>
close-stream closes an open stream.

</li>
<li id="sec-16.1">Format <br/>
A more complicated printing function is <code>sformat</code>, which is somewhat akin to
C's <code>printf</code>.



<pre class="src src-eulisp">(<span style="color: #0000ff; font-weight: bold;">sformat</span> stream format-string arg arg ...)
</pre>


<p>
The variants <code>format</code> and <code>fmt</code> do not take a stream argument and the former
prints to standard output and the latter returns the formatted output as a
string.
</p>
<p>
The format string is copied to the output, except that <code>~</code> marks an escape
(like C's <code>%</code>):
</p><ul>
<li>
<code>~a</code> output the next arg using <code>prin</code>
</li>
<li>
<code>~s</code> output the next arg using <code>write</code>
</li>
<li>
<code>~%</code> output a newline
</li>
<li>
<code>~~</code> output a <code>~</code>
</li>
<li>
<code>~c</code> output a character
</li>
<li>
<code>~d</code> output an integer
</li>
<li>
<code>~e</code> <code>~f</code>, <code>~g</code> floating point formats
</li>
<li>
<code>~t</code> output a tab

</li>
</ul>

<p>There are other escapes to write integers in other bases, output new pages,
and so on.
</p>
<p>
<code>fmt</code> can be used with the n-ary print and write functions to write complex
formatted output statements in a more readable form that using <code>format</code>
\e.g.\
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(print</span> <span style="color: #00ff00;">"one = "</span> 1 <span style="color: #00ff00;">", x = "</span> (<span style="color: #0000ff; font-weight: bold;">fmt</span> <span style="color: #00ff00;">"~e"</span> 0.000002)) prints: one = 1, x = 2.000000e-06
</pre>



</li>
</ul>
</div>

</div>

<div id="outline-container-17" class="outline-2">
<h2 id="sec-17"><span class="section-number-2">17</span> Macros </h2>
<div class="outline-text-2" id="text-17">

<p>EuLisp employs the usual backquoted template style of macros.
</p>


<pre class="src src-eulisp">(defmacro <span style="color: #0000ff; font-weight: bold;">first</span> (<span style="color: #0000ff; font-weight: bold;">x</span>)
  `<span style="color: #0000ff; font-weight: bold;">(car</span> ,x))
</pre>


<p>
Note that a macro cannot be used in the module where it is defined: a module
must be fully macroexpanded before it can be compiled.  If you don't know what
is and what isn't a macro beforehand, it is very difficult to do this.  Thus a
module containing
</p>


<pre class="src src-eulisp">(defmacro <span style="color: #0000ff; font-weight: bold;">second</span> (<span style="color: #0000ff; font-weight: bold;">x</span>)
   `<span style="color: #0000ff; font-weight: bold;">(cadr</span> ,x))

(defun <span style="color: #0000ff; font-weight: bold;">foo</span> (<span style="color: #0000ff; font-weight: bold;">x</span>) <span style="color: #0000ff; font-weight: bold;">(+</span> 1 (<span style="color: #0000ff; font-weight: bold;">second</span> x)))
</pre>


<p>
is doomed to failure by this restriction.
</p>
<p>
There is a wrinkle in the way that macros interact with modules: suppose a
macro expands into something that refers to bindings that are not imported
into the current module?
</p>


<pre class="src src-eulisp">(defmodule <span style="color: #0000ff; font-weight: bold;">one</span>
  (<span style="color: #0000ff; font-weight: bold;">import</span> (<span style="color: #0000ff; font-weight: bold;">level0</span>))

  (defmacro <span style="color: #0000ff; font-weight: bold;">foo</span> (<span style="color: #0000ff; font-weight: bold;">x</span>)
     `<span style="color: #0000ff; font-weight: bold;">(car</span> (<span style="color: #0000ff; font-weight: bold;">bar</span> ,x)))

  (defun <span style="color: #0000ff; font-weight: bold;">bar</span> (<span style="color: #0000ff; font-weight: bold;">a</span>) ...)

  (<span style="color: #0000ff; font-weight: bold;">export</span> foo)
)
</pre>


<p>
Here the module <code>one</code> exports foo only, but <code>foo</code> expands into a reference to
<code>bar</code>.
</p>


<pre class="src src-eulisp">(defmodule <span style="color: #0000ff; font-weight: bold;">two</span>
  (<span style="color: #0000ff; font-weight: bold;">import</span> (<span style="color: #0000ff; font-weight: bold;">level0</span>))

  ...
  (<span style="color: #0000ff; font-weight: bold;">foo</span> 4)
  ...
)
</pre>


<p>
In the macroexpansion of module <code>two</code>, a reference to bar would appear, but
bar is not defined in <code>two</code>.  Worse, maybe <code>bar</code> was defined in <code>two</code>: which
<code>bar</code> does the macroexpanded form refer to? The <code>bar</code> from <code>one</code> or the <code>bar</code>
from <code>two</code>?
</p>
<p>
The answer is "the right <code>bar</code>", that is that <code>bar</code> in the module of macro
definition, not the <code>bar</code> in the module of macro use.  EuLisp takes care of
all of this transparently for you: essentially every symbol remembers which
module it was defined in, and always refers back to that module for its value.
</p>
<p>
This provides a simple solution to the "macro hygene" problem that has always
plagued Lisp macros.
</p>
<p>
Sometimes you do want a symbol to be captured in the module of use: EuXLisp
provides a facility to allow you to do this.
</p>


<pre class="src src-eulisp">(defmacro <span style="color: #0000ff; font-weight: bold;">while</span> (<span style="color: #0000ff; font-weight: bold;">test</span> .  body)
  `(let/cc {break}
     (labels
       ((<span style="color: #0000ff; font-weight: bold;">loop</span> ()
          <span style="color: #0000ff; font-weight: bold;">(when</span> ,test
                ,@body
                (<span style="color: #0000ff; font-weight: bold;">loop</span>))))
       (<span style="color: #0000ff; font-weight: bold;">loop</span>))))
</pre>


<p>
The symbol loop cannot be captured by the code in body, while the symbol break
is intended to be captured.  The curly braces about the symbol indicates that
it is to be interpreted as coming from the module of use, not the module of
definition.  Thus, a reference to break in the body will refer to the binding
in the <code>let/cc</code>.
</p>
<p>
Notice that <code>(eq 'break '{break}) -&gt; t</code>.  As symbols they are <code>eq</code>, but as
identifiers they are quite different.
</p></div>

</div>

<div id="outline-container-18" class="outline-2">
<h2 id="sec-18"><span class="section-number-2">18</span> Miscellany </h2>
<div class="outline-text-2" id="text-18">

<ul>
<li id="sec-18.1">Keywords <br/>
There are keywords (unbindable, unassignable, self-evaluating symbols),
<i>e.g.</i>,



<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(defclass</span> foo ()
  ((<span style="color: #0000ff; font-weight: bold;">a</span> default: 99
      keyword: a:
      accessor: foo-a))
  constructor: (<span style="color: #0000ff; font-weight: bold;">make-foo</span> a:))
</pre>



</li>
<li id="sec-18.2">Comparisons <br/>
EuLisp has the usual tests for equality:
<ul>
<li>
<code>eq</code> for identity
</li>
<li>
<code>eql</code> for identity integers and characters
</li>
<li>
<code>binary=</code> generic function with methods for most types
</li>
<li>
=== n-ary equality which calls <code>binary=</code> for each pair

</li>
</ul>

<p>Note that
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(eql</span> 1 1.0)  -&gt; ()
<span style="color: #0000ff; font-weight: bold;">(=</span> 1 1.0)      -&gt; <span style="font-weight: bold; text-decoration: underline;">t</span>
</pre>


<p>
There is also the usual <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, which are n-ary:
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(&lt;</span> a b c ...)
</pre>


<p>
returns <code>t</code> when <code>a</code>, <code>b</code>, <code>c</code>, etc., form a strictly increasing sequence.
Similarly <code>&lt;=</code> for a non-decreasing sequence, and so on.
</p>
</li>
<li id="sec-18.3">Generic Arithmetic <br/>
The arithmetic operators <code>+</code> and so on are all n-ary, i.e., take a variable
number of arguments.  Each operator is defined in terms of a binary generic
function: <code>binary+</code> for <code>+</code>, <code>binary*</code> for <code>*</code>, etc.  The n-ary form is just
a repeated application of the binary form



<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(+</span> a b c ...) = ((<span style="color: #0000ff; font-weight: bold;">..</span><span style="color: #0000ff; font-weight: bold;">(binary+</span> <span style="color: #0000ff; font-weight: bold;">(binary+</span> a b) c) ...))
</pre>


<p>
Methods can be added to the binary operators
</p>


<pre class="src src-eulisp">(defmethod <span style="color: #0000ff; font-weight: bold;">binary+</span> ((<span style="color: #0000ff; font-weight: bold;">a</span> <span style="color: #0000ff;">&lt;symbol&gt;</span>) (<span style="color: #0000ff; font-weight: bold;">b</span> <span style="color: #0000ff;">&lt;symbol&gt;</span>))
  ...)
</pre>


<p>
and then you can use <code>+</code> to add symbols: <code>(+ 'a 'b 'c)</code>.
</p>
<p>
There are also generic functions <code>unary-</code> and <code>unary/</code> for the unary <code>(- x)</code>
and <code>(/ x)</code> (reciprocal).
</p>
<p>
Similarly, the comparators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> etc., are all defined in terms of
the two generic functions <code>binary&lt;</code> and <code>binary=</code>.
</p>
</li>
<li id="sec-18.4">Local Functions <br/>
Just like <code>let</code> introduces local variables, the <code>labels</code> form can introduce
local functions.



<pre class="src src-eulisp">(labels
  ((<span style="color: #0000ff; font-weight: bold;">foo</span> (<span style="color: #0000ff; font-weight: bold;">a</span> b)
     ...  (<span style="color: #0000ff; font-weight: bold;">bar</span> a) ...  )
   (<span style="color: #0000ff; font-weight: bold;">bar</span> (<span style="color: #0000ff; font-weight: bold;">x</span>)
     ...  (<span style="color: #0000ff; font-weight: bold;">foo</span> x (<span style="color: #0000ff; font-weight: bold;">bar</span> x)) ...  ))
  ...
  (<span style="color: #0000ff; font-weight: bold;">foo</span> 3 4)
  ...
)
</pre>


<p>
The <code>labels</code> takes a list of function definitions.  They may be self and
mutually recursive.  These functions may be used within the body of the
<code>labels</code> just like global functions.  Iterating functions are often most
conveniently written in terms of <code>labels</code> as the bodies of the function
definitions can refer to local variables:
</p>


<pre class="src src-eulisp">(let ((<span style="color: #0000ff; font-weight: bold;">a</span> 1))
  (labels
    ((<span style="color: #0000ff; font-weight: bold;">addit</span> (<span style="color: #0000ff; font-weight: bold;">x</span>)
       (if (<span style="color: #0000ff; font-weight: bold;">null</span> x)
           ()
           <span style="color: #0000ff; font-weight: bold;">(cons</span> <span style="color: #0000ff; font-weight: bold;">(+</span> a <span style="color: #0000ff; font-weight: bold;">(car</span> x)) (<span style="color: #0000ff; font-weight: bold;">addit</span> <span style="color: #0000ff; font-weight: bold;">(cdr</span> x))))))
    (<span style="color: #0000ff; font-weight: bold;">addit</span> '(<span style="color: #0000ff; font-weight: bold;">1</span> 2 3))))
-&gt;
(<span style="color: #0000ff; font-weight: bold;">2</span> 3 4)
</pre>



</li>
<li id="sec-18.5">Mapping and Collections <br/>
There are several functions supplied to iterate along collections.
Collections include <code>lists</code>, <code>vectors</code>, <code>strings</code>, and <code>tables</code>.

<p>
The generic function <code>map</code> takes a function and a collection
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(map</span> list '(<span style="color: #0000ff; font-weight: bold;">1</span> 2 3))   -&gt; ((<span style="color: #0000ff; font-weight: bold;">1</span>) (<span style="color: #0000ff; font-weight: bold;">2</span>) (<span style="color: #0000ff; font-weight: bold;">3</span>))
<span style="color: #0000ff; font-weight: bold;">(map</span> - #(<span style="color: #0000ff; font-weight: bold;">4</span> 5 6))      -&gt; #(<span style="color: #0000ff; font-weight: bold;">-4</span> -5 -6)
</pre>


<p>
or more than one collection
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(map</span> cons '(<span style="color: #0000ff; font-weight: bold;">a</span> b c) '(<span style="color: #000000;">A</span> <span style="color: #000000;">B</span> <span style="color: #000000;">C</span>))     -&gt; ((<span style="color: #0000ff; font-weight: bold;">a</span> .  <span style="color: #000000;">A</span>) (<span style="color: #0000ff; font-weight: bold;">b</span> .  <span style="color: #000000;">B</span>) (<span style="color: #0000ff; font-weight: bold;">c</span> .  <span style="color: #000000;">C</span>))
<span style="color: #0000ff; font-weight: bold;">(map</span> + #(<span style="color: #0000ff; font-weight: bold;">1</span> 2 3) #(<span style="color: #0000ff; font-weight: bold;">10</span> 10 10 10))  -&gt; #(<span style="color: #0000ff; font-weight: bold;">11</span> 12 13)
</pre>


<p>
The mapping stops when any collection runs out.  Even a mixture will work
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(map</span> * '(<span style="color: #0000ff; font-weight: bold;">2</span> 4 6) #(<span style="color: #0000ff; font-weight: bold;">1</span> -1 1))  -&gt; (<span style="color: #0000ff; font-weight: bold;">2</span> -4 6)
<span style="color: #0000ff; font-weight: bold;">(map</span> * #(<span style="color: #0000ff; font-weight: bold;">2</span> 4 6) '(<span style="color: #0000ff; font-weight: bold;">1</span> -1 1))  -&gt; #(<span style="color: #0000ff; font-weight: bold;">2</span> -4 6)
</pre>


<p>
The type of collection returned is the same as the first collection
argument.
</p>
<p>
If you don't need a return value, but are iterating purely for effect, use
do
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(do</span> print '(<span style="color: #0000ff; font-weight: bold;">1</span> 2 3))
</pre>


<p>
Other iterators include <code>accumulate</code>
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(accumulate</span> list () #(<span style="color: #0000ff; font-weight: bold;">a</span> b c))      -&gt; (((() a) b) c)
<span style="color: #0000ff; font-weight: bold;">(accumulate</span> * 1 '(<span style="color: #0000ff; font-weight: bold;">1</span> 2 3 4 5 6 7))  -&gt; 5040
</pre>



<p>
which takes a function, an initial value, an a collection to iterate over.
</p>
<p>
You can find the size of any collection using the function size.  This
returns the length of a list of string, number of elements of a vector, and
so on.  It can be reversed by reverse; an element removed by remove
(non-destructive) or by delete (destructive); find an element by (member elt
collection).  The last three (remove, delete and member) take an optional
last argument that is a test for equality: it is this test that is used when
looking for an element in the collection.  It defaults to eql.
</p>
<p>
The function concatenate can be used to join collections:
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(concatenate</span> '(<span style="color: #0000ff; font-weight: bold;">1</span> 2 3) '(<span style="color: #0000ff; font-weight: bold;">4</span> 5 6))  -&gt; (<span style="color: #0000ff; font-weight: bold;">1</span> 2 3 4 5 6)
<span style="color: #0000ff; font-weight: bold;">(concatenate</span> <span style="color: #00ff00;">"abc"</span> <span style="color: #00ff00;">"def"</span>)        -&gt; <span style="color: #00ff00;">"abcdef"</span>
<span style="color: #0000ff; font-weight: bold;">(concatenate</span> '(<span style="color: #0000ff; font-weight: bold;">1</span> 2 3) #(<span style="color: #0000ff; font-weight: bold;">4</span> 5 6))  -&gt; (<span style="color: #0000ff; font-weight: bold;">1</span> 2 3 4 5 6)
</pre>



</li>
<li id="sec-18.6">Loops <br/>
EuLisp doesn't really need loops, as everything can be written in terms of
tail recursive functions.  However sometimes a simple loop form is more
convenient and readable and for this a <code>while</code> loop is provided:



<pre class="src src-eulisp">(while bool
   expr
   expr
   ...
)
</pre>


<p>
which loops while the bool returns <code>true</code>.
</p>
</li>
<li id="sec-18.7">Tables <br/>
EuLisp uses tables for a general association mechanism.  EuXLisp and Youtoo
implement tables as hash tables, but in general they could be implemented
differently.
<ul>
<li>
<code>make-table</code> returns a table.
</li>
<li>
<code>(table-ref table key)</code> to retrieve a value, <code>((setter table-ref) table       key value)</code> to update.
</li>
<li>
<code>(table-delete key)</code> to remove a value.
</li>
<li>
<code>table-keys</code> to get a list of current keys.
</li>
<li>
<code>table-values</code> to get a list of current values.
</li>
<li>
<code>table-clear</code> to completely empty a table.

</li>
</ul>

<p>When looking for a match to a key in a table, the system defaults to <code>eql</code>.
You can change this by using <code>(make-table comparator)</code>, where <code>comparator</code>
is <code>eq</code> or <code>eql</code> or <code>binary=</code> or ===.
</p>
<p>
If a value is not found for a particular key in the table <code>()</code> is returned.
This can be changed by <code>(make-table comparator fill-value)</code>.  Now
<code>fill-value</code> will be returned on failure.
</p>
<p>
The mapping functions above work on tables, too.
</p>
</li>
<li id="sec-18.8">Non-local exits <br/>
EuLisp supports a limited form of continuation capture via <code>let/cc</code>.  This
form captures its continuation, and allows its use as a non-local exit.



<pre class="src src-eulisp">(let/cc out
   ...
   (<span style="color: #0000ff; font-weight: bold;">out</span>)
   ...
)
<span style="color: #ff00ff; font-weight: bold;">;; </span><span style="color: #ff00ff;">after
</span></pre>


<p>
This stores the continuation (i.e., from 'after') in the variable <code>out</code>.
This can be called as a function, whereupon control passes immediately to
that continuation.  The value of out can only be used in this way in the
dynamic scope of the <code>let/cc</code> form: outside the value is 'dead' and no
longer usable.
</p>
<p>
The continuation function can take a single optional argument which is a
value to pass to the continuation: the default is <code>()</code>.
</p>
<p>
The forms <code>block</code> and <code>return-from</code> are simply =let/c=c and a call to a
continuation:
</p>


<pre class="src src-eulisp">(block foo
  ...
  (return-from foo)
  ...
)
</pre>


<p>
The unwind-protect form ensures things are executed even if there is a
non-local exit
</p>


<pre class="src src-eulisp">(unwind-protect
  protected-form
  after-form
  after-form
  ...)
</pre>



<p>
This starts by executing the <code>protected-form</code>.  If there is no unusual exit
from the <code>protected-form</code>, this will then execute the <code>after-forms</code> and will
return whatever value the <code>protected-form</code> returned.  If there is a
non-local exit from the <code>protected-form</code> to a continuation outside the
<code>unwind-protect</code>, the <code>after-forms</code> will still be executed before the
control passes to the continuation.
</p>
</li>
<li id="sec-18.9">Setters <br/>
Structures, like <code>lists</code>, <code>vectors</code> and <code>class</code> instances have elements that
can be accessed.  The elements of a <code>vector</code> can be read by <code>vector-ref</code>.
To write to an element use the function <code>(setter vector-ref)</code>,



<pre class="src src-eulisp">(<span style="color: #0000ff; font-weight: bold;">(setter</span> vector-ref) vec index val)
</pre>


<p>
Similarly, the accessor <code>car</code> has an updater <code>(setter car)</code> (often called
<code>rplaca</code> in other Lisps), and so on.  In general a reader function <code>r</code> will
have an associated updater <code>(setter r)</code>.
</p>
<p>
The function <code>setter</code> is a simple association mechanism: <code>setter</code> is a
function that takes a reader and returns the associated writer.  To make
such an association between functions <code>r</code> and <code>w</code> just use <code>setter</code> again
</p>


<pre class="src src-eulisp">(<span style="color: #0000ff; font-weight: bold;">(setter</span> setter) r w)
</pre>


<p>
In fact, no particular properties of <code>r</code> and <code>w</code>, are used, so this can be
used as a general facility.  Further, setter functions, generic functions
and methods can be defined directly:
</p>


<pre class="src src-eulisp">(defun <span style="color: #0000ff; font-weight: bold;">(setter</span> foo) (<span style="color: #0000ff; font-weight: bold;">a</span> b)
  ...)
</pre>



</li>
<li id="sec-18.10">Convert <br/>
The function <code>convert</code> is used to change an object of one type into an
object of another type.  Thus to convert an <code>integer</code> to a <code>float</code>



<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(convert</span> 1 <span style="color: #0000ff;">&lt;float&gt;</span>) -&gt; 1.0
</pre>


<p>
or the other way
</p>


<pre class="src src-eulisp"><span style="color: #0000ff; font-weight: bold;">(convert</span> 2.6 <span style="color: #0000ff;">&lt;integer&gt;</span>) -&gt; 2
</pre>



<p>
Many other conversions are available: <code>integer</code> to <code>string</code>; <code>character</code> to
<code>string</code>; <code>string</code> to <code>number</code>; <code>symbol</code> to <code>string</code>; <code>list</code> to <code>vector</code>;
and so on.
</p>
</li>
<li id="sec-18.11">Copying <br/>
There are two functions that copy structures: <code>deep-copy</code> and
<code>shallow-copy</code>.  The second recursively descends a structure making copies
of all the elements in the structure; the first makes a single copy of the
top-level structure, and fills its slots will the existing elements:



<pre class="src src-eulisp">(<span style="color: #0000ff; font-weight: bold;">setq</span> a '((<span style="color: #0000ff; font-weight: bold;">1</span> 2) (<span style="color: #0000ff; font-weight: bold;">3</span> 4)))
(<span style="color: #0000ff; font-weight: bold;">setq</span> d <span style="color: #0000ff; font-weight: bold;">(deep-copy</span> a))
<span style="color: #0000ff; font-weight: bold;">(eq</span> a d)                  -&gt; ()
<span style="color: #0000ff; font-weight: bold;">(binary=</span> a d)             -&gt; <span style="font-weight: bold; text-decoration: underline;">t</span>
<span style="color: #0000ff; font-weight: bold;">(eq</span> <span style="color: #0000ff; font-weight: bold;">(car</span> a) <span style="color: #0000ff; font-weight: bold;">(car</span> d))      -&gt; ()

(<span style="color: #0000ff; font-weight: bold;">setq</span> s <span style="color: #0000ff; font-weight: bold;">(shallow-copy</span> a))
<span style="color: #0000ff; font-weight: bold;">(eq</span> a s)                  -&gt; ()
<span style="color: #0000ff; font-weight: bold;">(binary=</span> a s)             -&gt; <span style="font-weight: bold; text-decoration: underline;">t</span>
<span style="color: #0000ff; font-weight: bold;">(eq</span> <span style="color: #0000ff; font-weight: bold;">(car</span> a) <span style="color: #0000ff; font-weight: bold;">(car</span> s))      -&gt; <span style="font-weight: bold; text-decoration: underline;">t</span>
</pre>



</li>
<li id="sec-18.12">Other EuXLisp Tools <br/>
<ul>
<li>
<code>describe</code> gives a little information about an object, e.g., <code>(describe       &lt;integer&gt;)</code> or <code>(describe 4)</code>
</li>
<li>
<code>trace</code> can be used to print a message every time a function is entered or
exited.  Thus



<pre class="src src-eulisp">(<span style="color: #0000ff; font-weight: bold;">trace</span> foo)
</pre>


<p>
will describe the ins and outs of the function <code>foo</code>.  To untrace, use
<code>(untrace foo)</code>.  Use <code>(import "trace")</code> to load trace.
</p>
</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-19" class="outline-2">
<h2 id="sec-19"><span class="section-number-2">19</span> Example Modules </h2>
<div class="outline-text-2" id="text-19">

<p>EuXLisp provides a few sample modules.
</p><ul>
<li id="sec-19.1">Trace <br/>
The trace module has been mentioned above.

</li>
<li id="sec-19.2">Linda <br/>
The eulinda module implements the Linda pool mechanism.
<ul>
<li>
<code>make-linda-pool</code> returns a new pool
</li>
<li>
<code>(linda-out pool tag val val ...)</code> writes the tuple <code>(val val ...)</code> under
the tag to the pool
</li>
<li>
<code>(linda-in pool tag pat pat ...)</code> attempts to read a tuple matching the
pattern <code>(pat pat ...)</code> from the pool.  If no matching tuple exists in the
pool, the call will block until such a tuple appears.  When found, the
tuple is removed from the pool.  A pattern is a literal value, to be
matched exactly <code>(? var)</code> to match any value, and assign the matched value
to the variable <code>?</code> to match any value, and to discard the result.
</li>
<li>
<code>linda-read</code> as <code>linda-in</code> but does not remove the tuple from the pool
</li>
<li>
<code>(linda-eval fun arg arg ...)</code> starts a new thread, running the function
with the arguments.

</li>
</ul>

<p>Debugging tools are <code>print-linda-pool</code> to print the curent values in a pool,
and <code>(tril t)</code> to print some trace information as the system is running.
</p>
<p>
The <code>tag</code> must be a <code>symbol</code> or <code>number</code>.
</p>
</li>
<li id="sec-19.3">Modular Numbers <br/>
The module <code>modular</code> is a simple implementation of modular integers.  The
function mod constructs a modular number



<pre class="src src-eulisp">(<span style="color: #0000ff; font-weight: bold;">setq</span> a <span style="color: #0000ff; font-weight: bold;">(mod</span> 3 5))  -&gt; #&lt;3 mod 5&gt;
(<span style="color: #0000ff; font-weight: bold;">setq</span> b <span style="color: #0000ff; font-weight: bold;">(+</span> a a))    -&gt; #&lt;1 mod 5&gt;
<span style="color: #0000ff; font-weight: bold;">(/</span> a)               -&gt; #&lt;2 mod 5&gt;
</pre>



</li>
<li id="sec-19.4">Scheme <br/>
This module provides a mostly-conformant Scheme environment.  It is probably
not wise to mix Scheme constructs, such as call/cc, with EuLisp constructs,
such as threads.

</li>
<li id="sec-19.5">Paralation Lisp <br/>
This emulates a paralation system.  The module <code>tpl</code> (for tiny paralation
lisp) exports
<ul>
<li>
<code>(make-paralation n)</code> to make a new paralation of size <code>n</code>.  This returns
a index field of the new paralation.
</li>
<li>
elwise is the element-wise operator:



<pre class="src src-eulisp">(<span style="color: #0000ff; font-weight: bold;">elwise</span> (<span style="color: #0000ff; font-weight: bold;">a</span> b) <span style="color: #0000ff; font-weight: bold;">(+</span> a b))
</pre>


<p>
where <code>a</code> and <code>b</code> are fields on the same paralation.
</p></li>
<li>
<code>(match field field)</code> to create a map between fields, and
</li>
<li>
<code>(move field map combine default)</code> to move a field down a map, using
combine, (a function taking an appropriate number of arguments) to combine
elements that end up at the same element of the target field, and default
as the default value for a field element that is not in the image of the
map.

</li>
</ul>
</li>
<li id="sec-19.6">Values <br/>
This is an emulation of Scheme and Common Lisp's multiple values.  The
module values exports
<ul>
<li>
<code>(values val val ...)</code> as the basic multiple value return
</li>
<li>
<code>call-with-values</code> for the Scheme-like values:



<pre class="src src-eulisp">(<span style="color: #0000ff; font-weight: bold;">call-with-values</span>
  (<span style="color: #0000ff; font-weight: bold;">lambda</span> () ...)             <span style="color: #ff00ff; font-weight: bold;">; </span><span style="color: #ff00ff;">a thunk returning values
</span>  (<span style="color: #0000ff; font-weight: bold;">lambda</span> (<span style="color: #0000ff; font-weight: bold;">a</span> b c ...) ...))   <span style="color: #ff00ff; font-weight: bold;">; </span><span style="color: #ff00ff;">that are passed here, bound
</span>                              <span style="color: #ff00ff; font-weight: bold;">; </span><span style="color: #ff00ff;">to a, b, etc.
</span></pre>


</li>
<li>
<code>multiple-value-setq</code>; <code>multiple-value-list</code>; <code>multiple-value-call</code>;
<code>values-list</code>; <code>multiple-value-bind</code> are all as in Common Lisp.

</li>
</ul>

<p>If you pass multiple values to a continuation that only expects a single
value you will probably get strange results.
</p>
</li>
<li id="sec-19.7">Sort <br/>
A fast stable merge sort.  The module sort exports <code>sort</code> (non-destructive)
and <code>sort!</code> (destructive).  They are called as <code>(sort l)</code>, where <code>l</code> is a
list of values to be sorted.  The comparison operator used is <code>&lt;</code>.
Alternatively, you can use <code>(sort l comp)</code>, where comp is a comparator
function.

</li>
</ul>
</div>

</div>

<div id="outline-container-20" class="outline-2">
<h2 id="sec-20"><span class="section-number-2">20</span> EuLisp functions </h2>
<div class="outline-text-2" id="text-20">

<p>Here is a summary of the functions available in EuLisp.
</p><ul>
<li id="sec-20.1">Special operators <br/>
<ul>
<li>
<code>deflocal</code>
</li>
<li>
<code>defconstant</code>
</li>
<li>
<code>defclass</code>
</li>
<li>
<code>defcondition</code>
</li>
<li>
<code>defmacro</code>
</li>
<li>
<code>defgeneric</code>
</li>
<li>
<code>defmethod</code>
</li>
<li>
<code>quote</code>
</li>
<li>
<code>lambda</code>
</li>
<li>
<code>let</code>
</li>
<li>
<code>let*</code>
</li>
<li>
<code>labels</code>
</li>
<li>
<code>setq</code>
</li>
<li>
<code>if</code>
</li>
<li>
<code>cond</code>
</li>
<li>
<code>when</code>
</li>
<li>
<code>unless</code>
</li>
<li>
<code>progn</code>
</li>
<li>
<code>while</code>
</li>
<li>
<code>and</code>
</li>
<li>
<code>or</code>
</li>
<li>
<code>call-next-method</code>
</li>
<li>
<code>next-method?</code>
</li>
<li>
<code>apply</code>
</li>
</ul>
</li>
<li id="sec-20.2">Module directives <br/>
<ul>
<li>
<code>export</code>
</li>
<li>
<code>expose</code>
</li>
</ul>
</li>
<li id="sec-20.3">List functions <br/>
<ul>
<li>
<code>cons</code>
</li>
<li>
<code>car</code>
</li>
<li>
<code>cdr</code>
</li>
<li>
<code>list</code>
</li>
</ul>
</li>
<li id="sec-20.4">Symbol functions <br/>
<ul>
<li>
<code>gensym</code>
</li>
</ul>
</li>
<li id="sec-20.5">Vector functions <br/>
<ul>
<li>
<code>vector</code>
</li>
</ul>
</li>
<li id="sec-20.6">Predicates <br/>
<ul>
<li>
<code>null?</code>
</li>
<li>
<code>atom?</code>
</li>
<li>
<code>number?</code>
</li>
<li>
<code>cons?</code>
</li>
<li>
<code>symbol?</code>
</li>
<li>
<code>keyword?</code>
</li>
<li>
<code>float?</code>
</li>
<li>
<code>double-float?</code>
</li>
<li>
<code>integer?</code>
</li>
<li>
<code>string?</code>
</li>
<li>
<code>vector?</code>
</li>
<li>
<code>stream?</code>
</li>
<li>
<code>eq</code>
</li>
<li>
<code>eql</code>
</li>
</ul>
</li>
<li id="sec-20.7">Arithmetic functions <br/>
<ul>
<li>
<code>zero?</code>
</li>
<li>
<code>positive?</code>
</li>
<li>
<code>negative?</code>
</li>
<li>
<code>odd?</code>
</li>
<li>
<code>even?</code>
</li>
<li>
<code>truncate</code>
</li>
<li>
<code>floor</code>
</li>
<li>
<code>ceiling</code>
</li>
<li>
<code>round</code>
</li>
<li>
<code>abs</code>
</li>
<li>
<code>gcd</code>
</li>
<li>
<code>lcm</code>
</li>
<li>
<code>+</code>
</li>
<li>
<code>-</code>
</li>
<li>
<code>*</code>
</li>
<li>
<code>/</code>
</li>
<li>
<code>min</code>
</li>
<li>
<code>max</code>
</li>
<li>
<code>sin</code>
</li>
<li>
<code>cos</code>
</li>
<li>
<code>tan</code>
</li>
<li>
<code>asin</code>
</li>
<li>
<code>acos</code>
</li>
<li>
<code>atan</code>
</li>
<li>
<code>exp</code>
</li>
<li>
<code>sqrt</code>
</li>
<li>
<code>pow</code>
</li>
<li>
<code>log</code>
</li>
<li>
<code>binary+</code>
</li>
<li>
<code>binary-</code>
</li>
<li>
<code>binary*</code>
</li>
<li>
<code>binary/</code>
</li>
<li>
<code>binary-gcd</code>
</li>
<li>
<code>binary%</code>
</li>
</ul>
</li>
<li id="sec-20.8">Numeric comparison functions <br/>
<ul>
<li>
<code>&lt;</code>
</li>
<li>
<code>&lt;=</code>
</li>
<li>
===
</li>
<li>
<code>&gt;=</code>
</li>
<li>
<code>&gt;</code>
</li>
</ul>
</li>
<li id="sec-20.9">I/O functions <br/>
<ul>
<li>
<code>read</code>
</li>
<li>
<code>swrite</code>
</li>
<li>
<code>write</code>
</li>
<li>
<code>sprin</code>
</li>
<li>
<code>prin</code>
</li>
<li>
<code>sprint</code>
</li>
<li>
<code>print</code>
</li>
<li>
<code>snewline</code>
</li>
<li>
<code>newline</code>
</li>
<li>
<code>sflush</code>
</li>
<li>
<code>flush</code>
</li>
</ul>
</li>
<li id="sec-20.10">Format <br/>
<ul>
<li>
<code>sformat</code>
</li>
<li>
<code>format</code>
</li>
<li>
<code>fmt</code>
</li>
</ul>
</li>
<li id="sec-20.11">File I/O functions <br/>
<ul>
<li>
<code>open-input-file</code>
</li>
<li>
<code>open-output-file</code>
</li>
</ul>
</li>
<li id="sec-20.12">Standard streams <br/>
<ul>
<li>
<code>stdin</code>
</li>
<li>
<code>stdout</code>
</li>
<li>
<code>stderr</code>
</li>
</ul>
</li>
<li id="sec-20.13">Plus some others <br/>
<ul>
<li>
<code>t</code>
</li>
<li>
<code>else</code>
</li>
<li>
<code>ticks-per-second</code>
</li>
</ul>
</li>
<li id="sec-20.14">Thread <br/>
<ul>
<li>
<code>&lt;thread&gt;</code>
</li>
<li>
<code>&lt;simple-thread&gt;</code>
</li>
<li>
<code>thread?</code>
</li>
<li>
<code>thread-reschedule</code>
</li>
<li>
<code>current-thread</code>
</li>
<li>
<code>current-thread</code>
</li>
<li>
<code>thread-start</code>
</li>
<li>
<code>thread-value</code>
</li>
<li>
<code>&lt;lock&gt;</code>
</li>
<li>
<code>lock?</code>
</li>
<li>
<code>lock</code>
</li>
<li>
<code>unlock</code>
</li>
<li>
<code>wait</code>
</li>
<li>
<code>let/cc</code>
</li>
<li>
<code>with-handler</code>
</li>
<li>
<code>unwind-protect</code>
</li>
<li>
<code>signal</code>
</li>
<li>
<code>error</code>
</li>
<li>
<code>cerror</code>
</li>
</ul>
</li>
<li id="sec-20.15">Telos <br/>
<ul>
<li>
<code>allocate</code>
</li>
<li>
<code>&lt;object&gt;</code>
</li>
<li>
<code>&lt;class&gt;</code>
</li>
<li>
<code>&lt;simple-class&gt;</code>
</li>
<li>
<code>&lt;list&gt;</code>
</li>
<li>
<code>&lt;cons&gt;</code>
</li>
<li>
<code>&lt;null&gt;</code>
</li>
<li>
<code>&lt;number&gt;</code>
</li>
<li>
<code>&lt;integer&gt;</code>
</li>
<li>
<code>&lt;fpi&gt;</code>
</li>
<li>
<code>&lt;float&gt;</code>
</li>
<li>
<code>&lt;double-float&gt;</code>
</li>
<li>
<code>&lt;symbol&gt;</code>
</li>
<li>
<code>&lt;keyword&gt;</code>
</li>
<li>
<code>&lt;string&gt;</code>
</li>
<li>
<code>&lt;stream&gt;</code>
</li>
<li>
<code>&lt;vector&gt;</code>
</li>
<li>
<code>&lt;table&gt;</code>
</li>
<li>
<code>&lt;hash-table&gt;</code>
</li>
<li>
<code>&lt;function&gt;</code>
</li>
<li>
<code>&lt;simple-function&gt;</code>
</li>
<li>
<code>&lt;method&gt;</code>
</li>
<li>
<code>&lt;simple-method&gt;</code>
</li>
<li>
<code>&lt;slot&gt;</code>
</li>
<li>
<code>&lt;local-slot&gt;</code>
</li>
<li>
<code>generic-prin</code>
</li>
<li>
<code>generic-write</code>
</li>
<li>
<code>wait</code>
</li>
<li>
<code>make</code>
</li>
<li>
<code>initialize</code>
</li>
</ul>
</li>
<li id="sec-20.16">Setter <br/>
<ul>
<li>
<code>setter</code>
</li>
</ul>
</li>
<li id="sec-20.17">Converter <br/>
<ul>
<li>
<code>converter</code>
</li>
<li>
<code>convert</code>
</li>
</ul>
</li>
<li id="sec-20.18">Condition <br/>
<ul>
<li>
<code>condition?</code>
</li>
<li>
<code>&lt;condition&gt;</code>
</li>
</ul>
</li>
<li id="sec-20.19">Compare <br/>
<ul>
<li>
<code>binary&lt;</code>
</li>
<li>
<code>binary=</code>
</li>
<li>
<code>&lt;</code>
</li>
<li>
===
</li>
<li>
<code>&gt;</code>
</li>
<li>
<code>&lt;=</code>
</li>
<li>
<code>&gt;=</code>
</li>
<li>
<code>max</code>
</li>
<li>
<code>min</code>
</li>
</ul>
</li>
<li id="sec-20.20">Macros <br/>
<ul>
<li>
<code>quasiquote</code>
</li>
<li>
<code>unquote</code>
</li>
<li>
<code>unquote-splicing</code>
</li>
</ul>
</li>
<li id="sec-20.21">Collect <br/>
<ul>
<li>
<code>collection?</code>
</li>
<li>
<code>sequence?</code>
</li>
<li>
<code>accumulate</code>
</li>
<li>
<code>accumulate1</code>
</li>
<li>
<code>all?</code>
</li>
<li>
<code>any?</code>
</li>
<li>
<code>concatenate</code>
</li>
<li>
<code>delete</code>
</li>
<li>
<code>do</code>
</li>
<li>
<code>element</code>
</li>
<li>
<code>empty?</code>
</li>
<li>
<code>fill</code>
</li>
<li>
<code>map</code>
</li>
<li>
<code>member</code>
</li>
<li>
<code>remove</code>
</li>
<li>
<code>reverse</code>
</li>
<li>
<code>size</code>
</li>
<li>
<code>slice</code>
</li>
</ul>
</li>
<li id="sec-20.22">Copy <br/>
<ul>
<li>
<code>deep-copy</code>
</li>
<li>
<code>shallow-copy</code>

</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-21" class="outline-2">
<h2 id="sec-21"><span class="section-number-2">21</span> EuXLisp functions </h2>
<div class="outline-text-2" id="text-21">

<p>Here is a summary of the additional functions available in EuXLisp.  Those
marked '*' are also in Youtoo.
</p><ul>
<li id="sec-21.1">Special operators <br/>
<ul>
<li>
<code>delay</code>
</li>
<li>
<code>map-list</code>
</li>
<li>
<code>load</code>
</li>
<li>
<code>load-noisily</code>
</li>
<li>
<code>force</code>
</li>
</ul>
</li>
<li id="sec-21.2">List functions <br/>
<ul>
<li>
<code>caar</code> *
</li>
<li>
<code>cadr</code> *
</li>
<li>
<code>cdar</code> *
</li>
<li>
<code>cddr</code> *
</li>
<li>
<code>caaar</code> *
</li>
<li>
<code>caadr</code> *
</li>
<li>
<code>cadar</code> *
</li>
<li>
<code>caddr</code> *
</li>
<li>
<code>cdaar</code> *
</li>
<li>
<code>cdadr</code> *
</li>
<li>
<code>cddar</code> *
</li>
<li>
<code>cdddr</code> *
</li>
<li>
<code>caaaar</code>
</li>
<li>
<code>caaadr</code>
</li>
<li>
<code>caadar</code>
</li>
<li>
<code>caaddr</code>
</li>
<li>
<code>cadaar</code>
</li>
<li>
<code>cadadr</code>
</li>
<li>
<code>caddar</code>
</li>
<li>
<code>cadddr</code> *
</li>
<li>
<code>cdaaar</code>
</li>
<li>
<code>cdaadr</code>
</li>
<li>
<code>cdadar</code>
</li>
<li>
<code>cdaddr</code>
</li>
<li>
<code>cddaar</code>
</li>
<li>
<code>cddadr</code>
</li>
<li>
<code>cdddar</code>
</li>
<li>
<code>cddddr</code>
</li>
<li>
<code>list*</code>
</li>
<li>
<code>append</code> *
</li>
<li>
<code>last-pair</code>
</li>
<li>
<code>length</code> *
</li>
<li>
<code>memv</code>
</li>
<li>
<code>memq</code>
</li>
<li>
<code>assv</code>
</li>
<li>
<code>assq</code>
</li>
<li>
<code>list-ref</code> *
</li>
<li>
<code>list-tail</code>
</li>
</ul>
</li>
<li id="sec-21.3">Symbol functions <br/>
<ul>
<li>
<code>bound?</code>
</li>
<li>
<code>symbol-value</code>
</li>
<li>
<code>symbol-plist</code>
</li>
<li>
<code>get</code>
</li>
<li>
<code>put</code>
</li>
</ul>
</li>
<li id="sec-21.4">Vector functions <br/>
<ul>
<li>
<code>make-vector</code> *
</li>
<li>
<code>vector-length</code>
</li>
<li>
<code>vector-ref</code> *
</li>
</ul>
</li>
<li id="sec-21.5">Predicates <br/>
<ul>
<li>
<code>list?</code> *
</li>
<li>
<code>boolean?</code>
</li>
<li>
<code>complex?</code>
</li>
<li>
<code>rational?</code>
</li>
<li>
<code>char?</code>
</li>
<li>
<code>function?</code> *
</li>
<li>
<code>input-stream?</code>
</li>
<li>
<code>output-stream?</code>
</li>
<li>
<code>object?</code> *
</li>
<li>
<code>eof-object?</code>
</li>
<li>
<code>default-object?</code>
</li>
</ul>
</li>
<li id="sec-21.6">Arithmetic functions <br/>
<ul>
<li>
<code>exact?</code>
</li>
<li>
<code>inexact?</code>
</li>
<li>
<code>random</code> *
</li>
<li>
<code>quotient</code>
</li>
<li>
<code>remainder</code>
</li>
<li>
<code>unary-</code>
</li>
<li>
<code>unary/</code>
</li>
</ul>
</li>
<li id="sec-21.7">Bitwise logical functions <br/>
<ul>
<li>
<code>logand</code>
</li>
<li>
<code>logior</code>
</li>
<li>
<code>logxor</code>
</li>
<li>
<code>lognot</code>
</li>
</ul>
</li>
<li id="sec-21.8">String functions <br/>
<ul>
<li>
<code>make-string</code>
</li>
<li>
<code>string-length</code>
</li>
<li>
<code>string-null?</code>
</li>
<li>
<code>string-append</code>
</li>
<li>
<code>string-ref</code>
</li>
<li>
<code>substring</code>
</li>
</ul>
</li>
<li id="sec-21.9">I/O functions <br/>
<ul>
<li>
<code>read-char</code> *
</li>
<li>
<code>read-byte</code>
</li>
<li>
<code>read-short</code>
</li>
<li>
<code>read-long</code>
</li>
<li>
<code>write-char</code>
</li>
<li>
<code>write-byte</code>
</li>
<li>
<code>write-short</code>
</li>
<li>
<code>write-long</code>
</li>
<li>
<code>char-ready?</code>
</li>
<li>
<code>peek-char</code>
</li>
</ul>
</li>
<li id="sec-21.10">Print control functions <br/>
<ul>
<li>
<code>print-breadth</code>
</li>
<li>
<code>print-depth</code>
</li>
</ul>
</li>
<li id="sec-21.11">File I/O functions <br/>
<ul>
<li>
<code>open-input-file</code>
</li>
<li>
<code>open-output-file</code>
</li>
<li>
<code>open-append-file</code>
</li>
<li>
<code>open-update-file</code>
</li>
<li>
<code>close-stream</code>
</li>
<li>
<code>close-input-stream</code>
</li>
<li>
<code>close-output-stream</code>
</li>
<li>
<code>get-file-position</code>
</li>
<li>
<code>unlink</code>
</li>
</ul>
</li>
<li id="sec-21.12">utility functions <br/>
<ul>
<li>
<code>transcript-on</code>
</li>
<li>
<code>transcript-off</code>
</li>
<li>
<code>getarg</code>
</li>
<li>
<code>prompt?</code>
</li>
<li>
<code>exit</code> *
</li>
<li>
<code>compile</code> *
</li>
<li>
<code>decompile</code>
</li>
<li>
<code>gc</code>
</li>
<li>
<code>save</code>
</li>
<li>
<code>restore</code>
</li>
</ul>
</li>
<li id="sec-21.13">Debugging functions <br/>
<ul>
<li>
<code>trace-on</code>
</li>
<li>
<code>trace-off</code>
</li>
</ul>
</li>
<li id="sec-21.14">Module functions <br/>
<ul>
<li>
<code>enter-module</code>
</li>
<li>
<code>!&gt;</code>
</li>
<li>
<code>reenter-module</code>
</li>
<li>
<code>!&gt;&gt;</code>
</li>
<li>
<code>module-symbols</code>
</li>
<li>
<code>module-exports</code>
</li>
<li>
<code>symbol-module</code>
</li>
<li>
<code>current-module</code>
</li>
<li>
<code>module-list</code>
</li>
<li>
<code>unintern</code>
</li>
</ul>
</li>
<li id="sec-21.15">Tables <br/>
<ul>
<li>
<code>make-table</code>
</li>
<li>
<code>table-ref</code> *
</li>
<li>
<code>table-comparator</code> *
</li>
<li>
<code>table-delete</code>
</li>
<li>
<code>table-length</code>
</li>
<li>
<code>table-keys</code> *
</li>
<li>
<code>table-values</code> *
</li>
<li>
<code>table-fill</code>
</li>
<li>
<code>table-clear</code>
</li>
</ul>
</li>
<li id="sec-21.16">Plus some others <br/>
<ul>
<li>
<code>binary</code>
</li>
<li>
<code>text</code>
</li>
<li>
<code>not</code> *
</li>
<li>
<code>prin1</code>
</li>
<li>
<code>princ</code>
</li>
<li>
<code>eval</code>
</li>
<li>
<code>system</code> *
</li>
<li>
<code>getenv</code> *
</li>
<li>
<code>putenv</code>
</li>
<li>
<code>tmpfile</code>
</li>
<li>
<code>current-time</code>
</li>
<li>
<code>backtrace</code> *
</li>
<li>
<code>backtrace?</code>
</li>
</ul>
</li>
<li id="sec-21.17">Thread <br/>
<ul>
<li>
<code>make-thread</code>
</li>
<li>
<code>thread-kill</code>
</li>
<li>
<code>thread-queue</code>
</li>
<li>
<code>thread-state</code>
</li>
<li>
<code>&lt;thread-condition&gt;</code>
</li>
<li>
<code>&lt;thread-error&gt;</code>
</li>
<li>
<code>&lt;thread-already-started&gt;</code>
</li>
<li>
<code>&lt;simple-lock&gt;</code>
</li>
<li>
<code>make-lock</code>
</li>
<li>
<code>&lt;lock-condition&gt;</code>
</li>
<li>
<code>&lt;lock-error&gt;</code>
</li>
<li>
<code>&lt;wait-condition&gt;</code>
</li>
<li>
<code>&lt;wait-error&gt;</code>
</li>
<li>
<code>&lt;wrong-condition-class&gt;</code>
</li>
</ul>
</li>
<li id="sec-21.18">Telos <br/>
<ul>
<li>
<code>&lt;simple-string&gt;</code>
</li>
<li>
<code>&lt;input-stream&gt;</code>
</li>
<li>
<code>&lt;output-stream&gt;</code>
</li>
<li>
<code>&lt;i/o-stream&gt;</code>
</li>
<li>
<code>&lt;simple-vector&gt;</code>
</li>
<li>
<code>&lt;char&gt;</code>
</li>
<li>
<code>&lt;simple-char&gt;</code>
</li>
<li>
<code>&lt;promise&gt;</code>
</li>
<li>
<code>&lt;subr&gt;</code>
</li>
<li>
<code>&lt;continuation&gt;</code>
</li>
<li>
<code>&lt;generic&gt;</code>
</li>
<li>
<code>&lt;simple-generic&gt;</code>
</li>
<li>
<code>&lt;structure&gt;</code>
</li>
<li>
<code>class-hierarchy</code>
</li>
<li>
<code>describe</code>
</li>
<li>
<code>class?</code> *
</li>
<li>
<code>subclass?</code> *
</li>
</ul>
</li>
<li id="sec-21.19">Converter <br/>
<ul>
<li>
<code>&lt;conversion-condition&gt;</code>
</li>
<li>
<code>&lt;no-converter&gt;</code>
</li>
</ul>
</li>
<li id="sec-21.20">Condition <br/>
<ul>
<li>
<code>condition-message</code> *
</li>
<li>
<code>condition-value</code>
</li>
<li>
<code>&lt;telos-condition&gt;</code>
</li>
<li>
<code>&lt;telos-error&gt;</code>
</li>
<li>
<code>&lt;telos-general-error&gt;</code>
</li>
<li>
<code>&lt;telos-bad-ref&gt;</code>
</li>
<li>
<code>&lt;no-applicable-method&gt;</code>
</li>
<li>
<code>&lt;no-next-method&gt;</code>
</li>
<li>
<code>&lt;incompatible-method-domain&gt;</code>
</li>
<li>
<code>&lt;arithmetic-condition&gt;</code>
</li>
<li>
<code>&lt;arithmetic-error&gt;</code>
</li>
<li>
<code>&lt;error&gt;</code>
</li>
<li>
<code>&lt;general-error&gt;</code>
</li>
<li>
<code>&lt;bad-type&gt;</code>
</li>
<li>
<code>&lt;unbound-error&gt;</code>
</li>
<li>
<code>&lt;compilation-error&gt;</code>
</li>
<li>
<code>&lt;macro-error&gt;</code>
</li>
<li>
<code>&lt;syntax-error&gt;</code>
</li>
<li>
<code>&lt;user-interrupt&gt;</code>
</li>
</ul>
</li>
<li id="sec-21.21">Compare <br/>
<ul>
<li>
<code>assoc</code>
</li>
</ul>
</li>
<li id="sec-21.22">Macros <br/>
<ul>
<li>
<code>symbol-macro</code>
</li>
<li>
<code>macroexpand</code>
</li>
<li>
<code>macroexpand1</code>
</li>
</ul>
</li>
<li id="sec-21.23">Collect <br/>
<ul>
<li>
<code>&lt;collection-condition&gt;</code>
</li>
<li>
<code>&lt;collection-error&gt;</code>

</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-22" class="outline-2">
<h2 id="sec-22"><span class="section-number-2">22</span> Command Line Arguments </h2>
<div class="outline-text-2" id="text-22">

<ul>
<li id="sec-22.1">EuXLisp <br/>
<ul>
<li>
<code>-h</code>, <code>--help</code> Display this usage information.
</li>
<li>
<code>-q</code>, <code>--quiet</code> Print no messages, prompts or values.
</li>
<li>
<code>-n</code>, <code>--no-image</code> Do not read in the initial Lisp image.
</li>
<li>
<code>-N</code>, <code>--no-sys-calls</code> Disable system calls.
</li>
<li>
<code>-s</code> <i>file</i>, <code>--script</code> <i>file</i> Read and execute script from <i>file</i>, see
below.
</li>
<li>
<code>-m</code> <i>file</i>,  <code>--module</code> <i>file</i> Read and execute module from <i>file</i>.
</li>
<li>
<code>-i</code> <i>file</i>, <code>--image</code> <i>file</i> Read the given image <i>file</i> rather than the
default.
</li>
<li>
<code>-t</code>, <code>--trace</code>            Switch on byte-code level tracing.

</li>
</ul>

<p>Other arguments are passed to the intepreter and are available as <code>(getarg     0)</code> (the name of the program), <code>(getarg 1)</code> (first argument), <code>(getarg 2)</code>
(second argument), and so on.  The function <code>getarg</code> returns <code>()</code> for a
non-existent argument.
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-23" class="outline-2">
<h2 id="sec-23"><span class="section-number-2">23</span> Shell Scripts </h2>
<div class="outline-text-2" id="text-23">

<ul>
<li id="sec-23.1">EuXLisp <br/>
can be used in a shell script by means of the <code>--script</code> flag:



<pre class="src src-eulisp">#!&lt;absolute path&gt;/euxlisp --script

<span style="color: #0000ff; font-weight: bold;">(print</span> <span style="color: #00ff00;">"hello world"</span>)
</pre>


<p>
It is usual to use the <code>-q</code> or <code>--quiet</code> flag to prevent the echo from the
read-eval-print loop (the default), and the <code>-N</code> or <code>--no-sys-calls</code> flag to
prevent the use of the system function.
</p>


<pre class="src src-eulisp">#!/usr/local/bin/euxlisp -qN --script

<span style="color: #0000ff; font-weight: bold;">(print</span> <span style="color: #00ff00;">"hello world"</span>)
</pre>



</li>
<li id="sec-23.2">Youtoo <br/>
can also be used in a shell script by means of the <code>--script</code> flag:



<pre class="src src-eulisp">#!&lt;absolute path&gt;/youtoo --script

<span style="color: #0000ff; font-weight: bold;">(print</span> <span style="color: #00ff00;">"hello world"</span>)
</pre>


<p>
See <i>Examples/Misc/script.em</i>.
</p></li>
</ul>
</div>
</div>
<div id="postamble">
<p class="author"> Author: of original Euscheme notes Russell Bradford
<a href="mailto:no-reply">&lt;no-reply&gt;</a>
</p>
<p class="date"> Date: 2010-07-01 22:08:44 BST</p>
<p class="creator">HTML generated by org-mode 6.34trans in emacs 23</p>
</div>
</div>
</body>
</html>
