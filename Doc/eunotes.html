<html>
<head>
<title>Euscheme Starter Notes</title>

<style><!--
h2, h3, h4 {
  color: #aa0000;
}

pre, tt {
  color: #004400;
}
//-->
</style>

</head>

<body bgcolor="#cdcd00">
<center>
<h2>Using Euscheme</h2><p>
<a href="http://www.bath.ac.uk/~masrjb">Russell Bradford</a>
</center><p><p>

<h3>0. Introduction</h3><p>

<a href="http://www.bath.ac.uk/~masrjb/Sources/euscheme.html">Euscheme</a>
is a simple
<a href="http://www.bath.ac.uk/~masjap/eulisp.html">EuLisp</a> Level 0
interpreter, and is used as the language for
several of the assignments in final year courses. EuLisp Level 0 is a small and
compact Lisp, but nevertheless has many interesting features, such as modules,
an object system, and multithreading.  EuLisp Level 1 has extra features, the
most notable being a full metaobject system.

These are a few notes on the use of Euscheme. We assume you are already
familiar with Lisp, so we concentrate on those things unique to Eulisp.<p>

There is a basic "teach yourself Lisp"
<A href="http://www.bath.ac.uk/~masjap/TYL">course</a>, you might like to look
at: it even contains a few self assessment exercises.<p>

<h3>1. Running Euscheme</h3><p>

Just type
<tt>euscheme</tt>
and that will do it. You get something like
<pre>EuScheme - Version 0.30s

user>
</pre>
where the final line is the prompt. Euscheme uses the usual read-eval-print
cycle of interactive Lisps: type something, it will be evaluated, and the
result printed.

To exit, use
<pre>(exit)
</pre>
and (<a href="#ctrld">usually</a>) 
<tt>^D</tt>
will work, too.<p>

<h3>2. Constants</h3><p>
There are the usual self-evaluating bits and pieces:
<ul>
<li> strings: in double quotes 
<tt>"hello"</tt>
<li> numbers: integers and floating point 
<tt>1234</tt>
and 
<tt>3.1415</tt>
<li> characters: preceded by 
<tt>#\</tt>
as in
<tt>#\c</tt>
for the character 'c'
<li> vectors: delimited by 
<tt>#(</tt>
and
<tt>)</tt>
as in 
<tt>#(1 a (3))</tt>
which is a vector of length 3, containing an integer, a
symbol, and a list.
</ul>

<h3>3. Lists and Vectors</h3><p>
Lists are created with the usual 
<tt>cons</tt>,
<tt>list</tt>
and quoted forms 
<tt>'(1 2 3)</tt>.
Use 
<tt>car</tt>
and 
<tt>cdr</tt>
to access the elements.<p>

A vector is created by the function 
<tt>make-vector</tt>
as in
<pre>(make-vector 4)
</pre>
which creates a vector of length 4, indexed from 0 to 3, all elements
initialised to be 
<tt>()</tt>s.
In fact,
<tt>make-vector</tt>
can take a second argument
<pre>(make-vector 4 0)
</pre>
which creates a vector as before, with all elements initialised to 0.<p>

To access a vector element use 
<tt>(vector-ref vec index)</tt>;
to update use 
<tt>((setter vector-ref) vec index newval)</tt>.
See <a href="#setter">below</a> for details about the 
<tt>setter</tt>
function.<p>

Take care with the creation of vectors: 
<tt>(make-vector 3 #(0 0 0))</tt>
will create a vector of three slots, all initialised to the <em>same</em>
(<tt>eq</tt>)
value.<p>

<h3>4. Expressions</h3><p>
As is usual, anything that is not a constant is an expression to be evaluated,
and those things marked by a quote are deemed to be constant.  Thus
<pre>(+ 1 2)
</pre>
is an expression to be evaluated, while
<pre>'(+ 1 2)
</pre>
is a constant list of 3 elements (modifying constant lists has an undefined
effect, so it's best not to do so).

EuLisp has both 
<tt>progn</tt>
to collect together several expressions into a single expression, and 
<tt>let</tt>
for the declaration of local variables.
<pre>(progn
  expr
  expr
  ...
)
</pre>
and
<pre>(let ((var val)
      (var val)
      ...)
  expr
  expr
  ...
)
</pre>
(Semantics: evaluate all the 
<tt>val</tt>s
first, then make the bindings to the corresponding 
<tt>val</tt>s.
Thus the
<tt>val</tt>s
cannot refer to the 
<tt>var</tt>s.
Use 
<tt>let*</tt>
<pre>(let* ((var1 val1)
       (var2 val2)
       ...)
  ...)
</pre>
with semantics of evaluate 
<tt>val1</tt>,
bind to
<tt>var1</tt>,
evaluate 
<tt>val2</tt>,
bind to 
<tt>var2</tt>,
etc., if you need to refer back to previous values.)<p>

The values of these expressions are the values of their last
<tt>expr</tt>s. Named
<tt>let</tt>s and
<tt>let*</tt>s are also supported.
<p>

Numbers have the usual syntaxes:
<tt>123</tt>,
<tt>1.23</tt> and
<tt>1.2e4</tt>.  Additionally, you can enter
integers in base 2:
<tt>#b101010</tt>,
base 8:
<tt>#o7654</tt>,
base 16:
<tt>#x12ab</tt>,
and any other base up to 36:
<tt>#23r12gd</tt> for a base 23 integer.<p>

The full syntax of symbols is somewhat tricky, but "alphanumerics, starting
with a letter" is certainly OK.  Dodgy characters, such as space, or a leading
digit can be escaped with a
<tt>\</tt>.  A multiple character escape is
introduced and ended by
<tt>|</tt>.  Within the confines of these
delimeters any character is fine, except that
<tt>\|</tt>
is interpreted as a literal 
<tt>|</tt>,
and
<tt>\\</tt>
as a literal
<tt>\</tt>.<p>

All the following are the same symbol:
<pre>\1\ 23
|1 |23
|1 23|
|1 |2|3|
|1 |2\3
\1| |2||3
</pre>
Their canonical form is
<tt>|1 23|</tt>.

<h3>5. Conditionals</h3><p>
EuLisp has the usual 
<tt>(if boolexpr trueexpr falseexpr)</tt>
(always with both 
<tt>trueexpr</tt>
and 
<tt>falseexpr</tt>), and the 
<tt>cond</tt>
form.  The single false value in EuLisp is 
<tt>()</tt>:
anything else is deemed to be true.  The symbol
<tt>nil</tt>
is bound to 
<tt>()</tt>,
while 
<tt>t</tt>
is bound to the symbol 
<tt>t</tt>,
providing a convenient canonical true value.

Additional conditional forms include
<pre>(when boolexpr
   expr
   expr
   ...
)
</pre>
where the 
<tt>expr</tt>s
are evaluated when the condition is true; and
<pre>(unless boolexpr
   expr
   expr
   ...
)
</pre>
where the 
<tt>expr</tt>s
are evaluated when the
condition is false.<p>

<h3>6. Assignment</h3><p>
You've got 
<tt>setq</tt>.
It's also good to define your global variables
<pre>(deflocal foo 2)
</pre>
somewhere, too. You can omit the initial value if you want.  The
<tt>deflocal</tt>
form should only be used at the top level (i.e., never inside a function
definition or a
<tt>let</tt>).<p>

<h3>7. Defining Functions</h3><p>
Here we use 
<tt>defun</tt>.
<pre>(defun len (l)
  (if (null l)
      0
      (+ 1 (len (cdr l)))))
</pre>

EuLisp is fully tail-recursive, so a function written in a tail-recursive way
uses no stack:
<pre>(defun foo (n)
  (print n)
  (foo (+ n 1)))
</pre>
will run forever.<p>

Variable arity functions are available, too:
<pre>(defun bar (a b . c)
  (list a b c))
</pre>
can take 2 or more arguments.  The first two arguments are bounds to 
<tt>a</tt>
and 
<tt>b</tt>
as usual, the rest are made into a list which is bound to
<tt>c</tt>.
Thus 
<tt>(bar 1 2 3 4 5)</tt>
prints 
<tt>(1 2 (3 4 5))</tt>,
and
<tt>(bar 99 100)</tt>
prints 
<tt>(99 100 ())</tt><p>

<h3>8. Arithmetic</h3><p>
All the usual stuff here. Functions 
<tt>+</tt>,
<tt>-</tt>,
<tt>*</tt>
and 
<tt>/</tt>,
<tt>abs</tt>,
<tt>sin</tt>,
<tt>exp</tt>
and so on. Use
<tt>(pow a b)</tt>
to raise 
<tt>a</tt>
to power 
<tt>b</tt>.
Additionally, the basic arithmetic ops have variable arity:
<pre>(+)         -> 0
(+ 1)       -> 1
(+ 1 2)     -> 3
(+ 1 2 3)   -> 6
(- 1)       -> -1
(* 1 2 3 4) -> 24
</pre>
and so on.<p>

<h3>9. Modules</h3><p>
Now for something a little different.  The basic unit of a program in EuLisp is
the <em>module</em>.  Modules provide a way of fixing the global namespace
pollution problem: each module has its very own namespace.  A module can
import names from other modules, and can export names too.<p>

Here is a simple module:
<pre>(defmodule one
  (import (level0))

  (defun foo ...)
  (defun bar ...)
  (deflocal baz ...)
  ...

  (export foo baz)
)
</pre>
The module 
<tt>one</tt>
<em>import</em>s from the system module named
<tt>level0</tt>.
This module contains all the useful stuff like 
<tt>cons</tt>,
<tt>car</tt>,
<tt>defun</tt>,
<tt>+</tt>
and so on.  In fact, it's generally a good idea to import the 
<tt>level0</tt>
module, otherwise you can't actually do anything.<p>

In module 
<tt>one</tt>
we define a few name, like
<tt>foo</tt>,
<tt>bar</tt>
and 
<tt>baz</tt>,
and <em>export</em> 
<tt>foo</tt>
and 
<tt>baz</tt>.
Now any module that imports 
<tt>one</tt>
can access
<tt>foo</tt>
and 
<tt>baz</tt>,
but 
<tt>bar</tt>
is completely hidden from everyone.<p>

If now, we have
<pre>(defmodule two
  (import (level0 one))

  ...
)
</pre>
the module 
<tt>two</tt>
imports 
<tt>one</tt>
(and 
<tt>level0</tt>), so
<tt>two</tt>
can refer to 
<tt>foo</tt>
and 
<tt>baz</tt>
from 
<tt>one</tt>.
If 
<tt>two</tt>
uses a name 
<tt>bar</tt>,
it is its own 
<tt>bar</tt>,
and has nothing to do with the 
<tt>bar</tt>
in
<tt>one</tt>.<p>

<h4>Modules in Euscheme</h4>
Euscheme requires each module to be in a file of its own: thus 
<tt>one</tt>
should be in a file named 
<tt>one.em</tt>
(for <em>E</em>uLisp <em>m</em>odule), and 
<tt>two</tt>
in 
<tt>two.em</tt>.

To enter a module, use
<pre>(!> one)
</pre>
which will load 
<tt>one</tt>
if it is not already loaded, and will set the current module to be 
<tt>one</tt>.
This is indicated by the prompt
<pre>user> (!> one)
&lt;reading one.em>
&lt;read one.em>
&lt;one...done>
#t
one>
</pre>
Now the read-eval-print loop acts on bindings in the 
<tt>one</tt>
module. Use 
<tt>(!> user)</tt>
to switch back to the original module.<p>

To re-load a module (after, say, changing the file) use 
<tt>(!>> one)</tt>.<p>

<h3>10. Errors and the Debug Loop</h3><p>
When you make an error, EuLisp will call an <em>error handler</em>.  The full
use of error handlers is too tricky for an introductory set of notes, so we
shall rely on the default (built-in) handler.  In Euscheme an error
puts the system into a simple debugging loop:
<pre>user> qwerty
Continuable error---calling default handler:
Condition class is #&lt;class unbound-error>
message:        "variable unbound in module 'user'"
value:          qwerty

Debug loop.  Type help: for help
Broken at #&lt;Code #1008a768>

DEBUG>
</pre>
There is a lot of information here, and you should look carefully at what
Euscheme is telling you.<p>

In this case, the call of error is an 'unbound-error', i.e., reference to an
undefined variable. The 
<tt>message</tt>
gives an English description of the error, while the 
<tt>value</tt>
fills in some details, so it is the variable named 
<tt>qwerty</tt>
that is at fault.<p>

Another error:
<pre>user> (car 5)
Continuable error---calling default handler:
Condition class is #&lt;class bad-type>
message:        "incorrect type in car"
value:          5
expected-type:  #&lt;class cons>

Debug loop.  Type help: for help
Broken at #&lt;Code #100820a8>

DEBUG>
</pre>
This is a 'bad-type' error, where the function 
<tt>car</tt>
was expecting a different type of argument; it got a 
<tt>5</tt>,
where it was expecting something of class 
<tt>cons</tt>,
i.e., some sort of list.<p>

The prompt becomes 
<tt>DEBUG></tt>
to indicate we are in the debug loop. In this loop things act as normal, except
we have some additional functions to play with. Type 
<tt>help:</tt>
to get
<pre>Debug loop.
top:                                return to top level
resume:  or  (resume: val)          resume from error
bt:                                 backtrace
locals:                             local variables
cond:                               current condition
up:  or  (up: n)                    up one or n frames
down:  or  (down: n)                down one or n frames
where:                              current function
</pre>
The most useful of these is 
<tt>top:</tt>,
which
clears up the error and returns us to the top-level read-eval-print loop; and 
<tt>bt:</tt>
which gives us a backtrace, i.e., a list of the function calls and their
arguments that took us to where we are now.  (Note that, as EuLisp is tail
recursive, Euscheme does not save all the return addresses of the functions
that it travels through, so the backtrace may omit certain intermediate
function calls.)<p>

In a debug loop <a name="ctrld"></a>
<tt>^D</tt>
will act as 
<tt>resume:</tt>,
which is to try to carry on from the point of error.  Debug loops can be
nested.<p>

<h3>11. Classes and Generic Functions</h3><p>
EuLisp has a full object system. At Level 0, it is a simple, non-reflective
system, comparable to C++'s class system.

Every object in EuLisp has a class, which is itself a first-class object:
this means that classes are supported at the same level as any other object in
the system, and can be created, passed to functions, returned from functions,
and so on.  For example, the integer 
<tt>1</tt>
has class 
<tt>&lt;integer></tt>
(or rather, has a class with <em>name</em> 
<tt>&lt;integer></tt>).<p>

In fact, Euscheme has 
<tt>(class-of 1)</tt>
to be
<tt>&lt;fpi></tt>
(for
<em>f</em>ixed <em>p</em>oint <em>i</em>nteger), which is a subclass of
<tt>&lt;integer></tt>.<p>

Classes are fully-fledged objects, so they have a class, too
<pre>(class-of &lt;integer>) -> #&lt;class class>
</pre>
the print representation of the class 
<tt>&lt;class></tt>.
Finally,
<tt>(class-of &lt;class>)</tt>
is 
<tt> &lt;class></tt>
itself, or else we would need an infinite tower of classes.<p>

To make an instance of a class, use 
<tt>make</tt>
<pre>(make &lt;cons> car: 1 cdr: 2) -> (1 . 2)
</pre>
The keywords (symbols whose names end with colons) indicate how to fill in the
various slots of the instance of the class. The keywords can be in any order,
and can be omitted if not necessary: though some classes have slots with
<em>required</em> keywords.  This means that instances of such classes
<em>must</em> have certain information passed to 
<tt>make</tt>
in order to succeed.

Some classes are <em>abstract</em>, and you cannot make instances of them.
They are there purely for other classes to inherit from. The class
<tt>&lt;list></tt>
is abstract, while its subclass
<tt>&lt;cons></tt>
is
<em>concrete</em>.<p>

It is simple to create new classes by the use of 
<tt>defclass</tt>.
<pre>(defclass &lt;rat> ()
   ((num keyword: num:
         default: 0
         accessor: num)
    (den keyword: den:
         default: 1
         accessor: den))
    predicate: rat?
    constructor: (rat num: den:))
</pre>
There are many parts to explain.<p>

This form defines a new class named 
<tt>&lt;rat></tt>.
Classes in EuLisp are conventionally noted by the use of angle brackets 
<tt>&lt;></tt>,
but they are just normal names. The 
<tt>()</tt>
next is the list of classes for

<tt>&lt;rat></tt>
to inherit from.  In EuLisp Level 0, there is only single inheritance, so this
should be a list of at most one class.  Any empty list indicates some suitable
default superclass.<p>

Next is a list of <em>slot descriptions</em>.  Each has a slot name first, then
a list of <em>slot options</em>. The slot options are identified by keywords
which can come in any order, and can be omitted it you don't want them.<p>

The slot options are
<ul>
<li> 
<tt>keyword:</tt>
a keyword to use in a
<tt>make</tt>
of the class instance.
<li> 
<tt>default:</tt>
a default value to put in the slot if a value is not passed via the keyword.
<li> 
<tt>accessor:</tt>
a name that will be bound to functions to read and write the slot.  In the
above example,
<tt>num</tt>
will name a function to read the 
<tt>num</tt>
slot in an instance of
<tt>&lt;rat></tt>.
Similarly,
<tt>(setter num)</tt>
will be a function to write
to such a slot. See
<a href="#setter">setters</a>.
<li> 
<tt>reader:</tt>
a name for a slot reader.
<li> 
<tt>writer:</tt>
a name for a slot writer.
<li> 
<tt>requiredp:</tt>
use 
<tt>requiredp: t</tt>
to indicate a required slot. This slot must have a 
<tt>keyword:</tt>
keyword!
</ul>
The 
<tt>accessor:</tt>,
<tt>reader:</tt>
and 
<tt>writer:</tt>
options can be repeated as many times as you wish with different names.<p>

Next come the class options. Again, in any order or omitted.
<ul>
<li> 
<tt>predicate:</tt>
a symbol to name a function that will return true on an instance of the class,
and false on all other objects.
<li> 
<tt>constructor:</tt>
a way to name a function to make an instance of the class.  In this case, 
<tt>rat</tt>
will name a function of two arguments that makes an instance of 
<tt>&lt;rat></tt>.
The first argument will be given to the
<tt>num:</tt>
keyword, the second to the
<tt>den:</tt>.
This is equivalent to defining
<pre>(defun rat (n d)
  (make &lt;rat> num: n den: d))
</pre>
As usual, you can reorder or leave out bits as you feel.
<li> 
<tt>abstractp: t</tt>
to indicate that this class is abstract, and no direct instances can be made.
</ul>
The class options 
<tt>predicate:</tt>
and
<tt>constructor:</tt>
can be
repeated.<p>

To see all the currently defined classes in Euscheme use
<tt>(class-hierarchy)</tt>.
Other useful functions include
<tt>class-superclasses</tt>,
<tt>class-subclasses</tt>
and
<tt>class-slots</tt>.<p>

<h4>Generic Functions</h4>
Generic functions are (again) first-class objects in EuLisp, constructed by 
<tt>defgeneric</tt>.
Methods are added to them by 
<tt>defmethod</tt>
(unlike some other systems, a generic function must be created by
<tt>defgeneric</tt>
<em>before</em> 
<tt>defmethod</tt>
will work.)

<pre>(defgeneric foo (a b))

(defmethod foo ((a &lt;integer>) (b &lt;integer>))
  (list 'int 'int))

(defmethod foo ((x &lt;float>) (y &lt;float>))
  (list 'float 'float))
</pre>
This defines a generic of two arguments, and two methods. So
<pre>(foo 4 5)     -> (int int)
(foo 1.0 2.0) -> (float float)
(foo 2 2.0)   -> error, "no applicable methods"
</pre>
The methods discriminate off all the arguments, working left to right. Adding
another method
<pre>(defmethod foo ((n &lt;number>) (m &lt;number>))
  (list 'num 'num))
</pre>
we get 
<tt>(foo 2 2.0) -> (num num)</tt>.

Generally the most specific method for a given set of arguments is the method
that is executed in a generic call.  The next most specific method can be
invoked by using 
<tt>(call-next-method)</tt>
in the body of the current method.<p>

<h3>12. Threads</h3><p>
EuLisp supports multiple threaded programming by supplying some basic
thread primitives.<p>

To make a thread use
<pre>(make-thread fn)
</pre>
which returns a thread object (another first-class object).  The 
<tt>fn</tt>
is the function that the thread will start executing when it and when starts
running.<p>

A thread will not run until it is <em>started</em>
<pre>(thread-start thr arg arg ...)
</pre>
This function takes a thread 
<tt>thr</tt>
and starts executing the function
<tt>fn</tt>
(from 
<tt>make-thread</tt>)
on the arguments 
<tt>arg</tt>.
That is, it starts executing 
<tt>(fn arg arg ...)</tt>.<p>

Or it would start executing the thread if there were enough processors
to do so.  As is most likely, the thread is simply marked as <em>ready to
run</em> whenever the resource is available.  The EuLisp model requires
the programmer to write in such a manner that does not presume any particular
number of processors are available.  Even if there is just one processor, the
program should be written to work. To aid this, there is the function
<pre>(thread-reschedule)
</pre>
which will suspend the current thread, and allow another to run in its place.
If there are enough processors so that all threads are running, then
<tt>thread-reschedule</tt>
could have no effect at all.<p>

An single-threaded implementation such as Euscheme requires a sprinkling of
<tt>thread-reschedule</tt>s
for a parallel program to work.<p>

Threads are often used for their effect, but they can also return a value.
<pre>(thread-value thr)
</pre>
will suspend the calling thread (and allow another to run in its place) until
the thread 
<tt>thr</tt>
returns a value (and returns what the 
<tt>thr</tt>
returned).  A thread can return a value simply by returning from its initial
function
(<tt>fn</tt>, above).<p>

<h4>Semaphores</h4>
EuLisp provides simple binary semaphores, named <em>locks</em>, with functions

<tt>make-lock</tt>
to make one, 
<tt>lock</tt>
to gain a semaphore, and
<tt>unlock</tt>
to release.<p>

Locking a locked lock will suspend the calling thread (and allow another to
run) until some other thread releases the lock.<p>

<h3>13. Input and Output</h3><p>

EuLisp is still a little undecided as to how i/o is going to turn out, so for
the meantime Euscheme uses Scheme's functions.
<ul>
<li> 
<tt>read</tt>
to read a Lisp expression.
<li> 
<tt>write</tt>
output in a way that can be re-read if possible. Thus, for example, strings are
quoted.
<li> 
<tt>prin</tt>
output in a human-friendly manner. Strings and such are not quoted. Compare
<pre>(print "asd")   prints: asd
(write "asd")   prints: "asd"
</pre>
<li> 
<tt>print</tt>
as 
<tt>prin</tt>,
with a newline.
<li> 
<tt>newline</tt>
output a newline.
</ul>
All of the above take an optional extra argument, which is a stream to print
on. This defaults to the standard output.<p>

For stream manipulation:
<ul>
<li> 
<tt>open-input-file</tt>
takes a string, and opens and returns a corresponding stream for input. Returns
<tt>()</tt>
if not such file exists.
<li> 
<tt>open-output-file</tt>
creates a file if it didn't already exist.
<li> 
<tt>open-update-file</tt>
opens for append.
<li> 
<tt> get-file-position</tt>
and 
<tt>(setter  get-file-position)</tt>
move the file pointer in a file opened for update.
<li> 
<tt>close-port</tt>
closes an open stream.
</ul>

<h4>Format</h4>
A more complicated printing function is 
<tt>format</tt>,
which is somewhat akin to C's 
<tt>printf</tt>.

<pre>(format stream format-string arg arg ...)
</pre>
If 
<tt>stream</tt>
is 
<tt>t</tt>,

<tt>format</tt>
prints to the standard output. If 
<tt>stream</tt>
is 
<tt>()</tt>,

<tt>format</tt>
returns the formatted output as a string. Otherwise 
<tt>stream</tt>
is a file stream.<p>

The format string is copied to the output, except that 
<tt>~</tt>
marks an escape (like C's 
<tt>%</tt>):
<ul>
<li> 
<tt>~a</tt>
output the next arg using
<tt>prin</tt>
<li> 
<tt>~s</tt>
output the next arg using
<tt>write</tt>
<li> 
<tt>~%</tt>
output a newline
<li> 
<tt>~~</tt>
output a 
<tt>~</tt>
<li> 
<tt>~c</tt>
output a character
<li> 
<tt>~d</tt>
output an integer
<li> 
<tt>~e</tt>
<tt>~f</tt>,
<tt>~g</tt>
floating point formats
<li> 
<tt>~t</tt>
output a tab
</ul>
There are other escapes to write integers in other bases, output new pages, and
so on.<p>

<h3>14. Macros</h3><p>

EuLisp employs the usual backquoted template style of macros.
<pre>(defmacro first (x)
  `(car ,x))
</pre>
Note that a macro cannot be used in the module where it is defined: a module
must be fully macroexpanded before it can be compiled. If you don't know what
is and what isn't a macro beforehand, it is very difficult to do this. Thus
a module containing
<pre>(defmacro second (x)
   `(cadr ,x))

(defun foo (x) (+ 1 (second x)))
</pre>
is doomed to failure by this restriction.<p>

There is a wrinkle in the way that macros interact with modules: suppose a
macro expands into something that refers to bindings that are not imported into
the current module?

<pre>(defmodule one
  (import (level0))

  (defmacro foo (x)
     `(car (bar ,x)))

  (defun bar (a) ...)

  (export foo)
)
</pre>
Here the module 
<tt>one</tt>
exports 
<tt>foo</tt>
only, but 
<tt>foo</tt>
expands into a reference to 
<tt>bar</tt>.
<pre>(defmodule two
  (import (level0))

  ...
  (foo 4)
  ...
)
</pre>
In the macroexpansion of module 
<tt>two</tt>,
a reference to 
<tt>bar</tt>
would appear, but 
<tt>bar</tt>
is not defined in
<tt>two</tt>.
Worse, maybe
<tt>bar</tt>
<em>was</em> defined in 
<tt>two</tt>:
which 
<tt>bar</tt>
does the macroexpanded form refer to? The 
<tt>bar</tt>
from
<tt>one</tt>
or the
<tt>bar</tt>
from 
<tt>two</tt>?<p>

The answer is "the right 
<tt>bar</tt>", that is
that 
<tt>bar</tt>
in the module of macro definition, not the 
<tt>bar</tt>
in the module of macro use.  Euscheme takes care of all of this transparently
for you: essentially every symbol remembers which module it was defined in, and
always refers back to that module for its value.<p>

This provides a simple solution to the "macro hygene" problem that
has always plagued Lisp macros.<p>

Sometimes you <em>do</em> want a symbol to be captured in the module
of use: Euscheme provides a facility to allow you to do this.
<pre>(defmacro while (test . body)
  `(let/cc {break}
     (labels
       ((loop ()
	  (when ,test
                ,@body
                (loop))))
       (loop))))
</pre>
The symbol 
<tt>loop</tt>
cannot be captured by the code in 
<tt>body</tt>,
while the symbol 
<tt>break</tt>
is intended to be captured. The curly braces about the symbol
indicates that it is to be interpreted as coming from the module of
use, <em>not</em> the module of definition. Thus, a reference to
<tt>break</tt>
in the 
<tt>body</tt>
will refer to the binding in the
<tt>let/cc</tt>.<p>

Notice that <tt>(eq 'break '{break}) -> t</tt>.
As symbols they are <tt>eq</tt>, but as
identifiers they are quite different.

<h3>15. Miscellany</h3><p>

<h4>Comparisons</h4>
EuLisp has the usual tests for equality:
<ul>
<li> 
<tt>eq</tt>
for identity
<li> 
<tt>eql</tt>
for identity, but will also work for integers and characters
<li> 
<tt>equal</tt>
for recursive equality
<li> 
<tt>=</tt>
for numbers
</ul>
Note that
<pre>(equal 1 1.0)  -> ()
(= 1 1.0)      -> t
</pre>

There is also the usual 
<tt>&lt;</tt>,
<tt>&lt;=</tt>,
<tt>></tt>,
<tt>>=</tt>,
which are n-ary:
<pre>(< a b c ...)
</pre>
returns 
<tt>t</tt>
when 
<tt>a</tt>,
<tt>b</tt>,
<tt>c</tt>,
etc., form a strictly increasing sequence. Similarly 
<tt>&lt;=</tt>
for a non-decreasing sequence, and so on.<p>

<h4>Generic Arithmetic</h4>
The arithmetic operators 
<tt>+</tt>
and so on are all n-ary, i.e., take a variable number of arguments.  Each
operator is defined in terms of a binary generic function: 
<tt>binary+</tt>
for 
<tt>+</tt>,
<tt>binary*</tt>
for
<tt>*</tt>,
etc.  The n-ary form is just a repeated application of the binary form
<pre>(+ a b c ...) = ((..(binary+ (binary+ a b) c) ...
</pre>

Methods can be added to the binary operators
<pre>(defmethod binary+ ((a &lt;symbol>) (b &lt;symbol>))
   ...)
</pre>
and then you can use 
<tt>+</tt>
to add symbols:
<tt>(+ 'a 'b 'c)</tt>.<p>

There are also generic functions 
<tt>unary-</tt>
and 
<tt>unary/</tt>
for the unary 
<tt>(- x)</tt>
and 
<tt>(/ x)</tt>
(reciprocal).<p>

Similarly, the comparators 
<tt>&lt;</tt>,
<tt>></tt>,
<tt>&lt;=</tt>
etc., are all defined in terms of the two generic functions 
<tt>binary&lt;</tt>
and 
<tt>binary=</tt>.<p>

<h4>Local Functions</h4>
Just like 
<tt>let</tt>
introduces local variables, the 
<tt>labels</tt>
form can introduce local functions.
<pre>(labels
  ((foo (a b)
     ... (bar a) ... )
   (bar (x)
     ... (foo x (bar x)) ... ))
  ...
  (foo 3 4)
  ...
)
</pre>
The 
<tt>labels</tt>
takes a list of function definitions. They may be self and mutually recursive.
These functions may be used within the body of the 
<tt>labels</tt>
just like global functions. Iterating functions are often most conveniently
written in terms of
<tt>labels</tt>
as the bodies of the function definitions can refer to local variables:
<pre>(let ((a 1))
  (labels
    ((addit (x)
       (if (null x)
           ()
           (cons (+ a (car x)) (addit (cdr x))))))
    (addit '(1 2 3))))
->
(2 3 4)
</pre>

<a name="map"></a>
<h4>Mapping and Collections</h4>
There are several functions supplied to iterate along collections. Collections
include lists, vectors, strings, and <a href="#tables">tables</a>.<p>

The generic function
<tt>map</tt>
takes a function and a collection
<pre>(map list '(1 2 3))   -> ((1) (2) (3))
(map - #(4 5 6))      -> #(-4 -5 -6)
</pre>
or more than one collection
<pre>(map cons '(a b c) '(A B C))     -> ((a . A) (b . B) (c . C))
(map + #(1 2 3) #(10 10 10 10))  -> #(11 12 13)
</pre>
The mapping stops when any collection runs out. Even a mixture will work
<pre>(map * '(2 4 6) #(1 -1 1))  -> (2 -4 6)
(map * #(2 4 6) '(1 -1 1))  -> #(2 -4 6)
</pre>
The type of collection returned is the same as the first collection
argument.<p>

If you don't need a return value, but are iterating purely for effect, use
<tt>do</tt>
<pre>(do print '(1 2 3))
</pre>

Other iterators include 
<tt>accumulate</tt>
<pre>(accumulate list () #(a b c))      -> (((() a) b) c)
(accumulate * 1 '(1 2 3 4 5 6 7))  -> 5040
</pre>
which takes a function, an initial value, an a collection to iterate over.<p>

You can find the size of any collection using the function 
<tt>size</tt>.
This returns the length of a list of string, number of elements of a vector,
and so on. It can be reversed by
<tt>reverse</tt>;
an element removed by
<tt>remove</tt>
(non-destructive) or by 
<tt>delete</tt>
(destructive); find an element by 
<tt>(member elt
collection)</tt>.
The last three
(<tt>remove</tt>,
<tt>delete</tt>
and 
<tt>member</tt>)
take an optional last argument that is a test for equality: it is this test
that is used when looking for an element in the collection.  It defaults to 
<tt>eql</tt>.<p>

The function 
<tt>concatenate</tt>
can be used to join collections:
<pre>(concatenate '(1 2 3) '(4 5 6))  -> (1 2 3 4 5 6)
(concatenate "abc" "def")        -> "abcdef"
(concatenate '(1 2 3) #(4 5 6))  -> (1 2 3 4 5 6)
</pre>

<h4>Loops</h4>
EuLisp doesn't really need loops, as everything can be written easily in
terms of tail recursive functions. However, Euscheme sneaks in a 
<tt>while</tt>
loop:
<pre>(while bool
   expr
   expr
   ...
)
</pre>
which loops while the 
<tt>bool</tt>
returns
true.<p>

<a name="tables"></a>
<h4>Tables</h4>
EuLisp uses tables for a general association mechanism.  Euscheme
implements tables as hash tables, but in general they could be implemented
differently.
<ul>
<li> 
<tt>make-table</tt>
returns a table.
<li> 
<tt>(table-ref table key)</tt>
to retrieve a value,

<tt>((setter table-ref) table key value)</tt>
to update.
<li> 
<tt>(table-delete key)</tt>
to remove a value.
<li> 
<tt>table-keys</tt>
to get a list of current keys.
<li> 
<tt>table-values</tt>
to get a list of current values.
<li> 
<tt>table-clear</tt>
to completely empty a table.
</ul>
When looking for a match to a key in a table, the system defaults to
<tt>eql</tt>.
You can change this by using
<tt>(make-table comparator)</tt>,
where 
<tt>comparator</tt>
is 
<tt>eq</tt>
or 
<tt>eql</tt>
or
<tt>equal</tt>
or 
<tt>=</tt>.<p>

If a value is not found for a particular key in the table 
<tt>()</tt>
is returned.  This can be changed by 
<tt>(make-table
comparator fill-value)</tt>.
Now 
<tt>fill-value</tt>
will be returned on failure.<p>

The mapping functions <a href="#map">above</a> work on tables, too.<p>

<h4>Non-local exits</h4>
EuLisp supports a limited form of continuation capture via 
<tt>let/cc</tt>.
This form captures its continuation, and allows its use as a non-local exit.
<pre>(let/cc out
   ...
   (out)
   ...
)
;; after
</pre>
This stores the continuation (i.e., from 'after') in the variable 
<tt>out</tt>.
This can be called as a function, whereupon control passes immediately to that
continuation. The value of 
<tt>out</tt>
can only be used in this way in the dynamic scope of the 
<tt>let/cc</tt>
form: outside the value is 'dead' and no longer usable.<p>

The continuation function can take a single optional argument which is a value
to pass to the continuation: the default is 
<tt>()</tt>.<p>

The forms 
<tt>block</tt>
and 
<tt>return-from</tt>
are simply 
<tt>let/cc</tt>
and a call to a continuation:
<pre>(block foo
  ...
  (return-from foo)
  ...
)
</pre>

The 
<tt>unwind-protect</tt>
form ensures things are executed even if there is a non-local exit
<pre>(unwind-protect
  protected-form
  after-form
  after-form
  ...)
</pre>
This starts by executing the 
<tt>protected-form</tt>.
If there is no unusual exit from the 
<tt>protected-form</tt>,
this will then execute the 
<tt>after-form</tt>s
and will return whatever value the
<tt>protected-form</tt>
returned.  If there is a non-local exit from the 
<tt>protected-form</tt>
to a continuation outside the
<tt>unwind-protect</tt>,
the 
<tt>after-form</tt>s
will <em>still</em> be executed before the control passes to the
continuation.<p>

<a name="setter"></a>
<h4>Setters</h4>
Structures, like lists, vectors and class instances have elements that can
be accessed.  The elements of a vector can be read by 
<tt>vector-ref</tt>.
To write to an element use the function 
<tt>(setter vector-ref)</tt>,
<pre>((setter vector-ref) vec index val)
</pre>

Similarly, the accessor 
<tt>car</tt>
has an updater 
<tt>(setter car)</tt>
(often called 
<tt>rplaca</tt>
in other Lisps), and so on. In general a reader function  
<tt>r</tt>
will have an associated updater 
<tt>(setter r)</tt>.<p>

The function 
<tt>setter</tt>
is a simple association mechanism: 
<tt>setter</tt>
is a function that takes a reader and returns the associated writer. To make
such an association between functions
<tt>r</tt>
and 
<tt>w</tt>
just
use 
<tt>setter</tt>
again
<pre>((setter setter) r w)
</pre>
In fact, no particular properties of 
<tt>r</tt>
and 
<tt>w</tt>,
are used, so this can be used as a general facility. Further, 
<tt>setter</tt>
functions, generic functions and methods can be defined directly:
<pre>(defun (setter foo) (a b)
  ...)
</pre>

<h4>Convert</h4>
The function 
<tt>convert</tt>
is used to change an object of one type into an object of another type.  Thus
to convert an integer to a float
<pre>(convert 1 &lt;float>) -> 1.0
</pre>
or the other way
<pre>(convert 2.6 &lt;integer>) -> 2
</pre>
Many other conversions are available: integer to string; character to string;
string to number; symbol to string; list to vector; and so on.<p>

<h4>Copying</h4>
There are two functions that copy structures: 
<tt>deep-copy</tt>
and
<tt>shallow-copy</tt>.
The second recursively descends a structure making copies of all the elements
in the structure; the first makes a single copy of the top-level structure, and
fills its slots will the existing elements:
<pre>(setq a '((1 2) (3 4)))
(setq d (deep-copy a))
(eq a d)                  -> ()
(equal a d)               -> t
(eq (car a) (car d))      -> ()

(setq s (shallow-copy a))
(eq a s)                  -> ()
(equal a s)               -> t
(eq (car a) (car s))      -> t
</pre>

<h4>Other Tools</h4>
Other tools that Euscheme provides:
<ul>
<li> 
<tt>describe</tt>
gives a little information about an object, e.g.,

<tt>(describe &lt;integer>)</tt>
or 
<tt>(describe 4)</tt>
<li> 
<tt>trace</tt><a name="trace"></a>
can be used to print a message every time a function is entered or exited. Thus
<pre>(trace foo)
</pre>
will describe the ins and outs of the function 
<tt>foo</tt>. To untrace, use
<tt>(untrace foo)</tt>.<p>
</ul>

Use
<tt>(import "trace")</tt>
to load 
<tt>trace</tt>.

<h3>16. Euscheme Modules</h3><p>

Euscheme provides a few sample modules.

<h4>Trace</h4>
The
<tt>trace</tt>
module has been mentioned <a href="#trace">above</a>.

<h4>Linda</h4>
The
<tt>eulinda</tt>
module implements the Linda pool mechanism.
<ul>
<li>
<tt>make-linda-pool</tt>
returns a new pool
<li>
<tt>(linda-out pool tag val val ...)</tt>
writes the tuple
<tt>(val val ...)</tt>
under the tag to the pool
<li>
<tt>(linda-in pool tag pat pat ...)</tt>
attempts to read a tuple matching the pattern
<tt>(pat pat ...)</tt>
from the pool.  If no matching tuple exists in the pool, the call will block
until such a tuple appears.  When found, the tuple is removed from the pool.
A pattern is
<ul>
<li> a literal value, to be matched exactly
<li>
<tt>(? var)</tt>
to match any value, and assign the matched value to the variable
<li>
<tt>?</tt>
to match any value, and to discard the result.
</ul>
<li>
<tt>linda-read</tt>
as
<tt>linda-in</tt>
but does not remove the tuple from the pool
<li>
<tt>(linda-eval fun arg arg ...)</tt>
starts a new thread, running the function with the arguments.
</ul>
Debugging tools are
<tt>print-linda-pool</tt>
to print the curent values in a pool, and
<tt>(tril t)</tt>
to print some trace information as the system is running.<p>

The
<tt>tag</tt>
must be a symbol or number.

<h4>Modular Numbers</h4>
The module
<tt>modular</tt>
is a simple implementation of modular integers. The function
<tt>mod</tt>
constructs a modular number

<pre>(setq a (mod 3 5))  -> #<3 mod 5>
(setq b (+ a a))    -> #<1 mod 5>
(/ a)               -> #<2 mod 5>
</pre>

<h4>Scheme</h4>
This module,
<tt>scheme</tt>,
provides a mostly-conformant Scheme environment.  It is probably not wise
to mix Scheme constructs, such as
<tt>call/cc</tt>,
with EuLisp constructs, such as threads.

<h4>Paralation Lisp</h4>
This emulates a paralation system. The module
<tt>tpl</tt>
(for <em>t</em>iny <em>p</em>aralation <em>l</em>isp) exports
<ul>
<li>
<tt>(make-paralation n)</tt>
to make a new paralation of size
<tt>n</tt>.
This returns a index field of the new paralation.
<li>
<tt>elwise</tt>
is the element-wise operator:
<pre>(elwise (a b) (+ a b))
</pre>
where
<tt>a</tt>
and
<tt>b</tt>
are fields on the same paralation.
<li>
<tt>(match field field)</tt>
to create a map between fields, and
<li>
<tt>(move field map combine default)</tt>
to move a
<tt>field</tt>
down a
<tt>map</tt>,
using
<tt>combine</tt>,
(a function taking an appropriate number of arguments) to combine
elements that end up at the same element of the target field, and
<tt>default</tt>
as the default value for a field element that is not in the image of the map.
</ul>

<h4>Values</h4>
This is an emulation of Scheme and Common Lisp's multiple values. The
module
<tt>values</tt>
exports
<ul>
<li>
<tt>(values val val ...)</tt>
as the basic multiple value return
<li>
<tt>call-with-values</tt>
for the Scheme-like values:
<pre>(call-with-values
  (lambda () ...)             ; a thunk returning values
  (lambda (a b c ...) ...))   ; that are passed here, bound
                              ; to a, b, etc.
</pre>
<li>
<tt>multiple-value-setq</tt>;
<tt>multiple-value-list</tt>;
<tt>multiple-value-call</tt>;
<tt>values-list</tt>;
<tt>multiple-value-bind</tt> are all as in Common
Lisp.
</ul>
If you pass multiple values to a continuation that only expects a single
value you will probably get strange results.

<h4>Sort</h4>
A fast stable merge sort. The module
<tt>sort</tt>
exports
<tt>sort</tt>
(non-destructive) and
<tt>sort!</tt>
(destructive).
They are called as
<tt>(sort l)</tt>,
where
<tt>l</tt>
is a list of values to be sorted. The comparison operator used is
<tt>&lt;</tt>.
Alternatively, you can use
<tt>(sort l comp)</tt>,
where
<tt>comp</tt>
is a comparator function.

<h3>17. Euscheme functions</h3><p>
Here is a summary of the functions available in Euscheme. Not all of these
correspond to EuLisp.

<pre>;; specials
   quote
   lambda
   delay
   let
   let*
   setq
   if
   cond
   progn
   and
   or
   let/cc
   while
   block
   return-from
   labels
   when
   unless
   export
   expose
   enter-module
   !>
   reenter-module
   !>>
   call-next-method
   next-method-p
   import
   generic-lambda
   method-lambda

;; defining forms
   defun
   defgeneric
   defmethod
   deflocal
   defconstant
   defmodule
   defmacro

;; list functions
   cons
   car
   cdr
   caar
   cadr
   cdar
   cddr
   caaar
   caadr
   cadar
   caddr
   cdaar
   cdadr
   cddar
   cdddr
   caaaar
   caaadr
   caadar
   caaddr
   cadaar
   cadadr
   caddar
   cadddr
   cdaaar
   cdaadr
   cdadar
   cdaddr
   cddaar
   cddadr
   cdddar
   cddddr
   list
   list*
   append
   last-pair
   length
   memv
   memq
   assv
   assq
   list-ref
   list-tail

;; symbol functions
   bound?
   symbol-value
   symbol-plist
   gensym
   get
   put

;; vector functions
   vector
   make-vector
   vector-length
   vector-ref

;; predicates
   null
   atom
   listp
   numberp
   booleanp
   consp
   symbolp
   keywordp
   complexp
   floatp
   double-float-p
   rationalp
   integerp
   charp
   stringp
   vectorp
   functionp
   portp
   input-port-p
   output-port-p
   objectp
   eof-object-p
   default-object-p
   eq
   eql
   equal

;; arithmetic functions
   +
   -
   *
   /
   %
   zerop
   positivep
   negativep
   oddp
   evenp
   truncate
   floor
   ceiling
   round
   random
   quotient
   remainder
   sin
   cos
   tan
   asin
   acos
   atan
   exp
   sqrt
   log

;; bitwise logical functions
   logand
   logior
   logxor
   lognot

;; string functions
   make-string
   string-length
   string-null?
   string-append
   string-ref
   substring

;; i/o functions
   read
   read-char
   read-byte
   read-short
   read-long
   write
   write-char
   write-byte
   write-short
   write-long
   prin
   print
   newline
   char-ready-p
   peek-char
   format

;; print control functions
   print-breadth
   print-depth

;; file i/o functions
   open-input-file
   open-output-file
   open-append-file
   open-update-file
   close-port
   close-input-port
   close-output-port
   get-file-position
   unlink
   current-input-port
   current-output-port

;; utility functions
   transcript-on
   transcript-off
   getarg
   prompt?
   exit
   compile
   decompile
   gc
   save
   restore

;; debugging functions
   trace-on
   trace-off

;; module functions
   module-symbols
   module-exports
   symbol-module
   current-module
   module-list
   unintern

;; telos
   allocate
   describe
   classp
   subclassp

;; tables
   make-table
   table-ref
   table-comparator
   table-delete
   table-length
   table-keys
   table-values
   table-fill
   table-clear

;; plus some others
   binary
   text
   not
   prin1
   princ
   t
   nil
   eval                 ; no guarantees this one will work
   else
   system
   getenv
   putenv
   tmpfile
   current-time
   ticks-per-second
   backtrace
   backtracep

;; threads
   &lt;thread>
   &lt;simple-thread>
   make-thread
   threadp
   thread-reschedule
   current-thread
   thread-kill
   thread-queue
   current-thread
   thread-start
   thread-value
   thread-state
   &lt;thread-condition>
   &lt;thread-error>
   &lt;thread-already-started>

   &lt;lock>
   &lt;simple-lock>
   make-lock
   lockp
   lock
   unlock
   &lt;lock-condition>
   &lt;lock-error>

   wait
   &lt;wait-condition>
   &lt;wait-error>

;; errors and handlers
   with-handler
   unwind-protect
   &lt;wrong-condition-class>
   signal
   error
   cerror

;; classes
   &lt;object>
   &lt;class>
   &lt;simple-class>
   &lt;list>
   &lt;cons>
   &lt;null>
   &lt;number>
   &lt;integer>
   &lt;fpi>
   &lt;float>
   &lt;double-float>
   &lt;symbol>
   &lt;keyword>
   &lt;string>
   &lt;simple-string>
   &lt;port>
   &lt;input-port>
   &lt;output-port>
   &lt;i/o-port>
   &lt;vector>
   &lt;simple-vector>
   &lt;char>
   &lt;simple-char>
   &lt;promise>
   &lt;table>
   &lt;hash-table>
   &lt;function>
   &lt;simple-function>
   &lt;subr>
   &lt;continuation>
   &lt;generic>
   &lt;simple-generic>
   &lt;method>
   &lt;simple-method>
   &lt;slot>
   &lt;local-slot>
   &lt;structure>

   generic-prin
   generic-write
   wait

   make
   initialize
   class-hierarchy

;; setter
   setter

;; converter
   converter
   convert
   &lt;conversion-condition>
   &lt;no-converter>

;; condition classes
   defcondition
   conditionp
   condition-message
   condition-value
   &lt;condition>
   &lt;telos-condition>
   &lt;telos-error>
   &lt;telos-general-error>
   &lt;telos-bad-ref>
   &lt;no-applicable-method>
   &lt;no-next-method>
   &lt;incompatible-method-domain>
   &lt;arithmetic-condition>
   &lt;arithmetic-error>
   &lt;error>
   &lt;general-error>
   &lt;bad-type>
   &lt;unbound-error>
   &lt;compilation-error>
   &lt;macro-error>
   &lt;syntax-error>
   &lt;user-interrupt>

;; generic arithmetic
   binary+
   binary-
   unary-
   binary*
   binary/
   unary/
   binary%
   binary-gcd
   gcd
   abs
   pow

;; comparisons
   equal
   binary&lt;
   binary=
   &lt;
   =
   >
   &lt;=
   >=
   max
   min
   assoc

;; macros
   defmacro
   quasiquote
   unquote
   unquote-splicing
   symbol-macro
   macroexpand
   macroexpand1
   syntax

;; collections and sequences
   &lt;collection-condition>
   &lt;collection-error>
   collectionp
   sequencep
   accumulate
   accumulate1
   allp
   anyp
   concatenate
   delete
   do
   element
   emptyp
   fill
   map
   member
   remove
   reverse  
   size

;; copying
   deep-copy
   shallow-copy

;; telos introspection
   class-of
   class-name
   class-superclasses
   class-precedence-list
   class-slots
   class-keywords
   class-subclasses
   class-instance-size
   class-abstract-p
   generic-name
   generic-args
   generic-optargs?
   generic-methods
   generic-cache1
   generic-cache2
   method-generic
   method-function
   method-domain
   add-method
   slot-name
   slot-keyword
   slot-default
   slot-required-p

;; other functions
   apply
   map-list
   load
   load-noisily
   force
</pre>

<h3>18. Command Line Arguments</h3><p>
The Euscheme interpreter accepts a few arguments:
<ul>
<li><tt>-t</tt> enable trace debugging
<li><tt>-n</tt> do not load an image
<li><tt>-q</tt> do not print results in the
read-eval-print loop
<li><tt>-f</tt> see
<a href="#scripts">below</a>
<li><tt>-s</tt> disable the
<tt>system</tt> function
</ul>
Other arguments are passed to the intepreter and are available as
<tt>(getarg 0)</tt> (the name of the program),
<tt>(getarg 1)</tt> (first argument),
<tt>(getarg 2)</tt> (second argument), and so on.
The function <tt>getarg</tt> returns
<tt>()</tt> for a non-existent argument.

<h4>Shell Scripts</h4><a name="scripts"></a>
Euscheme can be used in a shell script by means of the
<tt>-f</tt> flag:
<pre>
#!/usr/local/bin/euscheme -f

(print "hello world")
</pre>

It is usual to use the
<tt>-q</tt> flag to prevent the echo from the
read-eval-print loop, and the
<tt>-s</tt> flag to prevent the use of
the <tt>system</tt> function.

<pre>
#!/usr/local/bin/euscheme -fq

(print "hello world")
</pre>

<p><p>
<a href="http://www.bath.ac.uk/~masrjb/Sources/eunotes.html">Here</a> is
the latest version of these notes.
</body>
</html>
