#                            -*- mode: org; -*-
#+TITLE:              *Using EuXLisp* (Formally Euscheme)
#+AUTHOR: of original Euscheme notes Russell Bradford
#+EMAIL: no-reply
#+OPTIONS: email:nil ^:{}
#+STARTUP: hidestars
#+STARTUP: odd
* [[file:../index.org][EuXLisp index]]
* Introduction
  These notes are based on the Euscheme HTML notes by Russell Bradford.  Most of
  the text remains more or less unchanged but reformatted in Org-mode and
  exported as HTML and PDF.  Also some changes have been made and continue to be
  made to keep this document consistent with the evolving EuLisp definition and
  EuXLisp implementation.

  EuXLisp is a simple EuLisp Level 0 interpreter.  EuLisp Level 0) is a small
  and compact Lisp, but nevertheless has many interesting features, such as
  modules, an object system, and multithreading.  EuLisp Level 1 has extra
  features, the most notable being a full metaobject system which is implemented
  in Youtoo not in EuXLisp.  These are a few notes on the use of EuLisp in
  general and EuXLisp in particular and concentrate on those things unique to
  EuLisp.

* Running EuXLisp
  Type /euxlisp/ which will print the banner and prompt:
  #+BEGIN_SRC eulisp
  EuXLisp (formally EuScheme) - Version 0.36.2

  user>
  #+END_SRC
  where the final line is the prompt.  EuXLisp uses the usual read-eval-print
  cycle of interactive Lisps: type something, it will be evaluated, and the
  result printed.  To exit, use
  #+BEGIN_SRC eulisp
  (exit)
  #+END_SRC

  and (usually) ^D will work, too.

*** [[file:./euxlisp.html][EuXLisp man page (HTML)]]
*** [[file:./euxlisp.1][EuXLisp man page (ASCII)]]

* Constants
  There are the usual self-evaluating bits and pieces:
  + strings: in double quotes "hello"
  + numbers: integers and floating point =1234= and =3.1415=
  + characters: preceded by =#\= as in =#\c= for the character 'c'
  + vectors: delimited by =#(= and =)= as in =#(1 a (3))= which is a vector of
    length 3, containing an integer, a symbol, and a list.

* Lists and Vectors
  Lists are created with the usual [[file:EuLisp-0.991/html/eulispcl17.html#dx21-624002][=cons=]], [[file:EuLisp-0.991/html/eulispcl17.html#dx21-641002][=list=]] and quoted forms '(1 2 3).
  Use [[file:EuLisp-0.991/html/eulispcl17.html#dx21-626002][=car=]] and [[file:EuLisp-0.991/html/eulispcl17.html#dx21-628002][=cdr=]] to access the elements.

  A vector is created by the function =make-vector= as in
  #+BEGIN_SRC eulisp
  (make-vector 4)
  #+END_SRC
  which creates a vector of length 4, indexed from 0 to 3, all elements
  initialised to be [[file:EuLisp-0.991/html/eulispcl17.html#dx21-609010][=()=]]s.  In fact, make-vector can take a second argument
  #+BEGIN_SRC eulisp
  (make-vector 4 0)
  #+END_SRC
  which creates a vector as before, with all elements initialised to 0.

  To access a vector element use =(vector-ref vec index)=; to update use
  =((setter vector-ref) vec index newval)=.  See below for details about the
  setter function.

  Take care with the creation of vectors: =(make-vector 3 #(0 0 0))= will create
  a vector of three slots, all initialised to the same [[file:EuLisp-0.991/html/eulispcl17.html#dx21-431004][=eq=]] value.

* Expressions
  As is usual, anything that is not a constant is an expression to be evaluated,
  and those things marked by a quote are deemed to be constant.  Thus
  #+BEGIN_SRC eulisp
  (+ 1 2)
  #+END_SRC
  is an expression to be evaluated, while
  #+BEGIN_SRC eulisp
  '(+ 1 2)
  #+END_SRC

  is a constant list of 3 elements (modifying constant lists has an undefined
  effect, so it's best not to do so).  EuLisp has both progn to collect together
  several expressions into a single expression, and let for the declaration of
  local variables.
  #+BEGIN_SRC eulisp
  (progn
    expr
    expr
    ...
  )
  #+END_SRC
  and
  #+BEGIN_SRC eulisp
  (let ((var val)
        (var val)
        ...)
    expr
    expr
    ...
  )
  #+END_SRC
  (Semantics: evaluate all the vals first, then make the bindings to the
  corresponding vals.  Thus the vals cannot refer to the vars.  Use let*
  #+BEGIN_SRC eulisp
  (let* ((var1 val1)
         (var2 val2)
         ...)
    ...)
  #+END_SRC
  with semantics of evaluate =val1=, bind to =var1=, evaluate =val2=, bind to
  =var2=, etc., if you need to refer back to previous values.)

  The values of these expressions are the values of their last exprs.  Named
  [[file:EuLisp-0.991/html/eulispcl16.html#dx20-289003][=let=]] and [[file:EuLisp-0.991/html/eulispcl16.html#dx20-292004][=let*=]] are also supported.

  Numbers have the usual syntax: =123=, =1.23= and =1.2e4=.  Additionally, you
  can enter integers in base 2: =#b101010=, base 8: =#o7654=, base 16: =#x12ab=,
  and any other base up to 36: =#23r12gd= for a base 23 integer.

  The full syntax of symbols is somewhat tricky, but "alphanumerics, starting
  with a letter" is certainly OK.  Dodgy characters, such as space, or a leading
  digit can be escaped with a =\=.  A multiple character escape is introduced
  and ended by =|=.  Within the confines of these delimiters any character is
  fine, except that =\|= is interpreted as a literal =|=, and =\\= as a literal
  =\=.

  All the following are the same symbol:
  #+BEGIN_SRC eulisp
  \1\ 23
  |1 |23
  |1 23|
  |1 |2|3|
  |1 |2\3
  \1| |2||3
  #+END_SRC
  Their canonical form is =|1 23|=.

* Conditionals
  EuLisp has the usual =(if boolexpr trueexpr falseexpr)= (always with both
  trueexpr and falseexpr), and the [[file:EuLisp-0.991/html/eulispcl16.html#dx20-262002][=cond=]] form.  The single false value in
  EuLisp is [[file:EuLisp-0.991/html/eulispcl17.html#dx21-609010][=()=]]: anything else is deemed to be true.  [[file:EuLisp-0.991/html/eulispcl16.html#dx20-210002][=t=]] is bound to the
  symbol [[file:EuLisp-0.991/html/eulispcl16.html#dx20-210002][=t=]], providing a convenient canonical true value.  Additional
  conditional forms include
  #+BEGIN_SRC eulisp
  (when boolexpr
     expr
     expr
     ...
  )
  #+END_SRC
  where the exprs are evaluated when the condition is true; and
  #+BEGIN_SRC eulisp
  (unless boolexpr
     expr
     expr
     ...
  )
  #+END_SRC
  where the exprs are evaluated when the condition is false.

* Assignment
  [[file:EuLisp-0.991/html/eulispcl16.html#dx20-245003][=setq=]] as usual:
  #+BEGIN_SRC eulisp
  (setq foo 2)
  #+END_SRC

  It's also good to define module-local variables:
  #+BEGIN_SRC eulisp
  (deflocal foo 2)
  #+END_SRC
  You can omit the initial value if you want.  The [[file:EuLisp-0.991/html/eulispcl16.html#dx20-211007][=deflocal=]] form should only
  be used at the top level (i.e., never inside a function definition or a
  [[file:EuLisp-0.991/html/eulispcl16.html#dx20-289003][=let=]]).

* Defining Functions
  Here we use defun.
  #+BEGIN_SRC eulisp
  (defun len (l)
    (if (null l)
        0
        (+ 1 (len (cdr l)))))
  #+END_SRC
  EuLisp is fully tail-recursive, so a function written in a tail-recursive way
  uses no stack:
  #+BEGIN_SRC eulisp
  (defun foo (n)
    (print n)
    (foo (+ n 1)))
  #+END_SRC
  will run forever.

  Variable arity functions are available, too:
  #+BEGIN_SRC eulisp
  (defun bar (a b .  c)
    (list a b c))
  #+END_SRC

  can take 2 or more arguments.  The first two arguments are bounds to a and b
  as usual, the rest are made into a list which is bound to c.  Thus =(bar 1 2 3
  4 5)= prints =(1 2 (3 4 5))=, and =(bar 99 100)= prints =(99 100 ())=.

* Arithmetic
  All the usual stuff here.  Functions [[file:EuLisp-0.991/html/eulispcl17.html#dx21-655004][=+=]], [[file:EuLisp-0.991/html/eulispcl17.html#dx21-657002][=-=]], [[file:EuLisp-0.991/html/eulispcl17.html#dx21-659002][=*=]] and [[file:EuLisp-0.991/html/eulispcl17.html#dx21-661002][=/=]], [[file:EuLisp-0.991/html/eulispcl17.html#dx21-671002][=abs=]], [[file:EuLisp-0.991/html/eulispcl17.html#dx21-521002][=sin=]],
  [[file:EuLisp-0.991/html/eulispcl17.html#dx21-531002][=exp=]] and so on.  Use =(pow a b)= to raise =a= to power =b=.  Additionally,
  the basic arithmetic ops have variable arity:
  #+BEGIN_SRC eulisp
  (+)         -> 0
  (+ 1)       -> 1
  (+ 1 2)     -> 3
  (+ 1 2 3)   -> 6
  (- 1)       -> -1
  (* 1 2 3 4) -> 24
  #+END_SRC

  and so on.

* Modules
  Now for something a little different.  The basic unit of a program in EuLisp
  is the module.  Modules provide a way of fixing the global namespace pollution
  problem: each module has its very own namespace.  A module can import names
  from other modules, and can export names too.

  Here is a simple module:
  #+BEGIN_SRC eulisp
  (defmodule one
    (import (level0))

    (defun foo ...)
    (defun bar ...)
    (deflocal baz ...)
    ...

    (export foo baz)
  )
  #+END_SRC
  The module one imports from the system module named =level0=.  This module
  contains all the useful stuff like [[file:EuLisp-0.991/html/eulispcl17.html#dx21-624002][=cons=]], [[file:EuLisp-0.991/html/eulispcl17.html#dx21-626002][=car=]], [[file:EuLisp-0.991/html/eulispcl16.html#dx20-229002][=defun=]], [[file:EuLisp-0.991/html/eulispcl17.html#dx21-655004][=+=]] and so on.  In
  fact, it's generally a good idea to import the =level0= module, otherwise you
  can't actually do anything.

  In module one we define a few name, like =foo=, =bar= and =baz=, and export
  =foo= and =baz=.  Now any module that imports one can access =foo= and =baz=,
  but bar is completely hidden from everyone.

  If now, we have
  #+BEGIN_SRC eulisp
  (defmodule two
    (import (level0 one))

    ...
  )
  #+END_SRC
  the module two imports one (and =level0=), so two can refer to =foo= and =baz=
  from one.  If two uses a name =bar=, it is its own =bar=, and has nothing to
  do with the =bar= in one.

*** Modules in EuXLisp
    EuXLisp requires each module to be in a file of its own: thus one should be
    in a file named one.em (for EuLisp module), and two in /two.em/.  To enter a
    module, use
    #+BEGIN_SRC eulisp
    (!> one)
    #+END_SRC
    which will load one if it is not already loaded, and will set the current
    module to be one.  This is indicated by the prompt
    #+BEGIN_SRC eulisp
    user> (!> one)
    <reading one.em>
    <read one.em>
    <one...done>
    #t
    one>
    #+END_SRC
    Now the read-eval-print loop acts on bindings in the one module.  Use =(!>
    user)= to switch back to the original module.

    To re-load a module (after, say, changing the file) use =(!>> one)=.

    Modules can rename and filter on [[file:EuLisp-0.991/html/eulispcl10.html#dx12-69001][=import=]] (not yet on [[file:EuLisp-0.991/html/eulispcl10.html#dx12-68001][=export=]]).  Use
    level0.em for all the basic stuff, e.g.,
    #+BEGIN_SRC eulisp
    (defmodule mymod
      (import (level0))
      ...
      )
    #+END_SRC
    If you [[file:EuLisp-0.991/html/eulispcl10.html#dx12-69001][=import=]] no modules, you get nothing---not even special forms!  See
    /Modules/rename.em/.

  Look at directory /Modules/ for a few examples (the basic EuLisp functionality
  in the modules in /EuXLisp/Boot/ are written the scheme-like syntax of
  xscheme).

* Errors and the Debug Loop
  When you make an error, EuLisp will call an error handler.  The full use of
  error handlers is too tricky for an introductory set of notes, so we shall
  rely on the default (built-in) handler.  In EuXLisp an error puts the system
  into a simple debugging loop:
  #+BEGIN_SRC eulisp
  user> qwerty
  Continuable error---calling default handler:
  Condition class is #<class unbound-error>
  message:        "variable unbound in module 'user'"
  value:          qwerty

  Debug loop.  Type help: for help
  Broken at #<Code #1008a768>

  DEBUG>
  #+END_SRC
  There is a lot of information here, and you should look carefully at what
  EuXLisp is telling you.

  In this case, the call of error is an 'unbound-error', i.e., reference to an
  undefined variable.  The message gives an English description of the error,
  while the value fills in some details, so it is the variable named qwerty that
  is at fault.

  Another error:
  #+BEGIN_SRC eulisp
  user> (car 5)
  Continuable error---calling default handler:
  Condition class is #<class bad-type>
  message:        "incorrect type in car"
  value:          5
  expected-type:  #<class cons>

  Debug loop.  Type help: for help
  Broken at #<Code #100820a8>

  DEBUG>
  #+END_SRC
  This is a 'bad-type' error, where the function car was expecting a different
  type of argument; it got a 5, where it was expecting something of class cons,
  i.e., some sort of list.

  The prompt becomes =DEBUG>= to indicate we are in the debug loop.  In this
  loop things act as normal, except we have some additional functions to play
  with.  Type help: to get
  #+BEGIN_SRC eulisp
  Debug loop.
  top:                                return to top level
  resume:  or  (resume: val)          resume from error
  bt:                                 backtrace
  locals:                             local variables
  cond:                               current condition
  up:  or  (up: n)                    up one or n frames
  down:  or  (down: n)                down one or n frames
  where:                              current function
  #+END_SRC
  The most useful of these is top:, which clears up the error and returns us to
  the top-level read-eval-print loop; and bt: which gives us a backtrace, i.e.,
  a list of the function calls and their arguments that took us to where we are
  now.  (Note that, as EuLisp is tail recursive, EuXLisp does not save all the
  return addresses of the functions that it travels through, so the backtrace
  may omit certain intermediate function calls.)

  In a debug loop ^D will act as resume:, which is to try to carry on from the
  point of error.  Debug loops can be nested.

* Classes and Generic Functions
  EuLisp has a full object system.  At Level 0, it is a simple, non-reflective
  system, comparable to C++'s class system.  Every object in EuLisp has a class,
  which is itself a first-class object: this means that classes are supported at
  the same level as any other object in the system, and can be created, passed
  to functions, returned from functions, and so on.  For example, the integer
  =1= has class [[file:EuLisp-0.991/html/eulispcl17.html#dx21-583035][=<integer>=]] (or rather, has a class with name =<integer>=).

  In fact, EuXLisp has (class-of 1) to be [[file:EuLisp-0.991/html/eulispcl17.html#dx21-554035][=<fpi>=]] (for fixed point integer),
  which is a subclass of [[file:EuLisp-0.991/html/eulispcl17.html#dx21-583035][=<integer>=]].

  Classes are fully-fledged objects, so they have a class, too
  #+BEGIN_SRC eulisp
  (class-of <integer>) -> #<class class>
  #+END_SRC
  the print representation of the class [[file:EuLisp-0.991/html/eulispcl11.html#dx13-76007][=<class>=]].  Finally, (class-of
  [[file:EuLisp-0.991/html/eulispcl11.html#dx13-76007][=<class>=]]) is =<class>= itself, or else we would need an infinite tower of
  classes.

  To make an instance of a class, use make
  #+BEGIN_SRC eulisp
  (make <cons> car: 1 cdr: 2) -> (1 .  2)
  #+END_SRC
  The keywords (symbols whose names end with colons) indicate how to fill in the
  various slots of the instance of the class.  The keywords can be in any order,
  and can be omitted if not necessary: though some classes have slots with
  required keywords.  This means that instances of such classes must have
  certain information passed to make in order to succeed.  Some classes are
  abstract, and you cannot make instances of them.  They are there purely for
  other classes to inherit from.  The class [[file:EuLisp-0.991/html/eulispcl17.html#dx21-609006][=<list>=]] is abstract, while its
  subclass [[file:EuLisp-0.991/html/eulispcl17.html#dx21-620002][=<cons>=]] is concrete.

  It is simple to create new classes by the use of defclass.
  #+BEGIN_SRC eulisp
  (defclass <rat> ()
     ((num keyword: num:
           default: 0
           accessor: num)
      (den keyword: den:
           default: 1
           accessor: den))
      predicate: rat?
      constructor: (rat num: den:))
  #+END_SRC
  There are many parts to explain.

  This form defines a new class named =<rat>=.  Classes in EuLisp are
  conventionally noted by the use of angle brackets =<>=, but they are just
  normal names.  The [[file:EuLisp-0.991/html/eulispcl17.html#dx21-609010][=()=]] next is the list of classes for =<rat>= to inherit
  from.  In EuLisp Level 0, there is only single inheritance, so this should be
  a list of at most one class.  Any empty list indicates some suitable default
  super-class.

  Next is a list of slot descriptions.  Each has a slot name first, then a list
  of slot options.  The slot options are identified by keywords which can come
  in any order, and can be omitted it you don't want them.

  The slot options are:
  + =keyword:= a keyword to use in a make of the class instance.
  + =default:= a default value to put in the slot if a value is not passed via
    the keyword.
  + =accessor:= a name that will be bound to functions to read and write the
    slot.  In the above example, num will name a function to read the num slot
    in an instance of =<rat>=.  Similarly, =(setter num)= will be a function to
    write to such a slot.  See setters.
  + =reader:= a name for a slot reader.
  + =writer:= a name for a slot writer.
  + =required?:= use =required?: t= to indicate a required slot.  This slot must
    have a =keyword: keyword=!

  The =accessor:=, =reader:= and =writer:= options can be repeated as many times
  as you wish with different names.

  Next come the class options.  Again, in any order or omitted.

  + =predicate:= a symbol to name a function that will return true on an
    instance of the class, and false on all other objects.
  + =constructor:= a way to name a function to make an instance of the class.
    In this case, rat will name a function of two arguments that makes an
    instance of =<rat>=.  The first argument will be given to the =num:=
    keyword, the second to the =den:=.  This is equivalent to defining
    #+BEGIN_SRC eulisp
    (defun rat (n d)
      (make <rat> num: n den: d))
    #+END_SRC
    As usual, you can reorder or leave out bits as you feel.
  + =abstract?: t= to indicate that this class is abstract, and no direct
    instances can be made.

  The class options =predicate:= and =constructor:= can be repeated.

  To see all the currently defined classes in EuXLisp use =(class-hierarchy)=.
  Other useful functions include class-superclasses, class-subclasses and
  class-slots.

*** Generic Functions
    Generic functions are (again) first-class objects in EuLisp, constructed by
    [[file:EuLisp-0.991/html/eulispcl18.html#dx23-942002][=defgeneric=]].  Methods are added to them by defmethod (unlike some other
    systems, a generic function must be created by defgeneric before [[file:EuLisp-0.991/html/eulispcl18.html#dx23-951002][=defmethod=]]
    will work.)
    #+BEGIN_SRC eulisp
    (defgeneric foo (a b))

    (defmethod foo ((a <integer>) (b <integer>))
      (list 'int 'int))

    (defmethod foo ((x <float>) (y <float>))
      (list 'float 'float))
    #+END_SRC
    This defines a generic of two arguments, and two methods.  So
    #+BEGIN_SRC eulisp
    (foo 4 5)     -> (int int)
    (foo 1.0 2.0) -> (float float)
    (foo 2 2.0)   -> error, "no applicable methods"
    #+END_SRC
    The methods discriminate off all the arguments, working left to right.
    Adding another method
    #+BEGIN_SRC eulisp
    (defmethod foo ((n <number>) (m <number>))
      (list 'num 'num))
    #+END_SRC
    we get =(foo 2 2.0) -> (num num)=.  Generally the most specific method for a
    given set of arguments is the method that is executed in a generic call.
    The next most specific method can be invoked by using =(call-next-method)=
    in the body of the current method.

* Threads
  EuLisp supports multiple threaded programming by supplying some basic thread
  primitives.

  To make a thread use
  #+BEGIN_SRC eulisp
  (make-thread fn)
  #+END_SRC
  which returns a thread object (another first-class object).  The fn is the
  function that the thread will start executing when it and when starts running.

  A thread will not run until it is started
  #+BEGIN_SRC eulisp
  (thread-start thr arg arg ...)
  #+END_SRC
  This function takes a thread thr and starts executing the function =fn= (from
  =make-thread=) on the arguments =arg=.  That is, it starts executing =(fn arg
  arg ...)=.

  Or it would start executing the thread if there were enough processors to do
  so.  As is most likely, the thread is simply marked as ready to run whenever
  the resource is available.  The EuLisp model requires the programmer to write
  in such a manner that does not presume any particular number of processors are
  available.  Even if there is just one processor, the program should be written
  to work.  To aid this, there is the function
  #+BEGIN_SRC eulisp
  (thread-reschedule)
  #+END_SRC
  which will suspend the current thread, and allow another to run in its place.
  If there are enough processors so that all threads are running, then
  thread-reschedule could have no effect at all.

  An single-threaded implementation such as EuXLisp requires a sprinkling of
  thread-reschedules for a parallel program to work.

  Threads are often used for their effect, but they can also return a value.
  #+BEGIN_SRC eulisp
  (thread-value thr)
  #+END_SRC
  will suspend the calling thread (and allow another to run in its place) until
  the thread thr returns a value (and returns what the thr returned).  A thread
  can return a value simply by returning from its initial function (=fn=,
  above).

*** Semaphores
    EuLisp provides simple binary semaphores, named locks, with functions
    =make-lock= to make one, lock to gain a semaphore, and unlock to release.

    Locking a locked lock will suspend the calling thread (and allow another to
    run) until some other thread releases the lock.

* Input and Output
  + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-774002][=read=]] to read a Lisp expression.
  + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-801002][=write=]] write to standard output in a way that can be re-read if possible.
    Thus, for example, strings are quoted.
  + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-817002][=prin=]] print to standard output in a human-friendly manner.  Strings and
    such are not quoted.  Compare
    #+BEGIN_SRC eulisp
        (prin "asd")    prints: asd
        (write "asd")   prints: "asd"
    #+END_SRC
  + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-825002][=print=]] as [[file:EuLisp-0.991/html/eulispcl17.html#dx21-817002][=prin=]], with a newline.
  + Print and write functions are n-ary:
    #+BEGIN_SRC eulisp
        (prin "one = " 1 ", two = " 2)    prints: one = 1, two = 2
        (write "one = " 1 ", two = " 2)   prints: "one = "1", two = "2
    #+END_SRC
  + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-832002][=newline=]] output a newline.

  All of the above have variants beginning with an 's' which take a stream to
  print on as the first argument.

  For stream manipulation:
  + open-input-file takes a string, and opens and returns a corresponding
    stream for input.  Returns [[file:EuLisp-0.991/html/eulispcl17.html#dx21-609010][=()=]] if not such file exists.
  + open-output-file creates a file if it didn't already exist.
  + open-update-file opens for append.
  + get-file-position and =(setter get-file-position)= move the file pointer in
    a file opened for update.
  + close-stream closes an open stream.

*** Format
    A more complicated printing function is [[file:EuLisp-0.991/html/eulispcl17.html#dx21-575002][=sformat=]], which is somewhat akin to
    C's =printf=.
    #+BEGIN_SRC eulisp
    (sformat stream format-string arg arg ...)
    #+END_SRC
    The variants [[file:EuLisp-0.991/html/eulispcl17.html#dx21-577002][=format=]] and [[file:EuLisp-0.991/html/eulispcl17.html#dx21-579002][=fmt=]] do not take a stream argument and the former
    prints to standard output and the latter returns the formatted output as a
    string.

    The format string is copied to the output, except that =~= marks an escape
    (like C's =%=):
    + =~a= output the next arg using [[file:EuLisp-0.991/html/eulispcl17.html#dx21-817002][=prin=]]
    + =~s= output the next arg using [[file:EuLisp-0.991/html/eulispcl17.html#dx21-801002][=write=]]
    + =~%= output a newline
    + =~~= output a =~=
    + =~c= output a character
    + =~d= output an integer
    + =~e= =~f=, =~g= floating point formats
    + =~t= output a tab

    There are other escapes to write integers in other bases, output new pages,
    and so on.

    [[file:EuLisp-0.991/html/eulispcl17.html#dx21-579002][=fmt=]] can be used with the n-ary print and write functions to write complex
    formatted output statements in a more readable form that using [[file:EuLisp-0.991/html/eulispcl17.html#dx21-577002][=format=]]
    \e.g.\
    #+BEGIN_SRC eulisp
        (print "one = " 1 ", x = " (fmt "~e" 0.000002)) prints: one = 1, x = 2.000000e-06
    #+END_SRC

* Macros
  EuLisp employs the usual backquoted template style of macros.
  #+BEGIN_SRC eulisp
  (defmacro first (x)
    `(car ,x))
  #+END_SRC
  Note that a macro cannot be used in the module where it is defined: a module
  must be fully macroexpanded before it can be compiled.  If you don't know what
  is and what isn't a macro beforehand, it is very difficult to do this.  Thus a
  module containing
  #+BEGIN_SRC eulisp
  (defmacro second (x)
     `(cadr ,x))

  (defun foo (x) (+ 1 (second x)))
  #+END_SRC
  is doomed to failure by this restriction.

  There is a wrinkle in the way that macros interact with modules: suppose a
  macro expands into something that refers to bindings that are not imported
  into the current module?
  #+BEGIN_SRC eulisp
  (defmodule one
    (import (level0))

    (defmacro foo (x)
       `(car (bar ,x)))

    (defun bar (a) ...)

    (export foo)
  )
  #+END_SRC
  Here the module =one= exports foo only, but =foo= expands into a reference to
  =bar=.
  #+BEGIN_SRC eulisp
  (defmodule two
    (import (level0))

    ...
    (foo 4)
    ...
  )
  #+END_SRC
  In the macroexpansion of module =two=, a reference to bar would appear, but
  bar is not defined in =two=.  Worse, maybe =bar= was defined in =two=: which
  =bar= does the macroexpanded form refer to? The =bar= from =one= or the =bar=
  from =two=?

  The answer is "the right =bar=", that is that =bar= in the module of macro
  definition, not the =bar= in the module of macro use.  EuXLisp takes care of
  all of this transparently for you: essentially every symbol remembers which
  module it was defined in, and always refers back to that module for its value.

  This provides a simple solution to the "macro hygene" problem that has always
  plagued Lisp macros.

  Sometimes you do want a symbol to be captured in the module of use: EuXLisp
  provides a facility to allow you to do this.
  #+BEGIN_SRC eulisp
  (defmacro while (test .  body)
    `(let/cc {break}
       (labels
         ((loop ()
            (when ,test
                  ,@body
                  (loop))))
         (loop))))
  #+END_SRC
  The symbol loop cannot be captured by the code in body, while the symbol break
  is intended to be captured.  The curly braces about the symbol indicates that
  it is to be interpreted as coming from the module of use, not the module of
  definition.  Thus, a reference to break in the body will refer to the binding
  in the [[file:EuLisp-0.991/html/eulispcl16.html#dx20-272002][=let/cc=]].

  Notice that =(eq 'break '{break}) -> t=.  As symbols they are [[file:EuLisp-0.991/html/eulispcl17.html#dx21-431004][=eq=]], but as
  identifiers they are q
* Miscellany
*** Keywords
    There are keywords (unbindable, unassignable, self-evaluating symbols),
    /e.g./,
    #+BEGIN_SRC eulisp
    (defclass foo ()
      ((a default: 99
          keyword: a:
          accessor: foo-a))
      constructor: (make-foo a:))
    #+END_SRC

*** Comparisons
    EuLisp has the usual tests for equality:
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-431004][=eq=]] for identity
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-435002][=eql=]] for identity integers and characters
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-438002][=binary==]] generic function with methods for most types
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-446002][===]] n-ary equality which calls [[file:EuLisp-0.991/html/eulispcl17.html#dx21-438002][=binary==]] for each pair

    Note that
    #+BEGIN_SRC eulisp
    (eql 1 1.0)  -> ()
    (= 1 1.0)      -> t
    #+END_SRC
    There is also the usual [[file:EuLisp-0.991/html/eulispcl17.html#dx21-450002][=<=]], [[file:EuLisp-0.991/html/eulispcl17.html#dx21-454002][=<==]], [[file:EuLisp-0.991/html/eulispcl17.html#dx21-452002][=>=]], [[file:EuLisp-0.991/html/eulispcl17.html#dx21-456002][=>==]], which are n-ary:
    #+BEGIN_SRC eulisp
    (< a b c ...)
    #+END_SRC
    returns [[file:EuLisp-0.991/html/eulispcl16.html#dx20-210002][=t=]] when =a=, =b=, =c=, etc., form a strictly increasing sequence.
    Similarly [[file:EuLisp-0.991/html/eulispcl17.html#dx21-450002][=<=]]= for a non-decreasing sequence, and so on.

*** Generic Arithmetic
    The arithmetic operators [[file:EuLisp-0.991/html/eulispcl17.html#dx21-655004][=+=]] and so on are all n-ary, i.e., take a variable
    number of arguments.  Each operator is defined in terms of a binary generic
    function: [[file:EuLisp-0.991/html/eulispcl17.html#dx21-685002][=binary+=]] for [[file:EuLisp-0.991/html/eulispcl17.html#dx21-655004][=+=]], [[file:EuLisp-0.991/html/eulispcl17.html#dx21-689002][=binary*=]] for [[file:EuLisp-0.991/html/eulispcl17.html#dx21-659002][=*=]], etc.  The n-ary form is just
    a repeated application of the binary form
    #+BEGIN_SRC eulisp
    (+ a b c ...) = ((..(binary+ (binary+ a b) c) ...))
    #+END_SRC
    Methods can be added to the binary operators
    #+BEGIN_SRC eulisp
    (defmethod binary+ ((a <symbol>) (b <symbol>))
      ...)
    #+END_SRC
    and then you can use [[file:EuLisp-0.991/html/eulispcl17.html#dx21-655004][=+=]] to add symbols: =(+ 'a 'b 'c)=.

    There are also generic functions =unary-= and =unary/= for the unary =(- x)=
    and =(/ x)= (reciprocal).

    Similarly, the comparators [[file:EuLisp-0.991/html/eulispcl17.html#dx21-450002][=<=]], [[file:EuLisp-0.991/html/eulispcl17.html#dx21-452002][=>=]], [[file:EuLisp-0.991/html/eulispcl17.html#dx21-454002][=<==]] etc., are all defined in terms of
    the two generic functions [[file:EuLisp-0.991/html/eulispcl17.html#dx21-443002][=binary<=]] and [[file:EuLisp-0.991/html/eulispcl17.html#dx21-438002][=binary==]].

*** Local Functions
    Just like [[file:EuLisp-0.991/html/eulispcl16.html#dx20-289003][=let=]] introduces local variables, the [[file:EuLisp-0.991/html/eulispcl16.html#dx20-286002][=labels=]] form can introduce
    local functions.
    #+BEGIN_SRC eulisp
    (labels
      ((foo (a b)
         ...  (bar a) ...  )
       (bar (x)
         ...  (foo x (bar x)) ...  ))
      ...
      (foo 3 4)
      ...
    )
    #+END_SRC
    The [[file:EuLisp-0.991/html/eulispcl16.html#dx20-286002][=labels=]] takes a list of function definitions.  They may be self and
    mutually recursive.  These functions may be used within the body of the
    [[file:EuLisp-0.991/html/eulispcl16.html#dx20-286002][=labels=]] just like global functions.  Iterating functions are often most
    conveniently written in terms of [[file:EuLisp-0.991/html/eulispcl16.html#dx20-286002][=labels=]] as the bodies of the function
    definitions can refer to local variables:
    #+BEGIN_SRC eulisp
    (let ((a 1))
      (labels
        ((addit (x)
           (if (null x)
               ()
               (cons (+ a (car x)) (addit (cdr x))))))
        (addit '(1 2 3))))
    ->
    (2 3 4)
    #+END_SRC

*** Mapping and Collections
    There are several functions supplied to iterate along collections.
    Collections include =lists=, =vectors=, =strings=, and =tables=.

    The generic function [[file:EuLisp-0.991/html/eulispcl17.html#dx21-390002][=map=]] takes a function and a collection
    #+BEGIN_SRC eulisp
    (map list '(1 2 3))   -> ((1) (2) (3))
    (map - #(4 5 6))      -> #(-4 -5 -6)
    #+END_SRC
    or more than one collection
    #+BEGIN_SRC eulisp
    (map cons '(a b c) '(A B C))     -> ((a .  A) (b .  B) (c .  C))
    (map + #(1 2 3) #(10 10 10 10))  -> #(11 12 13)
    #+END_SRC
    The mapping stops when any collection runs out.  Even a mixture will work
    #+BEGIN_SRC eulisp
    (map * '(2 4 6) #(1 -1 1))  -> (2 -4 6)
    (map * #(2 4 6) '(1 -1 1))  -> #(2 -4 6)
    #+END_SRC
    The type of collection returned is the same as the first collection
    argument.

    If you don't need a return value, but are iterating purely for effect, use
    do
    #+BEGIN_SRC eulisp
    (do print '(1 2 3))
    #+END_SRC
    Other iterators include [[file:EuLisp-0.991/html/eulispcl17.html#dx21-348020][=accumulate=]]
    #+BEGIN_SRC eulisp
    (accumulate list () #(a b c))      -> (((() a) b) c)
    (accumulate * 1 '(1 2 3 4 5 6 7))  -> 5040
    #+END_SRC

    which takes a function, an initial value, an a collection to iterate over.

    You can find the size of any collection using the function size.  This
    returns the length of a list of string, number of elements of a vector, and
    so on.  It can be reversed by reverse; an element removed by remove
    (non-destructive) or by delete (destructive); find an element by (member elt
    collection).  The last three (remove, delete and member) take an optional
    last argument that is a test for equality: it is this test that is used when
    looking for an element in the collection.  It defaults to eql.

    The function concatenate can be used to join collections:
    #+BEGIN_SRC eulisp
    (concatenate '(1 2 3) '(4 5 6))  -> (1 2 3 4 5 6)
    (concatenate "abc" "def")        -> "abcdef"
    (concatenate '(1 2 3) #(4 5 6))  -> (1 2 3 4 5 6)
    #+END_SRC

*** Loops
    EuLisp doesn't really need loops, as everything can be written easily in
    terms of tail recursive functions.  However, EuXLisp sneaks in a while loop:
    #+BEGIN_SRC eulisp
    (while bool
       expr
       expr
       ...
    )
    #+END_SRC
    which loops while the bool returns =true=.

*** Tables
    EuLisp uses tables for a general association mechanism.  EuXLisp implements
    tables as hash tables, but in general they could be implemented differently.
    + =make-table= returns a table.
    + =(table-ref table key)= to retrieve a value, =((setter table-ref) table
      key value)= to update.
    + =(table-delete key)= to remove a value.
    + =table-keys= to get a list of current keys.
    + =table-values= to get a list of current values.
    + =table-clear= to completely empty a table.

    When looking for a match to a key in a table, the system defaults to [[file:EuLisp-0.991/html/eulispcl17.html#dx21-435002][=eql=]].
    You can change this by using =(make-table comparator)=, where =comparator=
    is [[file:EuLisp-0.991/html/eulispcl17.html#dx21-431004][=eq=]] or [[file:EuLisp-0.991/html/eulispcl17.html#dx21-435002][=eql=]] or [[file:EuLisp-0.991/html/eulispcl17.html#dx21-438002][=binary==]] or [[file:EuLisp-0.991/html/eulispcl17.html#dx21-446002][===]].

    If a value is not found for a particular key in the table [[file:EuLisp-0.991/html/eulispcl17.html#dx21-609010][=()=]] is returned.
    This can be changed by =(make-table comparator fill-value)=.  Now
    =fill-value= will be returned on failure.

    The mapping functions above work on tables, too.

*** Non-local exits
    EuLisp supports a limited form of continuation capture via [[file:EuLisp-0.991/html/eulispcl16.html#dx20-272002][=let/cc=]].  This
    form captures its continuation, and allows its use as a non-local exit.
    #+BEGIN_SRC eulisp
    (let/cc out
       ...
       (out)
       ...
    )
    ;; after
    #+END_SRC
    This stores the continuation (i.e., from 'after') in the variable =out=.
    This can be called as a function, whereupon control passes immediately to
    that continuation.  The value of out can only be used in this way in the
    dynamic scope of the [[file:EuLisp-0.991/html/eulispcl16.html#dx20-272002][=let/cc=]] form: outside the value is 'dead' and no
    longer usable.

    The continuation function can take a single optional argument which is a
    value to pass to the continuation: the default is [[file:EuLisp-0.991/html/eulispcl17.html#dx21-609010][=()=]].

    The forms [[file:EuLisp-0.991/html/eulispcl16.html#dx20-278002][=block=]] and [[file:EuLisp-0.991/html/eulispcl16.html#dx20-282002][=return-from=]] are simply =let/c=c and a call to a
    continuation:
    #+BEGIN_SRC eulisp
    (block foo
      ...
      (return-from foo)
      ...
    )
    #+END_SRC
    The unwind-protect form ensures things are executed even if there is a
    non-local exit
    #+BEGIN_SRC eulisp
    (unwind-protect
      protected-form
      after-form
      after-form
      ...)
    #+END_SRC

    This starts by executing the =protected-form=.  If there is no unusual exit
    from the =protected-form=, this will then execute the =after-forms= and will
    return whatever value the =protected-form= returned.  If there is a
    non-local exit from the =protected-form= to a continuation outside the
    [[file:EuLisp-0.991/html/eulispcl16.html#dx20-299002][=unwind-protect=]], the =after-forms= will still be executed before the
    control passes to the continuation.

*** Setters
    Structures, like =lists=, =vectors= and [[file:EuLisp-0.991/html/eulispcl18.html#dx23-935001][=class=]] instances have elements that
    can be accessed.  The elements of a [[file:EuLisp-0.991/html/eulispcl17.html#dx21-911005][=vector=]] can be read by =vector-ref=.
    To write to an element use the function =(setter vector-ref)=,
    #+BEGIN_SRC eulisp
    ((setter vector-ref) vec index val)
    #+END_SRC
    Similarly, the accessor [[file:EuLisp-0.991/html/eulispcl17.html#dx21-626002][=car=]] has an updater =(setter car)= (often called
    =rplaca= in other Lisps), and so on.  In general a reader function =r= will
    have an associated updater =(setter r)=.

    The function [[file:EuLisp-0.991/html/eulispcl16.html#dx20-249002][=setter=]] is a simple association mechanism: =setter= is a
    function that takes a reader and returns the associated writer.  To make
    such an association between functions =r= and =w= just use [[file:EuLisp-0.991/html/eulispcl16.html#dx20-249002][=setter=]] again
    #+BEGIN_SRC eulisp
    ((setter setter) r w)
    #+END_SRC
    In fact, no particular properties of =r= and =w=, are used, so this can be
    used as a general facility.  Further, setter functions, generic functions
    and methods can be defined directly:
    #+BEGIN_SRC eulisp
    (defun (setter foo) (a b)
      ...)
    #+END_SRC

*** Convert
    The function [[file:EuLisp-0.991/html/eulispcl17.html#dx21-463004][=convert=]] is used to change an object of one type into an
    object of another type.  Thus to convert an [[file:EuLisp-0.991/html/eulispcl17.html#dx21-582005][=integer=]] to a [[file:EuLisp-0.991/html/eulispcl17.html#dx21-542005][=float=]]
    #+BEGIN_SRC eulisp
    (convert 1 <float>) -> 1.0
    #+END_SRC
    or the other way
    #+BEGIN_SRC eulisp
    (convert 2.6 <integer>) -> 2
    #+END_SRC

    Many other conversions are available: [[file:EuLisp-0.991/html/eulispcl17.html#dx21-582005][=integer=]] to [[file:EuLisp-0.991/html/eulispcl17.html#dx21-857005][=string=]]; [[file:EuLisp-0.991/html/eulispcl17.html#dx21-322005][=character=]] to
    [[file:EuLisp-0.991/html/eulispcl17.html#dx21-857005][=string=]]; =string= to =number=; [[file:EuLisp-0.991/html/eulispcl17.html#dx21-883005][=symbol=]] to =string=; [[file:EuLisp-0.991/html/eulispcl17.html#dx21-641002][=list=]] to [[file:EuLisp-0.991/html/eulispcl17.html#dx21-911005][=vector=]];
    and so on.

*** Copying
    There are two functions that copy structures: [[file:EuLisp-0.991/html/eulispcl17.html#dx21-476004][=deep-copy=]] and
    [[file:EuLisp-0.991/html/eulispcl17.html#dx21-483002][=shallow-copy=]].  The second recursively descends a structure making copies
    of all the elements in the structure; the first makes a single copy of the
    top-level structure, and fills its slots will the existing elements:
    #+BEGIN_SRC eulisp
    (setq a '((1 2) (3 4)))
    (setq d (deep-copy a))
    (eq a d)                  -> ()
    (binary= a d)             -> t
    (eq (car a) (car d))      -> ()

    (setq s (shallow-copy a))
    (eq a s)                  -> ()
    (binary= a s)             -> t
    (eq (car a) (car s))      -> t
    #+END_SRC

*** Other Tools
    Other tools that EuXLisp provides:
    + =describe= gives a little information about an object, e.g., =(describe
      <integer>)= or =(describe 4)=
    + =trace= can be used to print a message every time a function is entered or
      exited.  Thus
      #+BEGIN_SRC eulisp
      (trace foo)
      #+END_SRC
      will describe the ins and outs of the function =foo=.  To untrace, use
      =(untrace foo)=.  Use =(import "trace")= to load trace.

* Example Modules
  EuXLisp provides a few sample modules.
*** Trace
    The trace module has been mentioned above.

*** Linda
    The eulinda module implements the Linda pool mechanism.
    + =make-linda-pool= returns a new pool
    + =(linda-out pool tag val val ...)= writes the tuple =(val val ...)= under
      the tag to the pool
    + =(linda-in pool tag pat pat ...)= attempts to read a tuple matching the
      pattern =(pat pat ...)= from the pool.  If no matching tuple exists in the
      pool, the call will block until such a tuple appears.  When found, the
      tuple is removed from the pool.  A pattern is a literal value, to be
      matched exactly =(? var)= to match any value, and assign the matched value
      to the variable =?= to match any value, and to discard the result.
    + =linda-read= as =linda-in= but does not remove the tuple from the pool
    + =(linda-eval fun arg arg ...)= starts a new thread, running the function
      with the arguments.

    Debugging tools are =print-linda-pool= to print the curent values in a pool,
    and =(tril t)= to print some trace information as the system is running.

    The =tag= must be a [[file:EuLisp-0.991/html/eulispcl17.html#dx21-883005][=symbol=]] or =number=.

*** Modular Numbers
    The module =modular= is a simple implementation of modular integers.  The
    function mod constructs a modular number
    #+BEGIN_SRC eulisp
    (setq a (mod 3 5))  -> #<3 mod 5>
    (setq b (+ a a))    -> #<1 mod 5>
    (/ a)               -> #<2 mod 5>
    #+END_SRC

*** Scheme
    This module provides a mostly-conformant Scheme environment.  It is probably
    not wise to mix Scheme constructs, such as call/cc, with EuLisp constructs,
    such as threads.

*** Paralation Lisp
    This emulates a paralation system.  The module =tpl= (for tiny paralation
    lisp) exports
    + =(make-paralation n)= to make a new paralation of size =n=.  This returns
      a index field of the new paralation.
    + elwise is the element-wise operator:
      #+BEGIN_SRC eulisp
      (elwise (a b) (+ a b))
      #+END_SRC
      where =a= and =b= are fields on the same paralation.
    + =(match field field)= to create a map between fields, and
    + =(move field map combine default)= to move a field down a map, using
      combine, (a function taking an appropriate number of arguments) to combine
      elements that end up at the same element of the target field, and default
      as the default value for a field element that is not in the image of the
      map.

*** Values
    This is an emulation of Scheme and Common Lisp's multiple values.  The
    module values exports
    + =(values val val ...)= as the basic multiple value return
    + =call-with-values= for the Scheme-like values:
      #+BEGIN_SRC eulisp
      (call-with-values
        (lambda () ...)             ; a thunk returning values
        (lambda (a b c ...) ...))   ; that are passed here, bound
                                    ; to a, b, etc.
      #+END_SRC
    + =multiple-value-setq=; =multiple-value-list=; =multiple-value-call=;
      =values-list=; =multiple-value-bind= are all as in Common Lisp.

    If you pass multiple values to a continuation that only expects a single
    value you will probably get strange results.

*** Sort
    A fast stable merge sort.  The module sort exports [[file:EuLisp-0.991/html/eulispcl17.html#dx21-410002][=sort=]] (non-destructive)
    and =sort!= (destructive).  They are called as =(sort l)=, where =l= is a
    list of values to be sorted.  The comparison operator used is [[file:EuLisp-0.991/html/eulispcl17.html#dx21-450002][=<=]].
    Alternatively, you can use =(sort l comp)=, where comp is a comparator
    function.

* EuXLisp functions
  Here is a summary of the functions available in EuXLisp.  Not all of these
  correspond to EuLisp.
*** Special operators
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-211007][=deflocal=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-207002][=defconstant=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-215002][=quote=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-221002][=lambda=]]
    + =delay=
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-289003][=let=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-292004][=let*=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-245003][=setq=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-259002][=if=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-262002][=cond=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-295004][=progn=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-265004][=and=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-268004][=or=]]
    + =while=
    + [[file:EuLisp-0.991/html/eulispcl10.html#dx12-68001][=export=]]
    + [[file:EuLisp-0.991/html/eulispcl10.html#dx12-70001][=expose=]]
    + =enter-module=
    + =!>=
    + =reenter-module=
    + =!>>=
    + [[file:EuLisp-0.991/html/eulispcl11.html#dx13-97003][=call-next-method=]]
    + [[file:EuLisp-0.991/html/eulispcl11.html#dx13-100003][=next-method?=]]
    + [[file:EuLisp-0.991/html/eulispcl18.html#dx23-932002][=defclass=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-240002][=apply=]]
    + =map-list=
    + =load=
    + =load-noisily=
    + =force=

*** List functions
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-624002][=cons=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-626002][=car=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-628002][=cdr=]]
    + =caar=
    + =cadr=
    + =cdar=
    + =cddr=
    + =caaar=
    + =caadr=
    + =cadar=
    + =caddr=
    + =cdaar=
    + =cdadr=
    + =cddar=
    + =cdddr=
    + =caaaar=
    + =caaadr=
    + =caadar=
    + =caaddr=
    + =cadaar=
    + =cadadr=
    + =caddar=
    + =cadddr=
    + =cdaaar=
    + =cdaadr=
    + =cdadar=
    + =cdaddr=
    + =cddaar=
    + =cddadr=
    + =cdddar=
    + =cddddr=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-641002][=list=]]
    + =list*=
    + =append=
    + =last-pair=
    + =length=
    + =memv=
    + =memq=
    + =assv=
    + =assq=
    + =list-ref=
    + =list-tail=

*** Symbol functions
    + =bound?=
    + =symbol-value=
    + =symbol-plist=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-887002][=gensym=]]
    + =get=
    + =put=

*** Vector functions
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-911005][=vector=]]
    + =make-vector=
    + =vector-length=
    + =vector-ref=

*** Array functions
    + =make-array=
    + =array-ref=

*** Predicates
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-610007][=null?=]]
    + =atom=
    + =list?=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-651013][=number?=]]
    + =boolean?=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-620007][=cons?=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-885002][=symbol?=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-592002][=keyword?=]]
    + =complex?=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-543021][=float?=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-491069][=double-float?=]]
    + =rational?=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-583039][=integer?=]]
    + =char?=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-860002][=string?=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-914002][=vector?=]]
    + =function?=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-704012][=stream?=]]
    + =input-stream?=
    + =output-stream?=
    + =object?=
    + =eof-object?=
    + =default-object?=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-431004][=eq=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-435002][=eql=]]

*** Arithmetic functions
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-673002][=zero?=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-679002][=positive?=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-681002][=negative?=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-587002][=odd?=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-585002][=even?=]]
    + =exact?=
    + =inexact?=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-551002][=truncate=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-547002][=floor=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-545002][=ceiling=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-549002][=round=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-671002][=abs=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-667002][=gcd=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-669002][=lcm=]]
    + =random=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-655004][=+=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-657002][=-=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-659002][=*=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-661002][=/=]]
    + =quotient=
    + =remainder=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-460002][=min=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-458002][=max=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-521002][=sin=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-519003][=cos=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-523002][=tan=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-513003][=asin=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-511002][=acos=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-515003][=atan=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-531002][=exp=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-539004][=sqrt=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-537004][=pow=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-533003][=log=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-685002][=binary+=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-687002][=binary-=]]
    + =unary-=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-689002][=binary*=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-691002][=binary/=]]
    + =unary/=
    + =binary%=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-697003][=binary-gcd=]]

*** Bitwise logical functions
    + =logand=
    + =logior=
    + =logxor=
    + =lognot=

*** Numeric comparison functions
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-450002][=<=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-450002][=<=]]=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-446002][===]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-452002][=>=]]=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-452002][=>=]]

*** String functions
    + =make-string=
    + =string-length=
    + =string-null?=
    + =string-append=
    + =string-ref=
    + =substring=

*** I/O functions
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-774002][=read=]]
    + =read-char=
    + =read-byte=
    + =read-short=
    + =read-long=

    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-797002][=swrite=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-801002][=write=]]
    + =write-char=
    + =write-byte=
    + =write-short=
    + =write-long=

    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-813002][=sprin=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-821002][=sprint=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-817002][=prin=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-825002][=print=]]

    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-832002][=newline=]]
    + =char-ready?=
    + =peek-char=

*** Print control functions
    + =print-breadth=
    + =print-depth=

*** File I/O functions
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-848002][=open-input-file=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-850002][=open-output-file=]]
    + =open-append-file=
    + =open-update-file=
    + =close-stream=
    + =close-input-stream=
    + =close-output-stream=
    + =get-file-position=
    + =unlink=

*** Standard streams
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-743002][=stdin=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-745002][=stdout=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-746002][=stderr=]]

    + =; utility functions=
    + =transcript-on=
    + =transcript-off=
    + =getarg=
    + =prompt?=
    + =exit=
    + =compile=
    + =decompile=
    + =gc=
    + =save=
    + =restore=

*** Debugging functions
    + =trace-on=
    + =trace-off=

*** Module functions
    + =module-symbols=
    + =module-exports=
    + =symbol-module=
    + =current-module=
    + =module-list=
    + =unintern=

*** Telos
    + [[file:EuLisp-0.991/html/eulispcl18.html#dx23-1016002][=allocate=]]
    + =describe=
    + =class?=
    + =subclass?=

*** Tables
    + =make-table=
    + =table-ref=
    + =table-comparator=
    + =table-delete=
    + =table-length=
    + =table-keys=
    + =table-values=
    + =table-fill=
    + =table-clear=

*** Plus some others
    + =binary=
    + =text=
    + =not=
    + =prin1=
    + =princ=
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-210002][=t=]]
    + =eval=
    + =system=
    + =getenv=
    + =putenv=
    + =tmpfile=
    + =current-time=
    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-143002][=ticks-per-second=]]
    + =backtrace=
    + =backtrace?=

*** Thread
    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-121003][=<thread>=]]
    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-160002][=<simple-thread>=]]
    + =make-thread=
    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-122002][=thread?=]]
    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-124002][=thread-reschedule=]]
    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-127002][=current-thread=]]
    + =thread-kill=
    + =thread-queue=
    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-127002][=current-thread=]]
    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-128002][=thread-start=]]
    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-131002][=thread-value=]]
    + =thread-state=
    + =<thread-condition>=
    + =<thread-error>=
    + =<thread-already-started>=

    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-150003][=<lock>=]]
    + =<simple-lock>=
    + =make-lock=
    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-150007][=lock?=]]
    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-152002][=lock=]]
    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-156002][=unlock=]]
    + =<lock-condition>=
    + =<lock-error>=

    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-135002][=wait=]]
    + =<wait-condition>=
    + =<wait-error>=

    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-272002][=let/cc=]]
    + [[file:EuLisp-0.991/html/eulispcl15.html#dx19-192002][=with-handler=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-299002][=unwind-protect=]]
    + =<wrong-condition-class>=
    + [[file:EuLisp-0.991/html/eulispcl15.html#dx19-186003][=signal=]]
    + [[file:EuLisp-0.991/html/eulispcl15.html#dx19-198002][=error=]]
    + [[file:EuLisp-0.991/html/eulispcl15.html#dx19-201002][=cerror=]]

*** Telos
    + [[file:EuLisp-0.991/html/eulispcl11.html#dx13-76003][=<object>=]]
    + [[file:EuLisp-0.991/html/eulispcl11.html#dx13-76007][=<class>=]]
    + [[file:EuLisp-0.991/html/eulispcl18.html#dx23-964002][=<simple-class>=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-609006][=<list>=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-620002][=<cons>=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-610003][=<null>=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-651010][=<number>=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-583035][=<integer>=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-554035][=<fpi>=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-543017][=<float>=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-491061][=<double-float>=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-884006][=<symbol>=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-591006][=<keyword>=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-858017][=<string>=]]
    + =<simple-string>=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-703002][=<stream>=]]
    + =<input-stream>=
    + =<output-stream>=
    + =<i/o-stream>=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-912006][=<vector>=]]
    + =<simple-vector>=
    + =<char>=
    + =<simple-char>=
    + =<promise>=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-904005][=<table>=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-910002][=<hash-table>=]]
    + [[file:EuLisp-0.991/html/eulispcl11.html#dx13-84002][=<function>=]]
    + [[file:EuLisp-0.991/html/eulispcl11.html#dx13-84006][=<simple-function>=]]
    + =<subr>=
    + =<continuation>=
    + =<generic>=
    + =<simple-generic>=
    + [[file:EuLisp-0.991/html/eulispcl18.html#dx23-996008][=<method>=]]
    + [[file:EuLisp-0.991/html/eulispcl18.html#dx23-996011][=<simple-method>=]]
    + [[file:EuLisp-0.991/html/eulispcl18.html#dx23-971002][=<slot>=]]
    + [[file:EuLisp-0.991/html/eulispcl18.html#dx23-971005][=<local-slot>=]]
    + =<structure>=

    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-809003][=generic-prin=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-790002][=generic-write=]]
    + [[file:EuLisp-0.991/html/eulispcl12.html#dx16-135002][=wait=]]

    + [[file:EuLisp-0.991/html/eulispcl11.html#dx13-104004][=make=]]
    + [[file:EuLisp-0.991/html/eulispcl11.html#dx13-110002][=initialize=]]
    + =class-hierarchy=

*** Setter
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-249002][=setter=]]

*** Converter
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-469002][=converter=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-463004][=convert=]]
    + =<conversion-condition>=
    + =<no-converter>=

*** Condition
    + [[file:EuLisp-0.991/html/eulispcl14.html#dx18-162002][=defcondition=]]
    + [[file:EuLisp-0.991/html/eulispcl14.html#dx18-167002][=condition?=]]
    + =condition-message=
    + =condition-value=
    + [[file:EuLisp-0.991/html/eulispcl14.html#dx18-165002][=<condition>=]]
    + =<telos-condition>=
    + =<telos-error>=
    + =<telos-general-error>=
    + =<telos-bad-ref>=
    + =<no-applicable-method>=
    + =<no-next-method>=
    + =<incompatible-method-domain>=
    + =<arithmetic-condition>=
    + =<arithmetic-error>=
    + =<error>=
    + =<general-error>=
    + =<bad-type>=
    + =<unbound-error>=
    + =<compilation-error>=
    + =<macro-error>=
    + =<syntax-error>=
    + =<user-interrupt>=

*** Compare
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-443002][=binary<=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-438002][=binary==]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-450002][=<=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-446002][===]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-452002][=>=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-450002][=<=]]=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-452002][=>=]]=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-458002][=max=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-460002][=min=]]
    + =assoc=

*** Macros
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-225003][=defmacro=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-305004][=quasiquote=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-308002][=unquote=]]
    + [[file:EuLisp-0.991/html/eulispcl16.html#dx20-311002][=unquote-splicing=]]
    + =symbol-macro=
    + =macroexpand=
    + =macroexpand1=

*** Collect
    + =<collection-condition>=
    + =<collection-error>=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-357002][=collection?=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-404002][=sequence?=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-348020][=accumulate=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-351002][=accumulate1=]]
    + =all?=
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-354002][=any?=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-360002][=concatenate=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-364002][=delete=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-367002][=do=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-370002][=element=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-375002][=empty?=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-378002][=fill=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-390002][=map=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-393002][=member=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-396002][=remove=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-399002][=reverse=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-407002][=size=]]
    + =slice=

*** Copy
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-476004][=deep-copy=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-483002][=shallow-copy=]]

*** Format
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-575002][=sformat=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-577002][=format=]]
    + [[file:EuLisp-0.991/html/eulispcl17.html#dx21-579002][=fmt=]]

* Command Line Arguments
  The EuXLisp interpreter accepts a few arguments:
  + =-h=, =--help= Display this usage information.
  + =-q=, =--quiet= Print no messages, prompts or values.
  + =-n=, =--no-image= Do not read in the initial Lisp image.
  + =-N=, =--no-sys-calls= Disable system calls.
  + =-s= /file/, =--script= /file/ Read and execute script from /file/, see
    below.
  + =-m= /file/,  =--module= /file/ Read and execute module from /file/.
  + =-i= /file/, =--image= /file/ Read the given image /file/ rather than the
    default.
  + =-t=, =--trace=            Switch on byte-code level tracing.

  Other arguments are passed to the intepreter and are available as =(getarg 0)=
  (the name of the program), =(getarg 1)= (first argument), =(getarg 2)= (second
  argument), and so on.  The function =getarg= returns [[file:EuLisp-0.991/html/eulispcl17.html#dx21-609010][=()=]] for a non-existent
  argument.

*** Shell Scripts
    EuXLisp can be used in a shell script by means of the =--script= flag:
    #+BEGIN_SRC eulisp
    #!/usr/local/bin/euxlisp --script

    (print "hello world")
    #+END_SRC
    It is usual to use the =-q= or =--quiet= flag to prevent the echo from the
    read-eval-print loop (the default), and the =-N= or =--no-sys-calls= flag to
    prevent the use of the system function.
    #+BEGIN_SRC eulisp
    #!/usr/local/bin/euxlisp -qN --script

    (print "hello world")
    #+END_SRC

* [[http://people.bath.ac.uk/masrjb/Sources/eunotes.html][The original Euscheme notes]].
