;;; EuLisp system 'youtoo'
;;;   Interface file for module ex-expr

(definterface ex-expr
  (import (i-all p-env sx-node sx-obj ex-import ex-syntax ex-direct cg-dld)
   syntax (_macros _i-aux0 _ex-aux0)
   full-import (i-error i-notify i-param i-level1 boot1 boot symbol stream3 random handler read table table1 vector convert1 format list socket stream2 lock stream1 stream float character compare collect fpi number integer copy convert string callback let-cc dynamic thread event condition bit mop-alloc mop-access mop-prim mop-key mop-class mop-init mop-inspect mop-gf mop-meth mop-defcl telos level1 aux-table i-all sx-obj sx-obj1 sx-obj2 p-env i-ffi sx-node cg-interf i-modify ex-import ex-syntax ex-expose ex-direct cg-dld)
   export (
    ((name . *nil*) (pos . 2) (origin ex-expr . *nil*) (class . constant))
    ((name . expand-exprs) (pos . 16) (origin ex-expr . expand-exprs))
    ((name . filter-vars) (pos . 6) (origin ex-expr . filter-vars))
    ((name . expand-expr) (pos . 28) (origin ex-expr . expand-expr))
    ((name . protect-newline) (pos . 34) (origin ex-expr . protect-newline))
    ((name . protect-backslash) (pos . 3) (origin ex-expr . protect-backslash))
    ((name . complete-lambda-node) (pos . 27) (origin ex-expr . complete-lambda-node))
    ((name . filter-init-forms) (pos . 32) (origin ex-expr . filter-init-forms))
    ((name . protect-doublequote) (pos . 26) (origin ex-expr . protect-doublequote))
    ((name . get-macro-expander) (pos . 31) (origin ex-expr . get-macro-expander))
    ((name . protect-tilde) (pos . 17) (origin ex-expr . protect-tilde))
   )
   local-literals (
    (top-level . 324)
    (protect-backslash . 323)
    (check-appl-arity . 322)
    (box-binding . 321)
    (filter-vars . 320)
    (labelssetq . 319)
    (get-appl-expander . 318)
    (lambda-rest-args-p . 317)
    (expand-local-static-vars . 316)
    (get-nil-t-node . 315)
    (labelsvar . 314)
    (expand-local-static-vars* . 313)
    (get-id-expander . 312)
    (default-appl-expander . 311)
    (expand-exprs . 310)
    (protect-tilde . 309)
    (check-id-binding . 308)
    (expand-fun-form . 307)
    (get-keyword-node . 306)
    (unfold-rest-arg-appl . 305)
    (lift-appl . 304)
    (lift-let*-vars . 303)
    (expr-expander . 302)
    (protect-doublequote . 301)
    (complete-lambda-node . 300)
    (expand-expr . 299)
    (rest-args-p . 298)
    (compute-range-and-domain . 297)
    (get-macro-expander . 296)
    (filter-init-forms . 295)
    (dummy-args . 294)
    (protect-newline . 293)
    (install-expr-expander . 292)
    ("redefinition of expander ~a" . 290)
    ("\n" . 288)
    ("\n" . 287)
    ("\n" . 286)
    ("\n" . 285)
    ("RESULT: ~a" . 278)
    (execute . 277)
    ("APPLY MACRO: ~a" . 276)
    (|(method G005812)| . 275)
    ("bad macro expansion of ~a" . 273)
    ("compile time error condition: " . 272)
    ("\"" . 263)
    ("\"" . 262)
    ("\"" . 261)
    ("\"" . 260)
    ("    Expanding ~a" . 258)
    (int-binary . 251)
    (setter . 247)
    ("no lexical binding ~a available" . 246)
    (ff . 244)
    (opencoding . 243)
    ("~~" . 241)
    ("~~" . 240)
    ("~~" . 239)
    ("~~" . 238)
    (args: . 234)
    (fun: . 233)
    ("no lexical binding ~a available" . 229)
    (#f . 224)
    (#t . 223)
    (nil . 222)
    (int-zerop . 216)
    (binary= . 215)
    (binary- . 214)
    (int-binary- . 213)
    (dec . 212)
    (inc . 211)
    (binary+ . 210)
    (boot1 . 209)
    (int-binary+ . 208)
    (<= . 207)
    (int-binary= . 206)
    (>= . 205)
    (< . 204)
    (= . 203)
    (int-binary< . 202)
    (compare . 201)
    (> . 200)
    (number . 199)
    ((+ - * / %) . 198)
    (% . 197)
    (/ . 196)
    (* . 195)
    (- . 194)
    (+ . 193)
    ("  wrapping lambda in operator position: ~s" . 192)
    (arity . 187)
    ("box binding ~a" . 186)
    ("too few arguments calling ~a" . 184)
    ("too many arguments calling ~a" . 183)
    ("too few arguments calling ~a" . 182)
    ("\\" . 180)
    ("\\" . 179)
    ("\\" . 178)
    ("\\" . 177)
    (opencoded-lambda . 175)
    (named-lambda . 174)
    (lambda . 173)
    (|(method lift-setq)| . 172)
    (setq . 171)
    (|(method lift-if)| . 170)
    (call-next-method . 169)
    (|(method check-appl)| . 168)
    (lift-setq . 167)
    (lift-if . 166)
    (check-appl . 165)
    ("no applicable object ~a" . 163)
    ("macro binding ~a should be in syntax import" . 162)
    (*encl-lambda* . 155)
    ("missing else branch in (if ~a ...)" . 152)
    ("bad if syntax (if ~a ...)" . 151)
    (|(method G006259)| . 150)
    ("bad if syntax ~a" . 148)
    ("compile time error condition: " . 147)
    (else: . 144)
    (then: . 143)
    (pred: . 142)
    (if . 137)
    (value: . 132)
    (|(method G006350)| . 131)
    ("bad quote syntax" . 129)
    ("compile time error condition: " . 128)
    (quote . 125)
    (|(method G006372)| . 124)
    ("bad quasiquote syntax" . 122)
    ("compile time error condition: " . 121)
    (append . 118)
    (unquote-splicing . 117)
    (cons . 116)
    (unquote . 115)
    (quasiquote . 114)
    ("immutable binding ~a cannot be modified" . 112)
    ("no binding ~a available" . 111)
    (*clean-ups* . 110)
    (tail-pos? . 109)
    (|(method G006420)| . 108)
    ("bad setq syntax" . 106)
    ("compile time error condition: " . 105)
    ("body ~a not a list" . 94)
    (|(method G006506)| . 93)
    ("bad lambda syntax" . 91)
    ("compile time error condition: " . 90)
    ("body ~a not a list" . 87)
    ("~a" . 86)
    (|(method G006532)| . 85)
    ("bad named lambda syntax" . 83)
    ("compile time error condition: " . 82)
    ("body ~a not a list" . 79)
    (|(method G006563)| . 78)
    ("bad lambda syntax" . 76)
    ("compile time error condition: " . 75)
    ("body ~a not a list" . 72)
    (|(method G006589)| . 71)
    ("bad opencoded-lambda syntax" . 69)
    ("compile time error condition: " . 68)
    (labels . 65)
    (inlined-lambda . 64)
    (let* . 63)
    (|(method G006617)| . 62)
    ("bad let syntax" . 60)
    ("compile time error condition: " . 59)
    ("" . 55)
    (progn . 54)
    (|(method G006665)| . 53)
    ("bad let* syntax" . 51)
    ("compile time error condition: " . 50)
    (let . 47)
    (|(method G006702)| . 46)
    (anonymous . 45)
    (ct-error-value: . 43)
    ("bad labels syntax" . 42)
    ("compile time error condition: " . 41)
   )
   literals (
   )
))
