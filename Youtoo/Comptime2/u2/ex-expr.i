;;; EuLisp system 'youtoo'
;;;   Interface file for module ex-expr

(definterface ex-expr
  (import (i-all p-env sx-node sx-obj ex-import ex-syntax ex-direct cg-dld sx-write)
   syntax (_syntax-1 _i-aux0 _ex-aux0)
   full-import (i-error i-notify i-param i-level-1 boot1 boot symbol stream3 random handler read table table1 vector convert1 format list socket stream2 lock stream1 stream float character compare collect fpi number integer copy convert string callback let-cc dynamic thread event condition bit mop-alloc mop-access mop-prim mop-key mop-class mop-init mop-inspect mop-gf mop-meth mop-defcl telos level-1 aux-table i-all sx-obj sx-obj1 sx-obj2 p-env i-ffi sx-node cg-interf i-modify ex-import ex-syntax ex-expose ex-direct cg-dld sx-write)
   export (
    ((name . expand-syntax) (pos . 24) (origin ex-expr . expand-syntax))
    ((name . filter-vars) (pos . 7) (origin ex-expr . filter-vars))
    ((name . complete-lambda-node) (pos . 33) (origin ex-expr . complete-lambda-node))
    ((name . filter-init-forms) (pos . 37) (origin ex-expr . filter-init-forms))
    ((name . macroexpand) (pos . 11) (origin ex-expr . macroexpand))
    ((name . protect-tilde) (pos . 17) (origin ex-expr . protect-tilde))
    ((name . macroexpand-1) (pos . 6) (origin ex-expr . macroexpand-1))
    ((name . expand-syntax-1) (pos . 23) (origin ex-expr . expand-syntax-1))
    ((name . *nil*) (pos . 2) (origin ex-expr . *nil*) (class . constant))
    ((name . protect-newline) (pos . 40) (origin ex-expr . protect-newline))
    ((name . protect-backslash) (pos . 3) (origin ex-expr . protect-backslash))
    ((name . protect-doublequote) (pos . 32) (origin ex-expr . protect-doublequote))
   )
   local-literals (
    (top-level . 356)
    (protect-backslash . 355)
    (check-appl-arity . 354)
    (box-binding . 353)
    (macroexpand-1 . 352)
    (filter-vars . 351)
    (labelssetq . 350)
    (get-appl-expander . 349)
    (expand-local-static-vars . 348)
    (macroexpand . 347)
    (labelsvar . 346)
    (expand-local-static-vars* . 345)
    (get-id-expander . 344)
    (default-appl-expander . 343)
    (expand-exprs . 342)
    (protect-tilde . 341)
    (check-id-binding . 340)
    (expand-fun-form . 339)
    (get-keyword-node . 338)
    (unfold-rest-arg-appl . 337)
    (lift-appl . 336)
    (expand-syntax-1 . 335)
    (expand-syntax . 334)
    (letfunsvar . 333)
    (lambda-rest-args? . 332)
    (lift-let*-vars . 331)
    (expr-expander . 330)
    (macroexpanded? . 329)
    (letfunssetq . 328)
    (protect-doublequote . 327)
    (complete-lambda-node . 326)
    (expand-expr . 325)
    (compute-range-and-domain . 324)
    (get-macro-expander . 323)
    (filter-init-forms . 322)
    (dummy-args . 321)
    (rest-args? . 320)
    (protect-newline . 319)
    (get-t-node . 318)
    (install-expr-expander . 317)
    ("redefinition of expander ~a" . 315)
    ("\n" . 312)
    ("\n" . 311)
    ("\n" . 310)
    ("\n" . 309)
    ("RESULT: ~a" . 301)
    ("APPLY MACRO: ~a" . 300)
    (|(method G006297)| . 299)
    ("bad macro expansion of ~a in ~s" . 297)
    ("compile time error condition: " . 296)
    ("\"" . 288)
    ("\"" . 287)
    ("\"" . 286)
    ("\"" . 285)
    ("    Expanding ~a" . 281)
    ("expand-syntax-1: expression ~a is not a cons" . 272)
    ("expand-syntax-1: cannot find syntax binding ~a" . 271)
    ("expand-syntax-1 cannot find dynamic binding ~a for syntax binding ~a" . 270)
    (fpi-binary . 267)
    (setter . 263)
    ("no lexical binding ~a available in ~s" . 262)
    (ff . 260)
    (opencoding . 259)
    ("~~" . 257)
    ("~~" . 256)
    ("~~" . 255)
    ("~~" . 254)
    (args: . 250)
    (fun: . 249)
    ("no lexical binding ~a available in ~s" . 245)
    (fpi-zero? . 236)
    (binary= . 235)
    (binary- . 234)
    (fpi-binary- . 233)
    (dec . 232)
    (inc . 231)
    (binary+ . 230)
    (boot1 . 229)
    (fpi-binary+ . 228)
    (<= . 227)
    (fpi-binary= . 226)
    (>= . 225)
    (< . 224)
    (= . 223)
    (fpi-binary< . 222)
    (compare . 221)
    (> . 220)
    (number . 219)
    ((+ - * / %) . 218)
    (% . 217)
    (/ . 216)
    (* . 215)
    (- . 214)
    (+ . 213)
    ("  wrapping lambda in operator position: ~s" . 212)
    ("macroexpand-1: expression ~a is not a cons" . 207)
    ("macroexpand-1: cannot find syntax binding ~a" . 206)
    ("macroexpand-1 cannot find dynamic binding ~a for syntax binding ~a" . 205)
    (execute . 204)
    (arity . 202)
    ("box binding ~a" . 201)
    ("too few arguments calling ~a" . 199)
    ("too many arguments calling ~a" . 198)
    ("too few arguments calling ~a" . 197)
    ("\\" . 195)
    ("\\" . 194)
    ("\\" . 193)
    ("\\" . 192)
    (letfuns . 190)
    (opencoded-lambda . 189)
    (named-lambda . 188)
    (lambda . 187)
    (|(method lift-setq)| . 186)
    (setq . 185)
    (|(method lift-if)| . 184)
    (call-next-method . 183)
    (|(method check-appl)| . 182)
    (lift-setq . 181)
    (lift-if . 180)
    (check-appl . 179)
    ("no applicable object ~a in ~s" . 177)
    ("macro binding ~a should be in syntax import in ~s" . 176)
    (*encl-lambda* . 169)
    ("missing else branch in (if ~a ...) in ~s" . 166)
    ("bad if syntax (if ~a ...) in ~s" . 165)
    (|(method G006807)| . 164)
    ("bad if syntax ~a in ~s" . 162)
    ("compile time error condition: " . 161)
    (else: . 158)
    (then: . 157)
    (pred: . 156)
    ("unknown context" . 151)
    (if . 150)
    (value: . 145)
    (|(method G006898)| . 144)
    ("bad quote syntax" . 142)
    ("compile time error condition: " . 141)
    (quote . 138)
    (|(method G006920)| . 137)
    ("bad quasiquote syntax" . 135)
    ("compile time error condition: " . 134)
    (append . 131)
    (unquote-splicing . 130)
    (cons . 129)
    (unquote . 128)
    (quasiquote . 127)
    ("immutable binding ~a cannot be modified in ~s" . 125)
    ("no binding ~a available in ~s" . 124)
    (*clean-ups* . 123)
    (tail-pos? . 122)
    (|(method G006968)| . 121)
    ("bad setq syntax" . 119)
    ("compile time error condition: " . 118)
    ("body ~a not a list" . 107)
    (|(method G007054)| . 106)
    ("bad lambda syntax" . 104)
    ("compile time error condition: " . 103)
    ("body ~a not a list" . 100)
    ("~a" . 99)
    (|(method G007081)| . 98)
    ("bad named lambda syntax" . 96)
    ("compile time error condition: " . 95)
    ("body ~a not a list" . 92)
    (|(method G007113)| . 91)
    ("bad lambda syntax" . 89)
    ("compile time error condition: " . 88)
    ("body ~a not a list" . 85)
    (|(method G007140)| . 84)
    ("bad opencoded-lambda syntax" . 82)
    ("compile time error condition: " . 81)
    (labels . 78)
    (inlined-lambda . 77)
    (let* . 76)
    (|(method G007169)| . 75)
    ("bad let syntax" . 73)
    ("compile time error condition: " . 72)
    ("" . 68)
    (progn . 67)
    (|(method G007217)| . 66)
    ("bad let* syntax" . 64)
    ("compile time error condition: " . 63)
    (|(method G007254)| . 60)
    ("bad labels syntax" . 58)
    ("compile time error condition: " . 57)
    (let . 54)
    (|(method G007284)| . 53)
    (anonymous . 52)
    (ct-error-value: . 50)
    ("bad letfuns syntax" . 49)
    ("compile time error condition: " . 48)
   )
   literals (
   )
))
